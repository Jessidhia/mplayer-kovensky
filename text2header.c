/*
 * Convert files to C headers, which embed the file contents as string literals.
 *
 * This file is part of mplayer2.
 *
 * mplayer2 is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * mplayer2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with mplayer2; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <assert.h>
#include <string.h>
#include <stdint.h>

#include "config.h"
#include "bstr.h"
#include "talloc.h"
#include "mpcommon.h"

const char help[] =
"Usage:\n"
"   text2header [options] infile outfile.h\n"
"Convert the contents of infile to a string literal embedded into the\n"
"output file outfile.h. The output file will be overwritten if it exists.\n"
"Options:\n"
"   --sections    Parse the input file for section markers, and generate one\n"
"                 string literal for each named section.\n"
"                 Each section is started with a header and the section name:\n"
"                     #!section foo\n"
"                 In this case, the section name is 'foo'. The generated file\n"
"                 will contain a variable of type const char[] named after the\n"
"                 section header, in the example above:\n"
"                     static const char foo[] = ....;\n"
"                 The text before the first section header is ignored.\n"
"                 Lines starting with #!// are ignored as well.\n"
;

#define BSTR_F "%.*s"

#define SECTION_HEADER "#!section "
#define COMMENT "#!//"

// escape text s as C string literals (doesn't add the outer quotes)
// returns s as-is (same memory allocation) if no escaping needed
//
// incomplete, should probably handle binary data too
struct bstr escape_c(struct bstr s)
{
    if (bstrchr(s, '\"') < 0 && bstrchr(s, '\\') < 0)
        return s;
    char *res = talloc_size(NULL, s.len * 2); // at most 1 new char per char
    int pos = 0;
    for (int n = 0; n < s.len; n++) {
        char cur = s.start[n];
        if (cur == '\"' || cur == '\\') {
            res[pos++] = '\\';
        }
        res[pos++] = cur;
    }
    return (struct bstr) {res, pos};
}

struct bstr process_sections(const char *sourcefile, struct bstr in)
{
    char *res = NULL;
    struct bstr *lines = bstr_splitlines(NULL, in);
    int line_count = MP_TALLOC_ELEMS(lines);
    struct bstr current_section = {0};

    res = talloc_asprintf_append(res,
        "// automatically generated by text2header from '%s'\n"
        "// do not edit!\n\n", sourcefile);

    for (int n = 0; n < line_count; n++) {
        struct bstr line = lines[n];
        if (bstr_endswith0(line, "\n"))
            line.len--;
        if (bstr_startswith0(line, SECTION_HEADER)) {
            if (current_section.len)
                res = talloc_asprintf_append(res, ";\n\n");
            current_section = bstr_splice(line, strlen(SECTION_HEADER),
                                          line.len);
            res = talloc_asprintf_append(res, "static const char " BSTR_F "[]"
                                         " = \n", BSTR_P(current_section));
        } else if (bstr_startswith0(line, COMMENT)) {
            // ignore comment
        } else if (current_section.len) {
            struct bstr s = escape_c(line);
            res = talloc_asprintf_append(res, "    \"" BSTR_F "\\n\"\n",
                                         BSTR_P(s));
            if (s.start != line.start)
                talloc_free(s.start);
        } else {
            // ignore text that is not in any sections
        }
    }

    if (current_section.len)
        res = talloc_asprintf_append(res, ";\n");

    talloc_free(lines);

    return (struct bstr) {res, strlen(res)};
}

int main(int argc, char **argv)
{
    int mode = 0;
    int n;
    char *infile = NULL, *outfile = NULL;
    for (n = 1; n < argc; n++) {
        char *arg = argv[n];
        if (strcmp(arg, "--sections") == 0) {
            mode = 1;
        } else if (arg[0] == '-') {
            fprintf(stderr, "%s", help);
            return 1;
        } else {
            if (!infile) {
                infile = arg;
            } else if (!outfile) {
                outfile = arg;
            } else {
                fprintf(stderr, "%s", help);
                return 1;
            }
        }
    }

    if (!mode || !infile || !outfile) {
        fprintf(stderr, "%s", help);
        return 1;
    }

    FILE *f_in = fopen(infile, "rb");
    if (!f_in) {
        fprintf(stderr, "couldn't open input file\n");
        return 1;
    }
    fseek(f_in, 0, SEEK_END);
    long in_size = ftell(f_in);
    fseek(f_in, 0, SEEK_SET);
    void *in_data = talloc_size(NULL, in_size);
    fread(in_data, in_size, 1, f_in);
    if (ferror(f_in)) {
        fprintf(stderr, "error reading input file\n");
        return 1;
    }
    fclose(f_in);
    struct bstr in_data_str = (struct bstr) { in_data, in_size };
    struct bstr res;

    if (mode == 1) {
        res = process_sections(infile, in_data_str);
    }

    FILE *f_out = fopen(outfile, "wb");
    if (!f_out) {
        fprintf(stderr, "couldn't open output file\n");
        return 1;
    }
    fwrite(res.start, res.len, 1, f_out);
    fflush(f_out);
    if (fclose(f_out) != 0) {
        fprintf(stderr, "error writing output file\n");
    }

    talloc_free(in_data_str.start);
    talloc_free(res.start);

    return 0;
}
