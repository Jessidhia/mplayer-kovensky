<?xml version="1.0" encoding="utf-8"?>
<!-- in sync with r24549 -->
<!-- missing cosmetic commit 21537 -->
<chapter id="encoding-guide">
  <title>Encodieren mit <application>MEncoder</application></title>

  <sect1 id="menc-feat-dvd-mpeg4">
    <title>Erzeugen eines hochwertigen MPEG-4-Rips ("DivX") eines DVD-Films</title>

    <para>
      Eine häufig gestellte Frage ist
      "Wie mache ich den hochwertigsten Rip für eine gegebene Größe?".
      Eine weitere Frage ist
      "Wie mache ich den qualitativ bestmöglichen DVD-Rip? Die Dateigröße ist
      mir egal, ich will einfach nur die beste Qualität."
    </para>

    <para>
      Die letzte Frage ist zumindest etwas falsch gestellt. Wenn du dir
      schließlich keine Gedanken um die Dateigröße machst, warum kopierst Du
      dann nicht einfach den kompletten MPEG-2-Videostream der DVD?
      Sicherlich, deine AVI wird am Ende 5GB groß sein, so oder so, jedoch ist
      dies mit Sicherheit deine beste Option, wenn du die beste Qualität
      erhalten willst und dich nicht um die Größe kümmerst.
    </para>

    <para>
      Tatsache ist, der Grund eine DVD in MPEG-4 umzuencodieren ist
      gerade <emphasis role="bold">weil</emphasis> dir die Größe wichtig ist.
    </para>

    <para>
      Es ist sehr schwierig, ein Rezept zum Erzeugen eines sehr
      hochwertigen DVD-Rips anzubieten. Es gilt mehrere Faktoren zu
      berücksichtigen, und du solltest dich mit diesen Details auskennen oder
      du wirst voraussichtlich am Ende von den Resultaten enttäuscht.
      Nachfolgend werden wir einige dieser Themen etwas näher untersuchen
      und uns danach ein Beispiel ansehen. Wir gehen davon aus, dass Du
      <systemitem class="library">libavcodec</systemitem> zum Encodieren des
      Videos verwendest, obwohl diese Theorie genauso gut auf andere Codecs
      zutrifft.
    </para>

    <para>
      Ist dies alles zu viel für dich, solltest du womöglich auf eins der vielen
      guten Frontends zurückgreifen, die in der
      <ulink url="http://www.mplayerhq.hu/design7/projects.html#mencoder_frontends">MEncoder-Sektion</ulink>
      unserer diesbezüglichen Projektseite zu finden sind.
      Auf diese Weise solltest du in der Lage sein, hochwertige Rips zu
      erhalten ohne viel nachdenken zu müssen, da die meisten dieser Tools dazu entworfen
      wurden, clevere Entscheidungen für dich zu treffen.
    </para>

    <sect2 id="menc-feat-dvd-mpeg4-preparing-encode">
      <title>Vorbereitung aufs Encodieren: Identifiziere Quellmaterial und Framerate</title>
      <para>
        Bevor du über das Encodieren eines Films nachdenkst, solltest du einige einleitende
        Schritte vornehmen.
      </para>

      <para>
        Der erste und allerwichtigste Schritt vor dem Encodieren sollte sein,
        festzustellen, mit welchem Inhaltstyp du umgehst.
        Kommt dein Quellmaterial von einer DVD oder einem Rundfunk-/Kabel-/Satelliten-TV,
        wird es in einem von zwei Formaten abgespeichert: NTSC für Nord-Amerika und Japan,
        PAL für Europa usw.
        Es ist wichtig, sich klar zu machen, dass dies ganz einfach die Formatierung
        für die Präsentation auf einem Fernsehgerät ist und häufig
        <emphasis role="bold">nicht</emphasis> mit dem originalen Format des Films
        korrespondiert. Die Erfahrung zeigt, dass NTSC-Material schwieriger zu
        encodieren ist, da mehr Elemente in der Quelle zu identifizieren sind.
        Um eine geeignete Encodierung zu produzieren, solltest du das originale
        Format kennen.
        Fehler, dies sollte man berücksichtigen, führen zu diversen Fehlerstellen
        in deiner Encodierung, einschließlich hässlicher Kammartefakte (combing/interlacing)
        und doppelten oder gar verlorenen Frames.
        Abgesehen davon, dass sie unschön sind, beeinflussen diese Artefakte die
        Codierungseffizienz negativ:
        Du erhältst eine schlechtere Qualität pro Bitrateneinheit.
      </para>

      <sect3 id="menc-feat-dvd-mpeg4-preparing-encode-fps">
        <title>Identifizieren der Quellframerate</title>
        <para>
          Hier ist eine Liste der verbreiteten Typen des Quellmaterials, in der Du
          diese und ihre Eigenschaften voraussichtlich finden wirst:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="bold">Standardfilm</emphasis>: Produziert für
              theatralische Anzeige bei 24fps.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">PAL-Video</emphasis>: Aufgenommen mit einer
              PAL-Videokamera bei 50 Feldern pro Sekunde.
              Ein Feld besteht ganz einfach aus den ungerade oder gerade nummerierten
              Zeilen eines Frames.
              Das Fernsehen wurde entworfen, diese Felder als billige Form einer
              analogen Komprimierung im Wechsel zu aktualisieren.
              Das menschliche Auge kompensiert dies angeblich, aber wenn du
              Interlacing einmal verstanden hast, wirst du lernen, es auch auf
              dem TV-Bildschirm zu erkennen und nie wieder Spass am Fernsehen haben.
              Zwei Felder machen <emphasis role="bold">keinen</emphasis> kompletten
              Frame, da sie in einer 50-stel Sekunde zeitlich getrennt aufgenommen
              werden und so nicht Schlange stehen solange keine Bewegung da ist.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">NTSC-Video</emphasis>: Aufgenommen mit einer
              NTSC-Videokamera bei 60000/1001 Feldern pro Sekunde oder 60 Feldern
              pro Sekunde zu Zeiten vor dem Farbfernsehen.
              Ansonsten ähnlich wie PAL.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">Animation</emphasis>: Üblicherweise bei
              24fps gezeichnet, kommt jedoch auch in Varianten mit gemischter
              Framerate vor.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">Computer Graphics (CG)</emphasis>: Kann
              irgendeine Framerate sein, jedoch sind einige üblicher als andere;
              24 und 30 Frames pro Sekunde sind typisch für NTSC und 25fps ist
              typisch für PAL.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">Alter Film</emphasis>: Diverse niedrigere
              Frameraten.
            </para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 id="menc-feat-dvd-mpeg4-preparing-encode-material">
        <title>Identifizieren des Quellmaterials</title>
        <para>
          Filme, die sich aus Frames zusammensetzen, werden den progressiven
          zugeordnet, während die aus unabhängigen Feldern bestehenden
          entweder interlaced (engl. für verschachteln) oder Video
          genannt werden - somit ist letzterer Terminus zweideutig.
        </para>
        <para>
          Um das ganze noch komplizierter zu machen, sind manche Filme ein
          Gemisch aus einigen den oben beschriebenen Formen.
        </para>
        <para>
          Das wichtigste Unterscheidungsmerkmal zwischen all diesen
          Formaten ist, dass einige Frame-basiert, andere wiederum
          Feld-basiert sind.
          <emphasis role="bold">Immer</emphasis> wenn ein Film für die
          Anzeige auf dem Fernseher vorbereitet wird (einschließlich
          DVD), wird er in ein Feld-basiertes Format konvertiert.
          Die verschiedenen Methoden, mit denen dies bewerkstelligt werden
          kann, werden zusammengenommen als "telecine" bezeichnet, von welchen
          das verrufene NTSC "3:2 pulldown" eine Abart darstellt.
          Sofern das Originalmaterial nicht Feld-basiert war (bei gleicher
          Feldrate), erhältst du einen Film in einem anderen Format als
          das Original.
        </para>

        <itemizedlist>
          <title>Es gibt einige verbreitete Typen des pulldown:</title>
          <listitem>
            <para>
              <emphasis role="bold">PAL 2:2 pulldown</emphasis>: Das schönste von
              allen.
              Jeder Frame wird durch das wechselweise Extrahieren und Anzeigen
              der geradzahligen und ungeradzahligen Zeilen für die Dauer von zwei
              Feldern dargestellt.
              Hat das Originalmaterial 24fps, beschleunigt dieser Prozess den Film
              um 4%.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">PAL 2:2:2:2:2:2:2:2:2:2:2:3 pulldown</emphasis>:
              Jeder 12-te Frame, anstatt nur jeder 2-te, wird für die Dauer von zwei
              Feldern dargestellt.
              Dies vermeidet die 4% Geschwindigkeitssteigerung, macht jedoch das
              Umkehren des Prozesses viel schwieriger.
              Es ist üblicherweise in Musical-Produktionen zu sehen, wo das Anpassen der
              Geschwindigkeit um 4% sicherlich das musikalische Ergebnis kaputt machen würde.
            </para>
          </listitem>
          <listitem><para>
              <emphasis role="bold">NTSC 3:2 telecine</emphasis>: Frames werden
              abwechselnd für die Dauer von 3 oder 2 Feldern angezeigt.
              Dies verleiht der Feldrate das 2.5-fache der originalen Framerate.
              Das Resultat wird dadurch auch leicht von 60 Feldern pro Sekunde auf
              60000/1001 Felder pro Sekunde verlangsamt, um die NTSC-Felddrate
              beizubehalten.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">NTSC 2:2 pulldown</emphasis>: Verwendet zur
              Darstellung von 30fps Material auf NTSC.
              Schön, genau wie das 2:2 PAL pulldown.
            </para>
          </listitem>
        </itemizedlist>

        <para>
          Es gibt auch Methoden zur Konvertierung zwischen NTSC- und PAL-Video,
          jedoch liegen diese Themen jenseits des Rahmens dieser Anleitung.
          Wenn du auf solch einen Film stößt und ihn encodieren willst, solltest
          du besser eine Kopie im originalen Format suchen.
          Die Konvertierung zwischen diesen beiden Formaten ist hochdestruktiv und
          kann nicht spurlos rückgängig gemacht werden, somit wird deine Encodierung
          außerordentlich darunter leiden, wenn sie aus einer konvertierten Quelle
          erzeugt wurde.
        </para>
        <para>
          Wenn ein Video auf DVD gespeichert wird, werden fortlaufend Feldpaare
          als Frames gruppiert, auch wenn nicht beabsichtigt ist, diese gleichzeitig
          zu zeigen.
          Der bei DVD und digitalem TV verwendete MPEG-2-Standard bietet einen Weg
          für beides, die originalen progressiven Frames zu encodieren und die Anzahl
          der Felder, für die ein Frame gezeigt werden soll, im Header dieses Frames
          zu speichern.
          Wurde diese Methode angewandt, wird dieser Film oft als "soft telecined"
          beschrieben, da der Prozess eher nur den DVD-Player anweist, pulldown
          auf den Film anzuwenden, als den Film selbst abzuändern.
          Dieser Fall sollte möglichst bevorzugt werden, da er (eigentlich ignoriert)
          leicht vom Encoder rückgängig gemacht werden kann und da er die maximale
          Qualität beibehält.
          Wie auch immer, viele DVD- und Rundfunkproduktionsstudios verwenden
          keine passenden Encodierungstechniken, sie produzieren stattdessen Filme mit
          "hard telecine", bei denen Felder sogar in encodiertes MPEG-2 dupliziert
          werden.
        </para>
        <para>
          Die Vorgehensweisen für den Umgang mit solchen Fällen werden
          <link linkend="menc-feat-telecine">später in diesem Handbuch</link>
          behandelt.
          Wir lassen dich jetzt mit einigen Anleitungen zur Identifizierung der
          Materialtypen zurück, mit denen du es zu tun hast:
        </para>

        <itemizedlist>
          <title>NTSC-Bereiche:</title>
          <listitem>
            <para>
              Wenn <application>MPlayer</application> angibt, dass die Framerate
              während des Betrachtens des Films zu 24000/1001 gewechselt hat
              und diese nie wieder zurückwechselt, handelt es sich meist mit
              Sicherheit um progressiven Inhalt, der "soft telecined" wurde.
            </para>
          </listitem>
          <listitem>
            <para>
              Wenn <application>MPlayer</application> anzeigt, dass die Framerate
              zwischen 24000/1001 und 30000/1001 vor und zurück wechselt, und Du
              siehst hin und wieder Kammartefakte, dann gibt es mehrere Möglichkeiten.
              Die Segmente mit 24000/1001 fps sind meist mit Sicherheit progressiver
              Inhalt, "soft telecined", jedoch könnten die Teile mit 30000/1001 fps
              entweder "hard telecined" 24000/1001 fps Inhalt oder 60000/1001 Felder
              pro Sekunde NTSC-Video sein.
              Verwende die selben Richtwerte wie in den folgenden zwei Fällen, um zu
              bestimmen, um was es sich handelt.
            </para>
          </listitem>
          <listitem>
            <para>
              Wenn <application>MPlayer</application> nie einen Frameratenwechsel
              anzeigt und jeder einzelne Frame mit Bewegung gekämmt (combed) erscheint,
              ist dein Film ein NTSC-Video bei 60000/1001 Feldern pro Sekunde.
            </para>
          </listitem>
          <listitem>
            <para>
              Wenn <application>MPlayer</application> nie einen Frameratenwechsel
              anzeigt und zwei von fünf Frames gekämmt (combed) erscheinen, ist der
              Inhalt deines Films "hard telecined" 24000/1001 fps.
            </para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>PAL-Bereiche:</title>
          <listitem>
            <para>
              Wenn du niemals irgend ein Combing siehst, ist dein Film 2:2 pulldown.
            </para>
          </listitem>
          <listitem>
            <para>
              Siehst du alle halbe Sekunde abwechselnd ein- und ausgehendes Combing,
              dann ist dein Film 2:2:2:2:2:2:2:2:2:2:2:3 pulldown.
            </para>
          </listitem>
          <listitem>
            <para>
              Hast du immer während Bewegungen Combing gesehen, dann ist dein Film
              PAL-Video bei 50 Feldern pro Sekunde.
            </para>
          </listitem>
        </itemizedlist>

        <note>
          <title>Tipp:</title>
          <para>
            <application>MPlayer</application> kann das Filmplayback
            mittels der Option -speed verlangsamen oder Frame für Frame abspielen.
            Versuche <option>-speed</option> 0.2 zu verwenden, um den Film sehr lamgsam
            anzusehen oder drücke wiederholt die Taste "<keycap>.</keycap>", um jeweils
            einen Frame abzuspielen und identifiziere dann das Muster, falls du bei voller
            Geschwindigkeit nichts erkennen kannst.
          </para>
        </note>
      </sect3>
    </sect2>

    <sect2 id="menc-feat-dvd-mpeg4-2pass">
      <title>Konstanter Quantisierungsparameter vs. Multipass</title>

      <para>
        Es ist möglich, deinen Film in einer großen Auswahl von Qualitäten zu
        encodieren.
        Mit modernen Videoencodern und ein wenig Pre-Codec-Kompression
        (Herunterskalierung und Rauschunterdrückung), kann eine sehr gute
        Qualität bei 700 MB für einen 90-110-minütigen Breitwandfilm erreicht werden.
        Des Weiteren können alle Filme - sogar die längsten - mit nahezu perfekter
        Qualität bei 1400 MB encodiert werden.
      </para>

      <para>
        Es gibt drei Annäherungen für das Encodieren eines Videos: konstante Bitrate
        (CBR), konstanter Quantisierungsparameter und Multipass (ABR, oder mittlere Bitrate).
      </para>

      <para>
        Die Komplexität der Frames eines Filmes und somit die Anzahl der für
        deren Komprimierung erforderlichen Bits kann von einer Szene zur anderen
        außerordentlich variieren.
        Moderne Videoencoder können sich durch Variieren der Bitrate an diese
        Anforderungen anpassen.
        In einfachen Modi wie CBR kennen die Encoder jedoch nicht den
        Bitratenbedarf zukünftiger Szenen und sind somit nicht in der Lage,
        die angeforderte mittlere Bitrate über längere Zeitspannen zu
        überschreiten.
        Erweiterte Modi wie etwa Multipass-Encodierung können die Statistik
        früherer Durchgänge berücksichtigen; dies behebt das oben erwähnte
        Problem.
      </para>

      <note><title>Anmerkung:</title>
        <para>
          Die meisten Codecs, die ABR-Encodierung unterstützen, unterstützen nur
          die Encodierung in zwei Durchgängen (two pass) während einige andere wie
          etwa <systemitem class="library">x264</systemitem>,
          <systemitem class="library">Xvid</systemitem>
          und <systemitem class="library">libavcodec</systemitem> Multipass
          unterstützen, was die Qualität bei jedem Durchgang leicht verbessert.
          Jedoch ist diese Verbesserung weder messbar noch ist sie nach dem
          4-ten Durchgang oder so spürbar.
          Aus diesem Grund werden in diesem Abschnitt die Encoderierung mit 2 Durchläufen
          (two pass) und Multipass abwechselnd angewandt.
        </para>
      </note>

      <para>
        In jedem dieser Modi bricht der Videocodec (wie etwa
        <systemitem class="library">libavcodec</systemitem>)
        den Videoframe in 16x16 Pixel Macroblöcke und wendet danach einen
        Quantisierer auf jeden Macroblock an. Je niedriger der Quantisierer desto
        besser die Qualität und desto höher die Bitrate.
        Die Methode, die der Filmencoder zur Bestimmung des auf einen gegebenen
        Macroblock anzuwendenden Quantisierer verwendet, variiert und ist in
        hohem Maße einstellbar. (Dies ist eine extrem übertriebene Vereinfachung
        des aktuellen Prozesses aber nützlich, um das Grundkonzept zu verstehen.)
      </para>

      <para>
        Wenn du eine konstante Bitrate festlegst, wird der Videocodec das Video
        so encodieren, dass so viele Details wie notwendig und so wenig
        wie möglich ausgesondert werden, um unterhalb der vorgegebenen Bitrate zu
        bleiben. Wenn du dich wirklich nicht um die Dateigröße kümmerst, könntest
        du auch CBR verwenden und eine nahezu endlose Bitrate festlegen.
        (In der Praxis bedeutet dies einen Wert, der hoch genug ist, kein Limit
        aufzuwerfen wie 10000Kbit.) Ohne echte Einschränkung der Bitrate wird
        der Codec als Ergebnis den niedrigsten möglichen Quantisierer für jeden
        Macroblock anwenden (wie durch <option>vqmin</option> für
        <systemitem class="library">libavcodec</systemitem>
        spezifiziert, Standardwert ist 2).
        Sobald du eine Bitrate festlegst, die niedrig genug ist, den
        Codec zur Anwendung eines höheren Quantisierers zu zwingen, bist Du
        nahezu sicher dabei, die Qualität deines Videos zu ruinieren.
        Um dies zu vermeiden, solltst du möglicherweise dein Video wie
        in der später in diesem Handbuch beschriebenen Methode reduzieren.
        Im Allgemeinen solltst du CBR vollkommen meiden, wenn dir Qualität
        wichtig ist.
      </para>

      <para>
        Mit konstantem Quantisierer wendet der Codec denselben Quantisierer, wie
        durch die Option <option>vqscale</option> (für
        <systemitem class="library">libavcodec</systemitem>) spezifiziert, auf jeden
        Macroblock an.
        Willst du einen Rip mit höchstmöglicher Qualität und ignorierst dabei
        wiederum die Bitrate, kannst du <option>vqscale=2</option> verwenden.
        Dies wird dieselbe Bitrate und PSNR (peak signal-to-noise ratio) liefern
        wie CBR mit <option>vbitrate</option>=infinity und der Standardeinstellung
        <option>vqmin</option>=2.
      </para>

      <para>
        Das Problem mit konstantem Quantisierer ist, dass der vorgegebene Quantisierer
        zum Einsatz kommt, egal ob der Macroblock ihn benötigt oder nicht. Dies heißt,
        es wäre möglich, einen höheren Quantisierer auf einen Macroblock anzuwenden,
        ohne sichtbare Qualität zu opfern. Warum die Bits für einen unnötig kleinen
        Quantisierer verschwenden? Deine CPU hat soundso viele Arbeitsgänge Zeit zur
        Verfügung, die Festplatte jedoch nur soundso viele Bits.
      </para>

      <para>
        Bei einer Encodierung mit zwei Durchläufen (two pass), wird der erste Durchgang
        den Film so rippen, als würde CBR vorliegen, jedoch wird ein Log die Eigenschaften
        jedes Frames beibehalten. Diese Daten werden danach während des zweiten Durchgangs
        dazu verwendet, intelligente Entscheidungen zur Wahl des Quantisierers zu treffen.
        Während schneller Action oder hochdetaillierter Szenen werden womöglich
        höhere Quantisierer, während langsamen Bewegungen und Szenen mit weniger Details
        niedrigere Quantisierer verwendet.
        Normalerweise ist die Anzahl der Bewegungen wichtiger als die der Details.
      </para>

      <para>
        Wenn du <option>vqscale=2</option> verwendest, verschwendest du Bits. Wenn
        du <option>vqscale=3</option> anwendest, wirst du keinen Rip mit bestmöglicher
        Qualität erhalten. Angenommen du rippst eine DVD mit <option>vqscale=3</option>
        und das Resultat ist 1800Kbit. Wenn du in zwei Durchgängen mit
        <option>vbitrate=1800</option> encodierst, wird das daraus resultierende Video
        eine <emphasis role="bold">bessere Qualität</emphasis> bei
        <emphasis role="bold">gleicher Bitrate</emphasis> haben.
      </para>

      <para>
        Da du nun davon überzeugt bist, dass zwei Durchgänge (two pass) den besten
        Weg darstellen, stellt sich jetzt tatsächlich die Frage, welche Bitrate
        verwendet werden soll? Die Antwort ist, dass es nicht nur eine
        Antwort gibt. Idealerweise willst du eine Bitrate wählen, die die beste Balance
        zwischen Qualität und Dateigröße ergibt. Die kann abhängig vom Quellvideo
        variieren.
      </para>

      <para>
        Interessiert die Größe nicht, stellen etwa 2000Kbit plus oder minus 200Kbit
        einen guten Ausgangspunkt für einen sehr hochqualitativen Rip dar.
        Bei einem Video mit schneller Action oder hohen Details, oder wenn du schlicht
        und ergreifend ein sehr kritisches Auge besitzst, könntest du dich für 2400
        oder 2600 entscheiden.
        Bei einigen DVDs kannst du eventuell keinen Unterschied bei 1400Kbit feststellen.
        Um ein besseres Gefühl zu bekommen, ist es eine gute Idee, mit Szenen bei
        unterschiedlichen Bitraten herumzuexperimentieren.
      </para>

      <para>
        Wenn du eine bestimmte Größe anvisierst, musst du die Bitrate irgendwie
        kalkulieren.
        Aber zuvor solltest du wissen, wieviel Platz du für den/die Audiotrack(s)
        reservieren musst, daher solltest Du
        <link linkend="menc-feat-dvd-mpeg4-audio">diese(n) zuerst rippen</link>.
        Du kannst die Bitrate mit folgender Gleichung berechnen:
        <systemitem>Bitrate = (zielgroesse_in_MByte - soundgroesse_in_MByte) * 1024 * 1024 / laenge_in_sek * 8 / 1000</systemitem>
        Um zum Beispiel einen zweistündigen Film auf eine 702MB CD mit einem 60MB
        Audiotrack zu bekommen, sollte die Videobitrate folgendermaßen sein:
        <systemitem>(702 - 60) * 1024 * 1024 / (120*60) * 8 / 1000 = 740kbps</systemitem>
      </para>

    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-constraints">
      <title>Randbedingungen für effizientes Encodieren</title>

      <para>
        Aufgrund der Natur der MPEG-Komprimierung gibt es zahlreiche
        Randbedingungen, denen du zum Erreichen maximaler Qualität folgen
        solltest.
        MPEG splittet das Video in Macroblöcke genannte 16x16 Quadrate auf,
        jeder davon zusammengesetzt aus 4 8x8 Blöcken mit
        Luma-(Intensitäts)-Informationen und zwei halb-auflösenden 8x8
        Chroma-(Farb)-Blöcken (einer für die Rot-Cyan-Achse und der andere für
        die Blau-Gelb-Achse).
        Selbst wenn Breite und Höhe deines Films kein Vielfaches von 16 sind,
        wird der Encoder ausreichend 16x16 Macroblöcke zur Abdeckung des
        gesamten Bildbereichs verwenden und der Extraplatz wird verschwendet.
        Folglich ist es keine gute Idee, im Interesse der Maximierung der
        Qualität bei fester Dateigröße, Abmessungen zu verwenden, die kein
        Vielfaches von 16 sind.
      </para>

      <para>
        Die meisten DVDs besitzen ein bestimmtes Maß schwarzer Balken
        an ihren Rändern. Diese dort zu belassen wird für die Qualität in mehrfacher
        Hinsicht <emphasis role="bold">sehr</emphasis> schädlich sein.
      </para>

      <orderedlist>
        <listitem>
          <para>
            MPEG-Kompression hängt in höchstem Maße von den
            Frequenzbereichs-Transformationen ab, insbesondere von der
            Discrete Cosine Transform (DCT), die der Fourier Transform ähnelt.
            Diese Art Encodierung ist für darstellende Muster und weiche
            Übergänge effizient, hat jedoch große Probleme mit scharfen Kanten.
            Um diese zu encodieren muss sie viel mehr Bits verwenden,
            oder es wird andernfalls ein als Ringing bekannter Artefakt
            auftreten.
          </para>

          <para>
            Die Discrete Frequency Transform (DCT) erfolgt separat auf jeden
            Macroblock (eigentlich auf jeden Block), somit trifft dieses Problem
            nur zu, wenn sich in einem Block eine scharfe Kante befindet.
            Beginnt dein schwarzer Rand exakt an den Grenzen zum Vielfachen von
            16 Pixeln, stellt dies kein Problem dar.
            Seis drum, die schwarzen Ränder bei DVDs werden in den seltensten
            Fällen schön angeordnet, daher wirst du sie in der Praxis immer
            abschneiden müssen, um diesen Nachteil zu vermeiden.
          </para>
        </listitem>
      </orderedlist>

      <para>
        Zusätzlich zu den Frequenzbereichs-Transformationen verwendet die
        MPEG-Kompression Bewegungsvektoren, um den Wechsel von einem Frame
        zum anderen darzustellen.
        Bewegungsvektoren arbeiten bei Inhalt, der von den Kanten eines Bildes
        her einfließt, normalerweise weniger effizient, da dieser im vorherigen
        Frame nicht vorhanden ist. Solange sich das Bild bis voll zur Kante des
        encodierten Bereichs hin vergrößert, haben Bewegungsvektoren kein Problem
        mit Inhalt, der sich aus den Kanten des Bildes hinausbewegt. Die Präsenz
        schwarzer Ränder kann jedoch Ärger machen:
      </para>

      <orderedlist continuation="continues">
        <listitem>
          <para>
            Die MPEG-Kompression speichert für jeden Macroblock einen Vektor,
            um ausfindig zu machen, welcher Teil des vorherigen Frames in diesen
            Macroblock als Basis zur Vorhersage des nächsten Frames kopiert
            werden soll. Nur die verbleibenden Unterschiede müssen encodiert werden.
            Überspannt der Macroblock die Kante des Bildes und enthält einen
            Teil des schwarzen Randes, werden Bewegungsvektoren aus anderen
            Teilen des Bildes den schwarzen Rand überschreiben. Dies bedeutet, dass
            jede Menge Bits entweder zur wiederholten Schwärzung des überschriebenen
            Randes aufgewendet werden müssen, oder es wird (eher) erst gar kein
            Bewegungsvektor genutzt und alle Änderungen innerhalb dieses Macroblocks
            müssen explizit encodiert werden. So oder so wird die Encodiereffizienz
            außerordentlich reduziert.
          </para>

          <para>
            Nochmal, dieses Problem trifft nur dann zu, wenn schwarze Ränder
            nicht an den Grenzen eines Vielfachen von 16 anstehen.
          </para>
        </listitem>

        <listitem>
          <para>
            Zuletzt noch was, angenommen wir haben einen Macroblock im Inneren des
            Bildes und ein Objekt bewegt sich aus Richtung Nähe der Kante des Bildes
            her in diesen Block hinein. Die MPEG-Encodierung kann nicht sagen
            "kopiere den Teil, der innerhalb des Bildes liegt, den schwarzen Rand
            aber nicht". Somit wird der schwarze Rand ebenfalls mit hinein kopiert
            und jede Menge Bits müssen zur Encodierung des Teils des Bildes, der
            dort angenommen wird, aufgewendet werden.
          </para>

          <para>
            Läuft das Bild ständig zur Kante des encodierten Bereichs hin, besitzt
            MPEG spezielle Optimierungen, um immer wieder dann die Pixel am Rand des
            Bildes zu kopieren, wenn ein Bewegungsvektor von außerhalb des
            encodierten Bereichs ankommt. Dieses Feature wird nutzlos, wenn der Film
            schwarze Ränder hat. Im Gegensatz zu den Problemen 1 und 2 hilft hier
            kein Anordnen der Ränder am Vielfachen von 16.
          </para>
        </listitem>

        <listitem>
          <para>
            Obwohl die Ränder komplett schwarz sind und sich nie ändern, ist
            zumindest ein minimaler Overhead damit verbunden, mehr Macroblöcke
            zu besitzen.
          </para>
        </listitem>
      </orderedlist>

      <para>
        Aus all diesen Gründen wird empfohlen, schwarze Ränder komplett abzuschneiden.
        Mehr noch, liegt ein Bereich mit Rauschen/Verzerrung an der Kante des Bildes,
        steigert dessen Abschneiden ebenso die Encodiereffizienz. Videophile Puristen,
        die den Originalzustand so nah wie möglich sichern wollen,
        mögen dieses Abschneiden (cropping) beanstanden, wenn du jedoch nicht planst,
        bei konstantem Quantisierer zu encodieren, wird der Qualitätsgewinn, den Du
        durch dieses Abschneiden erreichst, beträchtlich über dem Verlust an Informationen
        an den Kanten liegen.
      </para>
    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-crop">
      <title>Abschneiden und Skalieren</title>

      <para>
        Wiederaufruf der vorherigen Sektion, dass die letzte von Dir
        encodierte Bildgröße ein Vielfaches von 16 sein sollte (bei beidem,
        Breite und Höhe).
        Diese kann durch Abschneiden, Skalieren erreicht werden oder durch
        eine Kombination von beidem.
      </para>

      <para>
        Beim Abschneiden gibt es ein paar Richtwerte, die befolgt werden müssen,
        um eine Zerstörung des Films zu vermeiden.
        Das normale YUV-Format, 4:2:0, speichert Chroma-(Farb)-Informationen
        in einer Unterstichprobe (subsampled), z.B. wird Chroma nur halb so oft
        in jede Richtung gesampelt wie Luma-(Intensitäts)-Informationen.
        Beobachte dieses Diagramm, in dem L Luma-Samplingpunkte bedeuten und C
        für Chroma steht.
      </para>

      <informaltable>
        <?dbhtml table-width="40%" ?>
        <?dbfo table-width="40%" ?>
        <tgroup cols="8" align="center">
          <colspec colnum="1" colname="col1"/>
          <colspec colnum="2" colname="col2"/>
          <colspec colnum="3" colname="col3"/>
          <colspec colnum="4" colname="col4"/>
          <colspec colnum="5" colname="col5"/>
          <colspec colnum="6" colname="col6"/>
          <colspec colnum="7" colname="col7"/>
          <colspec colnum="8" colname="col8"/>
          <spanspec spanname="spa1-2" namest="col1" nameend="col2"/>
          <spanspec spanname="spa3-4" namest="col3" nameend="col4"/>
          <spanspec spanname="spa5-6" namest="col5" nameend="col6"/>
          <spanspec spanname="spa7-8" namest="col7" nameend="col8"/>
          <tbody>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry spanname="spa1-2">C</entry>
              <entry spanname="spa3-4">C</entry>
              <entry spanname="spa5-6">C</entry>
              <entry spanname="spa7-8">C</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry spanname="spa1-2">C</entry>
              <entry spanname="spa3-4">C</entry>
              <entry spanname="spa5-6">C</entry>
              <entry spanname="spa7-8">C</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        Wie du sehen kannst, kommen Zeilen und Spalten des Bildes natürlich paarweise.
        Folglich <emphasis>müssen</emphasis> deine Abschneide-Offsets und
        Abmessungen geradzahlig sein.
        Sind sie dies nicht, wird Chroma nicht mehr korrekt mit Luma abgeglichen.
        In der Theorie ist es möglich, mit ungeraden Offsets abzuschneiden, jedoch
        erfordert dies ein Resampling von Chroma, was potentiell eine mit Verlust
        verbundene Operation bedeutet und vom Crop-Filter nicht unterstützt
        wird.
      </para>

      <para>
        Weiterhin wird interlaced Video folgendermaßen gesampelt:
      </para>

      <informaltable>
        <?dbhtml table-width="80%" ?>
        <?dbfo table-width="80%" ?>
        <tgroup cols="16" align="center">
          <colspec colnum="1"  colname="col1"/>
          <colspec colnum="2"  colname="col2"/>
          <colspec colnum="3"  colname="col3"/>
          <colspec colnum="4"  colname="col4"/>
          <colspec colnum="5"  colname="col5"/>
          <colspec colnum="6"  colname="col6"/>
          <colspec colnum="7"  colname="col7"/>
          <colspec colnum="8"  colname="col8"/>
          <colspec colnum="9"  colname="col9"/>
          <colspec colnum="10" colname="col10"/>
          <colspec colnum="11" colname="col11"/>
          <colspec colnum="12" colname="col12"/>
          <colspec colnum="13" colname="col13"/>
          <colspec colnum="14" colname="col14"/>
          <colspec colnum="15" colname="col15"/>
          <colspec colnum="16" colname="col16"/>
          <spanspec spanname="spa1-2"   namest="col1" nameend="col2"/>
          <spanspec spanname="spa3-4"   namest="col3" nameend="col4"/>
          <spanspec spanname="spa5-6"   namest="col5" nameend="col6"/>
          <spanspec spanname="spa7-8"   namest="col7" nameend="col8"/>
          <spanspec spanname="spa9-10"  namest="col9" nameend="col10"/>
          <spanspec spanname="spa11-12" namest="col11" nameend="col12"/>
          <spanspec spanname="spa13-14" namest="col13" nameend="col14"/>
          <spanspec spanname="spa15-16" namest="col15" nameend="col16"/>
          <tbody>
            <row>
              <entry namest="col1" nameend="col8">Oberes Feld</entry>
              <entry namest="col9" nameend="col16">Unteres Feld</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry spanname="spa1-2">C</entry>
              <entry spanname="spa3-4">C</entry>
              <entry spanname="spa5-6">C</entry>
              <entry spanname="spa7-8">C</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry spanname="spa9-10">C</entry>
              <entry spanname="spa11-12">C</entry>
              <entry spanname="spa13-14">C</entry>
              <entry spanname="spa15-16">C</entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry spanname="spa1-2">C</entry>
              <entry spanname="spa3-4">C</entry>
              <entry spanname="spa5-6">C</entry>
              <entry spanname="spa7-8">C</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry spanname="spa9-10">C</entry>
              <entry spanname="spa11-12">C</entry>
              <entry spanname="spa13-14">C</entry>
              <entry spanname="spa15-16">C</entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
              <entry>L</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        Wie du erkennen kannst, wiederholt sich das Muster bis nach 4 Zeilen nicht.
        Somit müssen bei interlaced Video dein y-Offset und die Höhe für das
        Ausschneiden ein Vielfaches von 4 sein.
      </para>

      <para>
        Die ursprüngliche DVD-Auflösung ist 720x480 für NTSC und 720x576 für PAL, es
        gibt jedoch ein Aspektkennzeichen, das spezifiziert, ob Vollbild (4:3) oder
        Breitwandfilm (16:9) vorliegt. Viele (wenn nicht die meisten) Breitwandfilm-DVDs
        sind nicht grundsätzlich 16:9, sondern entweder 1.85:1 oder 2.35:1 (Cinescope).
        Dies bedeutet, dass es schwarze Bänder im Video geben wird, die herausgeschnitten
        werden müssen.
      </para>

      <para>
        <application>MPlayer</application> stellt einen Crop-Erkennungsfilter
        zur Verfügung, der das Ausschnittsrechteck (<option>-vf cropdetect</option>)
        bestimmt.
        Starte <application>MPlayer</application> mit
        <option>-vf cropdetect</option>, und er wird die Crop-Einstellungen
        zum Entfernen der Ränder ausgeben.
        du solltest den Film lange genug laufen lassen, damit die gesamte Bildfläche
        verwendet wird, um akkurate Crop-Werte zu erhalten.
      </para>

      <para>
        Teste danach die Werte, die von <application>MPlayer</application>
        über die Befehlszeile mittels <option>cropdetect</option> ausgegeben wurden
        und passe das Rechteck nach deinen Bedürfnissen an.
        Der Filter <option>rectangle</option> kann dabei helfen, indem er dir erlaubt,
        das Rechteck interaktiv über dem Film zu positionieren.
        Vergiss nicht, den oben genannten Teilbarkeitsrichtwerten zu folgen, sodass du
        die Chroma-Ebenen nicht verkehrt anordnest.
      </para>

      <para>
        In bestimmten Fällen könnte Skalieren nicht wünschenswert sein.
        Skalierung in vertikaler Richtung ist mit interlaced Video
        schwierig, und wenn du das Interlacing beibehalten willst, solltest
        du für gewöhnlich das Skalieren bleiben lassen.
        Hast du nicht vor zu skalieren, willst aber nach wie vor Abmessungen
        in einem Vielfachen von 16 verwenden, musst du über den Rand
        hinausschneiden.
        Schneide aber lieber nicht über den Rand hinaus, da schwarze Ränder
        sehr schlecht zu encodieren sind!
      </para>

      <para>
        Weil MPEG-4 16x16 Macroblöcke nutzt, solltest du dich vergewissern,
        dass jede Abmessung des zu encodierenden Videos ein Vielfaches von
        16 ist oder du verschlechterst andernfalls die Qualität, speziell bei
        niedrigeren Bitraten. Du kannst dies durch Abrunden der Breite und
        Höhe des Ausschnittsrechtecks hinunter auf den nächsten Wert eines
        Vielfachen von 16 erreichen.
        Wie früher bereits erklärt, wirst du beim Abschneiden das y-Offset
        um die Hälfte der Differenz der alten und neuen Höhe erhöhen wollen,
        sodass das daraus resultierende Video aus der Mitte des Frames genommen
        wird. Und stelle wegen der Art, wie ein DVD-Video gesampelt wird, sicher,
        dass das Offset eine gerade Zahl ist. (Verwende in der Tat - als eine
        Regel - nie ungerade Werte für irgendwelche Parameter beim Abschneiden
        oder Skalieren eines Videos) Wenn du dich beim Wegwerfen einiger extra
        Pixel nicht wohl fühlst, ziehst du es stattdessen vor, das Video zu
        skalieren.
        Wir werden uns dies im unten stehenden Beispiel mal ansehen.
        Du kannst den <option>cropdetect</option>-Filter sogar alles oben erwähnte
        für dich erledigen lassen, da dieser einen optionalen Parameter
        <option>round</option> besitzt, der standardmäßig gleich 16 ist.
      </para>

      <para>
        Pass auch auf "halbschwarze" Pixel an den Kanten auf. Stelle sicher, dass
        du diese ebenfalls mit abschneidest oder du vergeudest dort Bits, wo sie
        doch besser anderswo verwendet werden sollten.
      </para>

      <para>
        Nachdem nun alles gesagt ist, wirst du möglicherweise bei einem
        Video landen, dessen Pixel nicht ganz 1.85:1 oder 2.35:1, aber ziemlich
        nahe dran sind. Du könntest ein neues Seitenverhältnis manuell berechnen,
        aber <application>MEncoder</application> bietet eine Option für
        <systemitem class="library">libavcodec</systemitem> genannt
        <option>autoaspect</option>, die das für dich erledigt.
        Skaliere dieses Video auf keinen Fall hoch, um die Pixel abzugleichen
        solange du keinen Festplattenplatz verschwenden willst.
        Das Skalieren sollte beim Playback gemacht werden und der Player wird das
        in der AVI gespeicherte Seitenverhältnis zur Bestimmung der besten
        Auflösung verwenden.
        Unglücklicherweise erzwingen nicht alle Player diese Auto-Skalierinformation,
        und deshalb willst du vielleicht trotzdem neu skalieren.
      </para>
    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-resolution-bitrate">
      <title>Auswahl von Auflösung und Bitrate</title>

      <para>
        Wenn du nicht vor hast, im Modus mit konstantem Quantisier zu encodieren,
        musst du eine Bitrate auswählen.
        Das Konzept der Bitrate ist denkbar einfach.
        Sie ist die (mittlere) Anzahl Bits, die pro Sekunde zum Speichern des
        Films verbraucht werden.
        Normalerweise wird die Bitrate in Kilobit (1000 Bit) pro Sekunde gemessen.
        Die Größe deines Films auf der Platte ist die Bitrate multipliziert mit der
        Dauer des Films, plus einem kleinen "Overhead" (siehe zum Beispiel in der
        Sektion über
        <link linkend="menc-feat-dvd-mpeg4-muxing-avi-limitations">den AVI-Container</link>).
        Weitere Parameter wie Skalierung, Cropping, usw. werden die Dateigröße
        <emphasis role="bold">nicht</emphasis> ändern, solange du nicht auch
        die Bitrate veränderst!
      </para>
      <para>
        Die Bitrate skaliert <emphasis role="bold">nicht</emphasis> proportional
        zur Auflösung.
        Dies bedeutet, eine Datei 320x240 mit 200 KBit/Sek wird nicht dieselbe
        Qualität aufweisen wie der gleiche Film bei 640x480 und 800 KBit/Sek!
        Dafür gibt es zwei Gründe:
        <orderedlist>
          <listitem>
            <para>
              <emphasis role="bold">Wahrnehmbar</emphasis>: du bemerkst
              MPEG-Artefakte eher, wenn sie größer hochskaliert sind!
              Artefakte erscheinen bei einer Skalierung von Blöcken (8x8).
              Dein Auge wird in 4800 kleinen Blöcken nicht so leicht Fehler sehen
              wie es welche in 1200 großen Blöcken sieht (vorausgesetzt du skalierst
              beide auf Vollbild).
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">Theoretisch</emphasis>: Wenn du ein Bild
              runterskalierst, aber nach wie vor die selbe Größe der (8x8)
              Blöcke zur Frequenzraumtransformation verwendest, bewegst Du
              mehr Daten in die Hochfrequenzbänder.
              Grob gesagt, jedes Pixel enthält mehr des Details als es dies
              zuvor tat.
              Somit enthält dein herunterskaliertes Bild 1/4 der Information
              in räumlichen Richtungen, es könnte immer noch einen hohen Anteil
              Information im Frequenzbereich enthalten (vorausgesetzt dass die
              hohen Frequenzen im originalen 640x480 Bild nicht ausgenutzt wurden).
            </para>
          </listitem>
        </orderedlist>
      </para>
      <para>
        Vergangene Leitfäden legten nahe, eine Bitrate und Auflösung zu wählen,
        die auf eine "Bits pro Pixel"-Näherung basieren, dies ist jedoch im
        allgemeinen aus oben genannten Gründen nicht gültig.
        Eine bessere Schätzung scheint zu sein, dass Bitraten proportional zur
        Quadratwurzel der Auflösung skalieren, sodass 320x240 und 400 KBit/Sek
        vergleichbar mit 640x480 bei 800 KBit/Sek wären.
        Dies wurde aber nicht mit theoretischer oder empirischer Strenge verifiziert.
        Desweiteren ist es in Anbetracht der Tatsache, dass Filme in Bezug auf Rauschen, Details,
        Bewegungsgrad usw. außerordentlich variieren, zwecklos, allgemeine Empfehlungen
        für die Bits pro Diagonallänge (dem Analog zu Bits pro Pixel
        unter Verwendung der Quadratwurzel) abzugeben.
      </para>
      <para>
        So weit haben wir nun die Schwierigkeit der Wahl von Bitrate und
        Auflösung diskutiert.
      </para>


      <sect3 id="menc-feat-dvd-mpeg4-resolution-bitrate-compute">
        <title>Berechnen der Auflösung</title>
        <para>
          Die folgenden Schritte werden dich in der Berechnung der Auflösung
          deiner Encodierung anleiten, ohne das Video allzusehr zu verzerren,
          indem verschiedene Typen von Informationen über das Quellvideo in
          Betracht gezogen werden.
          Zuerst solltest du die encodierte Auflösung berechnen:
          <systemitem>ARc = (Wc x (ARa / PRdvd )) / Hc</systemitem>
          <itemizedlist>
            <title>wobwei:</title>
            <listitem>
              <para>
                Wc und Hc die Breite und Höhe des zugeschnittenen Videos darstellen
              </para>
            </listitem>
            <listitem>
              <para>
                ARa das angezeigte Seitenverhältnis ist, das üblicherweise 4/3 oder 16/9 beträgt
              </para>
            </listitem>
            <listitem>
              <para>
                PRdvd das Pixelverhältnis der DVD ist, welches gleich 1.25=(720/576) für
                PAL-DVDs und 1.5=(720/480) für NTSC-DVDs beträgt
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          Dann kannst du die X- und Y-Auflösung berechnen, gemäß eines gewisse Faktors
          der Kompressionsqualität (CQ):
          <systemitem>ResY = INT(SQRT( 1000*Bitrate/25/ARc/CQ )/16) * 16</systemitem>
          und
          <systemitem>ResX = INT( ResY * ARc / 16) * 16</systemitem>
        </para>

        <para>
          Okay, aber was ist der CQ?
          Der CQ repräsentiert die Anzahl Bits pro Pixel und pro Frame der Encodierung.
          Grob ausgedrückt, je größer der CQ, desto geringer die Wahrscheinlichkeit,
          Encodierungsartefakte zu sehen.
          Trotz allem, wenn du eine Zielgröße für deinen Film hast (1 oder 2 CDs zum Beispiel),
          gibt es eine begrenzte Gesamtzahl an Bits, die du aufwenden kannst; deswegen ist es
          notwendig, einen guten Kompromiss zwischen Komprimierbarkeit und Qualität zu suchen.
        </para>

        <para>
          Der CQ hängt von der Bitrate, der Effektivität des Videocodecs und der
          Filmauflösung ab.
          Um den CQ anzuheben, könntest du typischerweise den Film unter der Annahme
          herunterskalieren, dass die Bitrate mit der Funktion der Zielgröße und der
          Länge des Films berechnest, die ja konstant sind.
          Mit MPEG-4 ASP-Codecs wie <systemitem class="library">Xvid</systemitem>
          und <systemitem class="library">libavcodec</systemitem>, resultiert ein CQ
          unter 0.18 für gewöhnlich in einem ziemlich blockhaften Bild, weil nicht
          genug Bits zum Codieren der Information jedes Macroblocks vorhanden sind.
          (MPEG4, wie auch viele andere Codecs, gruppiert Pixel nach Blöcken verschiedener
          Pixel, um das Bild zu komprimieren; sind nicht genügend Bits vorhanden,
          werden die Kanten dieser Blöcke sichtbar.)
          Es ist daher weise, einen CQ im Bereich von 0.20 bis 0.22 für einen 1 CD-Rip
          und 0.26-0.28 für einen 2 CD-Rip mit Standard-Encodieroptionen zu nehmen.
          Höherentwickelte Encodieroptionen wie die hier für
          <link linkend="menc-feat-mpeg4-lavc-example-settings"><systemitem class="library">libavcodec</systemitem></link>
          und
          <link linkend="menc-feat-xvid-example-settings"><systemitem class="library">Xvid</systemitem></link>
          aufgelisteten sollten es möglich machen, dieselbe Qualität mit einem CQ im Bereich
          von 0.18 bis 0.20 für einen 1 CD-Rip und 0.24 bis 0.26 für einen 2 CD-Rip zu erreichen.
          Mit den MPEG-4 AVC-Codecs wie <systemitem class="library">x264</systemitem>,
          kannst du einen CQ im Bereich von 0.14 bis 0.16 mit Standard-Encodieroptionen
          verwenden, und solltest bis auf 0.10 bis 0.12 mit den
          <link linkend="menc-feat-x264-example-settings">erweiterten Encodieroptionen von <systemitem class="library">x264</systemitem></link>
          runter gehen können.
        </para>

        <para>
          Bitte nimm zur Kenntnis, dass der CQ lediglich eine richtungsweisendes Maß ist,
          da sie vom encodierten Inhalt abhängt. Ein CQ von 0.18 kann für einen
          Bergman-Film recht hübsch aussehen, im Gegensatz zu einem Film wie
          The Matrix, der jede Menge High-Motion-Szenen enthält.
          Auf der anderen Seite ist es nutzlos, den CQ höher als 0.30 zu schrauben,
          da du ohne spürbaren Qualitätsgewinn Bits vergeuden würdest.
          Beachte ebenso, dass wie früher in diesem Handbuch bereits angemerkt,
          niedrig auflösende Videos einen größeren CQ benötigen, um gut auszusehen
          (im Vergleich z.B. zur DVD-Auflösung).
        </para>
      </sect3>

    </sect2>

    <sect2 id="menc-feat-dvd-mpeg4-filtering">
      <title>Filtern</title>

      <para>
        Zu lernen, wie man <application>MEncoder</application>s Videofilter
        verwendet, ist essentiell, um gute Encodierungen zu produzieren.
        Jede Videoverarbeitung wird über Filter ausgeführt -- Ausschneiden,
        Skalieren, Farbanpassung, Rauschentfernung, Scharfzeichnen, Deinterlacing,
        telecine, inverses telecine und Deblocking, um nur ein paar davon aufzuzählen.
        Zusammen mit der gewaltigen Zahl unterstützter Inputformate, ist die Vielfalt der
        in <application>MEncoder</application> verfügbaren Filter eine seiner
        Hauptvorteile im Vergleich zu ähnlichen Programmen.
      </para>

      <para>
        Filter werden in einer Kette über die Option -vf geladen:

        <screen>-vf filter1=Optionen,filter2=Optionen,...</screen>

        Die meisten Filter nehmen mehrere numerische, kommagetrennte
        Optionen entgegen, jedoch variiert die Syntax der Optionen von
        Filter zu Filter, also lies bitte die Manpage für Details
        zu den Filtern, die du verwenden willst.
      </para>

      <para>
        Filter wirken auf das Video in der Reihenfolge ein, in der sie geladen werden.
        Zum Beispiel wird folgende Kette:

        <screen>-vf crop=688:464:12:4,scale=640:464</screen>

        zuerst den Bereich 688x464 aus dem Bild schneiden mit der oberen, linken
        Ecke bei (12,4) und danach das Ergebnis auf 640x464 herunter skalieren.
      </para>

      <para>
        Bestimmte Filter müssen zu oder nahe dem Anfang der Filterkette geladen
        werden, um Vorteile aus den Informationen des Videodecoders zu ziehen,
        die ansonsten durch andere Filter verloren gehen oder ungültig gemacht
        würden.
        Die wichtigsten Beispiele sind <option>pp</option>
        (Nachbearbeitung (postprocessing), nur wenn es Deblock- oder
        Dering-Operationen durchführt), <option>spp</option> (ein weiterer
        Postprozessor zum Entfernen von MPEG-Artefakten), <option>pullup</option>
        (umgekehrtes telecine) und <option>softpulldown</option> (zur Konvertierung
        von soft telecine nach hard telecine).
      </para>

      <para>
        Im Allgemeinen solltest du den Film so wenig wie möglich Filtern, um
        nahe an der originalen DVD-Quelle zu bleiben. Ausschneiden ist oft
        notwendig (wie oben beschrieben), vermeide aber das Skalieren von Videos.
        Obwohl das Herunterskalieren manchmal vorgezogen wird, um höhere Quantisierer
        zu verwenden, wollen wir beide diese Dinge vermeiden: Erinnere dich daran,
        dass wir von Anfang an beschlossen hatten, einen Kompromiss zwischen
        Bits und Qualität zu schließen.
      </para>

      <para>
        Passe ebenso kein Gamma, Kontrast, Helligkeit, usw. an. Was auf deinem
        Display gut aussieht, sieht auf anderen eventuell nicht gut aus. Diese
        Anpassungen sollten nur im Playback vorgenommen werden.
      </para>

      <para>
        Eine Sache, die du vielleicht machen willst, ist, das Video durch einen sehr
        feinen Entrauschfilter (Denoise) zu schicken, wie etwa <option>-vf hqdn3d=2:1:2</option>.
        Nochmals, es geht darum, die Bits einer besseren Verwendung zuzuführen: Warum
        Bits zum Encodieren des Rauschens verschwenden, wenn du dieses Rauschen auch
        während des Playback entfernen kannst?
        Die Parameter für <option>hqdn3d</option> zu erhöhen, wird überdies
        die Komprimierbarkeit erhöhen, erhöhst du jedoch die Werte zu sehr, riskierst Du
        eine Verringerung der Bildsichtbarkeit. Die oben vorgeschlagenen Werte
        (<option>2:1:2</option>) sind ziemlich konservativ; du solltest dich frei
        fühlen, mit höheren Werten herumzuexperimentieren und die Ergebnisse
        selbst zu beobachten.
      </para>

    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-interlacing">
      <title>Interlacing und Telecine</title>

      <para>
        Nahezu alle Filme sind bei 24 fps aufgenommen. Weil NTSC 30000/1001 fps entspricht,
        müssen mit diesen 24 fps Videos einige Verarbeitungen durchgeführt werden,
        um sie mit der korrekten NTSC-Framerate laufen zu lassen. Der Prozess wird 3:2
        pulldown genannt, allgemein telecine zugeordnet (weil pulldown des öfteren
        während des telecine-Prozesses angewandt wird), und naiv so beschrieben,
        dass er durch Verlangsamung des Films auf 24000/1001 fps und dem
        Wiederholen jeden vierten Frames arbeitet.
      </para>

      <para>
        Keine spezielle Verarbeitung ist jedoch bei einem Video für PAL-DVDs
        durchzuführen, das bei 25 fps läuft. (Technisch gesehen kann PAL telecined
        werden, 2:2 pulldown genannt, dies ist jedoch in der Praxis nicht von Bedeutung.)
        Der 24 fps Film wird einfach mit 25 fps abgespielt. Das Resultat ist, dass
        der Film ein wenig schneller abläuft, doch solange du kein Alien bist, wirst
        du möglicherweise keinen Unterschied wahrnehmen.
        Die meisten PAL-DVDs haben pitch-korrigiertes Audio, dadurch hören sie sich
        bei 25 fps abgespielt korrekt an, obwohl der Audiotrack (und infolgedessen der
        gesamte Film) eine 4% kürzere Abspielzeit hat wie NTSC-DVDs.
      </para>

      <para>
        Weil das Video in einer PAL-DVD nicht verändert wurde, musst du dich nicht
        viel um die Framerate sorgen. Die Quelle ist 25 fps und dein Rip wird 25
        fps haben. Wenn du jedoch einen NTSC-DVD-Film rippst, musst du eventuell
        umgekehrtes telecine anwenden.
      </para>

      <para>
        Für mit 24 fps aufgenommene Filme ist das Video auf der NTSC-DVD entweder telecined
        30000/1001 oder hat andernfalls progressive 24000/1001 fps und es ist vorgesehen,
        on-the-fly vom DVD-Player telecined zu werden. Auf der anderen Seite sind TV-Serien
        üblicherweise nur interlaced, nicht telecined. Dies ist keine feste Regel: Einige
        TV-Serien sind interlaced (wie etwa Buffy die Vampirjägerin), wogegen andere
        eine Mixtur aus progressive und interlaced sind (so wie Angel oder 24) - wers kennt :).
      </para>

      <para>
        Es wird strengstens empfohlen, die Sektion über
        <link linkend="menc-feat-telecine">Wie mit telecine und interlacing in NTSC-DVDs umgehen</link>
        durchzulesen, um den Umgang mit den verschiedenen Möglichkeiten zu lernen.
      </para>

      <para>
        Wenn du aber hauptsächlich nur Filme rippst, gehst du wahrscheinlich entweder
        mit 24 fps progressivem oder telecined Video um, in welchem Falle du
        den Filter <option>pullup</option> mittels <option>-vf pullup,softskip</option>
        verwenden kannst.
      </para>

    </sect2>

    <sect2 id="menc-feat-dvd-mpeg4-encoding-interlaced">
      <title>Interlaced Video encodieren</title>

      <para>
        Ist der Film, den du encodieren willst, interlaced (NTSC-Video oder
        PAL-Video), wirst du wählen müssen, ob du ihn deinterlacen willst
        oder nicht.
        Während das Deinterlacing deinen Film zwar auf progressiven Scan-Displays
        wie Computermonitoren und Projektoren verwendbar macht, wird dich dies
        doch etwas kosten: Die Feldrate von 50 oder 60000/1001 Feldern pro Sekunde
        wird auf 25 oder 30000/1001 Frames pro Sekunde halbiert und annähernd die
        Hälfte der Informationen in deinem Film geht während Szenen mit
        signifikanter Bewegung verloren.
      </para>

      <para>
        Deswegen wird empfohlen, wenn du aus Gründen hochqualitativer
        Archivierung encodierst, kein Deinterlacing durchzuführen.
        Du kannst den Film immer noch beim Playback deinterlacen,
        wenn du ihn auf progressiven Scan-Geräten anzeigst. Und zukünftige
        Player werden in der Lage sein, auf volle Feldrate zu
        deinterlacen, mit Interpolation auf 50 oder 60000/1001 komplette
        Frames pro Sekunde aus interlaced Video heraus.
      </para>

      <para>
        Spezielle Sorgfalt solltest du bei der Arbeit mit interlaced Video walten lassen:
      </para>

      <orderedlist>
        <listitem>
          <para>
            Ausschneidehöhe und y-Offset müssen Vielfache von 4 sein.
          </para>
        </listitem>
        <listitem>
          <para>
            Jedes vertikale Skalieren muss im interlaced Modus durchgeführt werden.
          </para>
        </listitem>
        <listitem>
          <para>
            Nachbearbeitungs- (postprocessing) und Rauschunterdrückungsfilter (denoising)
            funktionieren eventuell nicht wie erwartet, wenn du nicht speziell darauf achtest,
            dass sie zu einem Zeitpunkt nur ein Feld verarbeiten, und sie können das Video
            kaputt machen, wenn sie inkorrekt angewendet werden.
          </para>
        </listitem>
      </orderedlist>

      <para>
        Mit diesen Dingen im Kopf, hier das erste Beispiel:
      </para>
<screen>mencoder <replaceable>capture.avi</replaceable> -mc 0 -oac lavc -ovc lavc -lavcopts \
vcodec=mpeg2video:vbitrate=6000:ilme:ildct:acodec=mp2:abitrate=224</screen>
      <para>
        Beachte die Optionen <option>ilme</option> und <option>ildct</option>.
      </para>
    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-av-sync">
      <title>Anmerkungen zur Audio-/Videosynchronisation</title>
      <para>
        <application>MEncoder</application>s Algorithmen der Audio-/Videosynchronisation
        wurden mit der Intention entwickelt, Dateien mit kaputter Sychronisation wieder herzustellen.
        In einigen Fällen können unnötiges Überspringen und Duplizieren
        von Frames und möglicherweise leichte A/V-Desynchronisation verursachen, auch wenn sie
        mit dem richtigen Input verwendet werden
        (gewiss, Probleme mit A/V-Synchronisation treffen nur zu, wenn du den Audiotrack während
        der Transcodierung des Videos verarbeitest oder kopierst, wozu auch nachhaltig
        ermutigt wird).
        Hierfür müsstest du mit der Option <option>-mc 0</option> in die
        Grundeinstellung der A/V-Synchronisation wechseln oder diese in deine
        <systemitem>~/.mplayer/mencoder</systemitem> Konfigurationsdatei eintragen,
        solange du ausschließlich mit guten Quellen arbeitest (DVD, TV-Capture,
        hochqualitativen MPEG-4-Rips usw.) und mit nicht-kaputten ASF/RM/MOV-Dateien.
      </para>
      <para>
        Wenn du dich überdies gegen merkwürdige Frameübersprünge und -duplikationen
        absichern willst, kannst du beides verwenden, <option>-mc 0</option>
        und <option>-noskip</option>.
        Dies verhindert <emphasis>jede</emphasis> A/V-Synchronisation und kopiert die Frames
        eins-zu-eins, somit kannst du sie nicht verwenden, falls du irgendwelche Filter
        verwendest, die unvorhersagbar Frames hinzufügen oder streichen oder falls
        deine Input-Datei eine variable Framerate besitzt!
        Deshalb wird eine allgemeine Anwendung von <option>-noskip</option> nicht empfohlen.
      </para>
      <para>
        Die von <application>MEncoder</application> unterstützte sogenannte
        "3-pass" Audioencodierung soll laut Berichten A/V-Desynchronisation
        verursachen.
        Dies geschieht definitiv dann, wenn sie in Verbindung mit bestimmten Filtern
        verwendet wird, daher wird <emphasis>nicht</emphasis> empfohlen, den
        3-pass-Audio-Modus anzuwenden.
        Dieses Feature ist nur aus Kompatibilitätsgründen übrig geblieben und für
        erfahrene Benutzer, die wissen, wann es sicher anzuwenden ist und wann nicht.
        Wenn du zuvor noch nie etwas vom 3-pass-Modus gehört hast, vergiss, dass wir es je
        erwähnt haben!
      </para>
      <para>
        Es gab auch Berichte über A/V-Desynchronisation, wenn
        mit <application>MEncoder</application> von stdin encodiert wurde.
        Lass das bleiben! Verwende immer eine Datei oder ein CD/DVD/usw-Laufwerk
        als Input.
      </para>
    </sect2>

    <sect2 id="menc-feat-dvd-mpeg4-codec">
      <title>Auswahl des Videocodecs</title>

      <para>
        Welcher Videocodec die beste Wahl ist, hängt von mehreren Faktoren
        wie Größe, Qualität, Streambarkeit, Brauchbarkeit und Popularität, manche
        davon weitgehend vom persönlichen Geschmack und technischen
        Randbedingungen ab.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">Kompressionseffizienz</emphasis>:
            Es ist leicht zu verstehen, dass die meisten Codecs der neueren Generation
            dafür gemacht wurden, Qualität und Komprimierung zu verbessern.
            Deshalb behauptet der Autor dieses Handbuches und viele andere Leute, dass
            du nichts verkehrt machen kannst,
            <footnote id='fn-menc-feat-dvd-mpeg4-codec-cpu'>
              <para>Sei trotzdem vorsichtig: MPEG-4 AVC-Videos in DVD-Auflösung zu
                decodieren erfordert einen schnellen Rechner (z.B. einen Pentium 4
                über 1.5GHz oder einen Pentium M über 1GHz).
              </para>
            </footnote>
            wenn du MPEG-4 AVC-Codecs wie
            <systemitem class="library">x264</systemitem> anstatt MPEG-4 ASP-Codecs
            wie <systemitem class="library">libavcodec</systemitem> MPEG-4 oder
            <systemitem class="library">Xvid</systemitem> wählst.
            (Zukunftsorientierte Codec-Entwickler interessiert eventuell Michael
            Niedermayers Meinung
            "<ulink url="http://guru.multimedia.cx/?p=10">why MPEG4-ASP sucks</ulink>"
            zu lesen.)
            Ebenso solltest du mit MPEG-4 ASP eine bessere Qualität erhalten als mit
            MPEG-2-Codecs.
          </para>
          <para>
            Allerdings können neuere Codecs, die noch stark in der Entwicklung stecken,
            unter unentdeckten Bugs leiden, die die Encodierung ruinieren können.
            Dies nimmt man schlicht in Kauf, wenn man "bleeding edge"-Technologie
            verwendet.
          </para>
          <para>
            Außerdem erfordert der Umgang mit einem neuen Codec und sich mit dessen Optionen
            vertraut zu machen eine Zeit, bis du weißt, was alles anzupassen
            ist, um die erhoffte Bildqualität zu erreichen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">Hardware-Kompatibilität</emphasis>:
            Gewöhnlich dauert es bei neuen standalone Video-Playern lange, bis der
            Support für die neuesten Videocodecs eingebunden ist.
            Als ein Ergebnis unterstützen die meisten nur MPEG-1 (wie VCD, XVCD
            und KVCD), MPEG-2 (wie DVD, SVCD und KVCD) und MPEG-4 ASP (wie DivX,
            LMP4 von <systemitem class="library">libavcodec</systemitem> und
            <systemitem class="library">Xvid</systemitem>)
            (Vorsicht: Im Allgemeinen werden nicht alle MPEG-4 ASP-Features unterstützt).
            Sieh bitte in den technischen Spezifikationen deines Players nach (falls
            welche vorhanden sind) oder google nach mehr Informationen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">Beste Qualität pro Encodierzeit</emphasis>:
            Codecs, die es schon einige Zeit gibt (wie
            <systemitem class="library">libavcodec</systemitem> MPEG-4 und
            <systemitem class="library">Xvid</systemitem>), sind gewöhnlich heftig
            mit allen möglichen intelligenten Algorithmen und SIMD Assembly-Code optimiert.
            Das sind sie deshalb, weil sie darauf abzielen, das beste Verhältnis von Qualität
            pro Encodierzeit zu liefern.
            Jedoch haben sie oft einige sehr fortschrittliche Optionen, die,
            wenn aktiviert, das Encodieren bei marginalem Gewinn wirklich langsam
            machen.
          </para>
          <para>
            Wenn du es auf die Wahnsinnsgeschwindigkeit abzielst, solltest du
            in der Nähe der Standardeinstellungen des Videocodecs bleiben
            (obwohl du ruhig weitere Optionen ausprobieren solltest, die in
            anderen Sektionen dieses Handbuchs angesprochen werden).
          </para>
          <para>
            Vielleicht überlegst du auch, einen Codec auszuwählen, der mit
            Multi-Threading klarkommt, was nur für Benutzer von Rechnern
            mit mehreren CPUs von Nutzen ist.
            <systemitem class="library">libavcodec</systemitem> MPEG-4 erlaubt
            dies zwar, aber die Geschwindigkeitsgewinne sind begrenzt und es gibt
            einen leicht negativen Effekt in Bezug auf die Bildqualität.
            Die Multi-Thread-Encodierung von <systemitem class="library">Xvid</systemitem>,
            durch die Option <option>threads</option> aktiviert, kann zum Ankurbeln
            der Encodiergeschwindigkeit - um in typischen Fällen etwa 40-60% -
            bei wenn überhaupt geringer Bildverschlechterung verwendet werden.
            <systemitem class="library">x264</systemitem> erlaubt ebenfalls
            Multi-Thread-Encodierung, was das Encodieren momentan um 94% beschleunigt
            bei gleichzeitiger Verringerung des PSNR um einen Wert zwischen 0.005dB und 0.01dB.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">Persönlicher Geschmack</emphasis>:
            Hier beginnt die Angelegenheit oft irrational zu werden: Aus den selben
            Gründen, aus denen manche über Jahre an DivX 3 hängen, während neuere
            Codecs bereits Wunder wirken, ziehen einige Leute
            <systemitem class="library">Xvid</systemitem>
            oder <systemitem class="library">libavcodec</systemitem> MPEG-4 dem
            <systemitem class="library">x264</systemitem> vor.
          </para>
          <para>
            Du solltest dir dein eigenes Urteil bilden; lass dich nicht von Leuten
            vollquasseln, die auf den einen Codec schwören.
            Nimm ein paar Beispiel-Clips von Originalquellen und vergleiche die
            verschiedenen Encodier-Optionen und Codecs, um den einen zu finden, mit
            dem du am besten klarkommst.
            Der beste Codec ist der, den du beherrschst und der in deinen Augen
            auf deinem Display am besten aussieht.
            <footnote id='fn-menc-feat-dvd-mpeg4-codec-playback'>
              <para>Dieselbe Encodierung kann auf dem Monitor eines anderen vollkommen
                anders aussehen oder wenn sie von einem anderen Decoder abgespielt wird,
                also mach deine Encodierungen zukunftssicher indem du sie unter verschiedenen
                Setups ablaufen lässt.</para></footnote>!
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Sieh dazu bitte in der Sektion
        <link linkend="menc-feat-selecting-codec">Auswahl der Codecs und Containerformate</link>
        nach der Liste der unterstützten Codecs.
      </para>
    </sect2>

    <sect2 id="menc-feat-dvd-mpeg4-audio">
      <title>Audio</title>

      <para>
        Audio ist ein leichter zu lösendes Problem: Wenn du Wert auf Qualität legst,
        lass es einfach so wie es ist.
        Gerade AC3 5.1 Streams sind meist 448Kbit/s und jedes Bit wert.
        Möglicherweise gerätst du in Versuchung, Audio in hochwertiges Vorbis
        umzuwandeln, aber nur weil du heute keinen A/V-Receiver für AC3-pass-through
        besitzt, bedeutet dies nicht, dass du nicht morgen doch einen hast.
        Halte deine DVD-Rips zukunftssicher, indem du den AC3-Stream beibehältst.
        Du behältst den AC3-Stream entweder, indem du ihn
        <link linkend="menc-feat-mpeg4">während der Encodierung</link>
        direkt in den Video-Stream kopierst.
        Du kannst den AC3-Stream aber auch extrahieren, um ihn in Container wie NUT
        oder Matroska zu muxen.
        <screen>mplayer <replaceable>source_file.vob</replaceable> -aid 129 -dumpaudio -dumpfile <replaceable>sound.ac3</replaceable></screen>
        dumpt Audiotrack Nummer 129 aus der Datei <replaceable>source_file.vob</replaceable>
        (NB: DVD-VOB-Dateien verwenden gewöhnlich andere Audionummerierungen,
        was bedeutet, dass der VOB-Audiotrack 129 der 2-te Audiotrack der Datei ist)
        in die Datei <replaceable>sound.ac3</replaceable>.
      </para>

      <para>
        Aber manchmal hast du wirklich keine andere Wahl als den Sound weiter zu
        komprimieren, sodass mehr Bits fürs Video aufgewendet werden können.
        Die meisten Leute entscheiden sich für eine Audiokomprimierung mit MP3- oder
        Vorbis-Audiocodecs.
        Wobei letzterer ein sehr platzsparender Codec ist, MP3 wird von Hardware-Playern
        besser unterstützt, wobei sich dieser Trend auch ändert.
      </para>

      <para>
        Verwende <emphasis>nicht</emphasis> <option>-nosound</option> beim Encodieren
        einer Datei, die Audio enhält, sogar wenn du Audio später separat
        encodierst und muxt.
        Zwar kann es im Idealfall manchmal funktionieren, wenn du <option>-nosound</option>
        verwendest, wahrscheinlich um einige Probleme in deinen
        Encodier-Befehlszeileneinstellungen zu verbergen.
        In anderen Worten, einen Soundtrack während dem Encodieren zu haben, stellt sicher,
        vorausgesetzt du siehst keine Meldungen wie
        <quote>Too many audio packets in the buffer</quote>, dass du in der Lage sein
        wirst, eine korrekte Synchronisation zu erhalten.
      </para>

      <para>
        Du brauchst <application>MEncoder</application> zur Verarbeitung des Sounds.
        Du kannst zum Beispiel den originalen Soundtrack während dem Encodieren mit
        <option>-oac copy</option> kopieren oder ihn mittels
        <option>-oac pcm -channels 1 -srate 4000</option> in eine "leichte"
        4 kHz Mono WAV-PCM konvertieren.
        Anderenfalls wird er - in einigen Fällen - eine Videodatei erzeugen, die
        nicht mit Audio synchron läuft.
        So was kommt vor, wenn die Anzahl der Videoframes in der Quelldatei nicht
        mit der Gesamtlänge der Audioframes zusammenpasst oder immer dann, wenn
        Unstetigkeiten/Splices vorhanden sind, wo Audioframes oder extra Audioframes
        fehlen.
        Der korrekte Weg, mit dieser Art Problem umzugehen, ist Stille (silence)
        einzufügen oder Audio an diesen Punkten wegzuschneiden.
        Seis drum, <application>MPlayer</application> kann das nicht, also wenn du
        AC3-Audio demuxt und es in einer separaten Anwendung encodierst (oder
        es mit <application>MPlayer</application> in eine PCM dumpst), die Splices
        bleiben inkorrekt und der einzige Weg sie zu korrigieren ist, Videoframes
        an diesem Splice zu streichen bzw. zu duplizieren.
        Solange <application>MEncoder</application> Audio beim Encodieren des
        Videos sieht, kann er dieses Streichen/Duplizieren erledigen (was
        gewöhnlich OK ist, da es bei voller Schwärze/Szenenwechsel stattfindet),
        aber wenn <application>MEncoder</application> Audio nicht erkennen kann,
        wird er einfach alle Frames so wie sie ankommen verarbeiten und sie werden
        einfach nicht zum endgültigen Audiostream passen, wenn du beispielsweise
        deinen Audio- und Videotrack in eine Matroska-Datei mergst.
      </para>

      <para>
        Zuallererst wirst du den DVD-Sound in eine WAV-Datei konvertieren müssen, die
        der Audiocodec als Input nutzen kann.
        Zum Beispiel:
        <screen>mplayer <replaceable>source_file.vob</replaceable> -ao pcm:file=<replaceable>destination_sound.wav</replaceable> -vc dummy -aid 1 -vo null</screen>
        wird den zweiten Audiotrack aus der Datei <replaceable>source_file.vob</replaceable>
        in die Datei <replaceable>destination_sound.wav</replaceable> dumpen.
        Vielleicht willst du den Sound vor dem Encodieren normalisieren, da
        DVD-Audiotracks gemeinhin bei niedriger Lautstärke aufgenommen sind.
        Du kannst beispielsweise das Tool <application>normalize</application> verwenden,
        das in den meisten Distributionen zur Verfügung steht.
        Wenn du Windows nutzt, kann ein Tool wie <application>BeSweet</application>
        denselben Job erledigen.
        Du wirst entweder nach Vorbis oder MP3 komprimieren.
        Zum Beispiel:
        <screen>oggenc -q1 <replaceable>destination_sound.wav</replaceable></screen>
        wird <replaceable>destination_sound.wav</replaceable> mit
        der Encodierqualität 1 encodieren, was annähernd 80Kb/s ergibt und
        die Minimalqualität darstellt, mit der du encodieren solltest, wenn du
        Wert auf Qualität legst.
        Nimm bitte zur Kenntnis, dass <application>MEncoder</application> aktuell keine Vorbis-Audiotracks
        in die Output-Datei muxen kann, da er nur AVI- und MPEG-Container als
        Output unterstützt, wobei es beim Audio-/Videoplayback zu
        Synchronisationproblemen mit einigen Playern führen wird, wenn die AVI-Datei
        VBR-Audiostreams wie z.B. Vorbis enthält.
        Keine Bange, dieses Dokument wird dir zeigen, wie du das mit
        Third-Party-Programmen hinbekommst.
      </para>

    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-muxing">
      <title>Muxen</title>
      <para>
        Nun da du dein Video encodiert hast, wirst du es höchstwahrscheinlich
        mit einem oder mehr Audiotracks in einen Movie-Container wie etwa
        AVI, MPEG, Matroska oder NUT muxen.
        <application>MEncoder</application> ist aktuell nur in der Lage,
        Audio und Video nativ in MPEG- und AVI-Containerformate auszugeben.
        Zum Beispiel:
        <screen>mencoder -oac copy -ovc copy -o <replaceable>output_movie.avi</replaceable> -audiofile <replaceable>input_audio.mp2</replaceable> <replaceable>input_video.avi</replaceable></screen>
        würde die Video-Datei <replaceable>input_video.avi</replaceable>
        und die Audio-Datei <replaceable>input_audio.mp2</replaceable>
        in die AVI-Datei <replaceable>output_movie.avi</replaceable> mergen.
        Dieser Befehl funktioniert mit MPEG-1 Layer I, II und III Audio (eher
        bekannt als MP3), WAV und auch mit ein paar weiteren Audioformaten.
      </para>

      <para>
        <application>MEncoder</application> zeichnet sich aus durch experimentellen Support für
        <systemitem class="library">libavformat</systemitem>, das eine
        Programmbibliothek des FFmpeg-Projekts ist, welches das Muxen und
        Demuxen einer Vielzahl von Containern unterstützt.
        Zum Beispiel:
        <screen>mencoder -oac copy -ovc copy  -o <replaceable>output_movie.asf</replaceable> -audiofile <replaceable>input_audio.mp2</replaceable> <replaceable>input_video.avi</replaceable> -of lavf -lavfopts format=asf</screen>
        wird das selbe machen, wie das obere Beispiel, außer dass der
        Output-Container ASF sein wird.
        Bitte nimm zur Kenntnis, dass dieser Support hochexperimentell ist
        (aber von Tag zu Tag besser wird) und nur funktionieren wird, wenn du
        <application>MPlayer</application> mit aktiviertem Support für
        <systemitem class="library">libavformat</systemitem> kompiliert
        hast (was meint, dass eine Pre-Packaged Binary Version in den meisten
        Fällen nicht funktionieren wird).
      </para>


      <sect3 id="menc-feat-dvd-mpeg4-muxing-filter-issues">
        <title>Verbessern der Mux- und A/V-Synchronisationszuverlässigkeit</title>
        <para>
          Es kann vorkommen, dass du ernsthafte A/V-Synchronisationsprobleme hast während
          du versuchst, deine Video- und einige Audiotracks zu muxen, wobei es nichts
          ändert, wenn du das Audiodelay anpasst, du bekommst nie eine korrekte
          Synchronisation zu Stande.
          Dies kann vorkommen, wenn du manche Videofilter verwendest, die einige Frames
          weglassen oder duplizieren, wie etwa die inverse telecine-Filter.
          ich kann dich nur dazu ermutigen, den <option>harddup</option>-Videofilter
          ans Ende der Filterkette anzuhängen, um solcherlei Problemen aus dem Weg
          zu gehen.
        </para>

        <para>
          Ohne <option>harddup</option> verlässt sich <application>MEncoder</application>,
          wenn er einen Frame duplizieren will, darauf, dass der Muxer eine Marke auf den
          Container setzt, sodass der letzte Frame nochmals angezeigt wird, um
          während des Schreibens des aktuellen Frames synchron zu bleiben.
          Mit <option>harddup</option> wird <application>MEncoder</application>
          statt dessen einfach den zuletzt angezeigten Frame nochmal in die Filterkette
          einschieben.
          Dies bedeutet, dass der Encoder <emphasis>exakt</emphasis> denselben Frame
          zweimal entgegen nimmt und komprimiert.
          Dies ergibt eine etwas größere Datei, verursacht jedoch keine Probleme
          beim Demuxen oder Remuxen in ein anderes Containerformat.
        </para>

        <para>
          Du kommst auch nicht um den Einsatz von <option>harddup</option> im
          Zusammenhang mit Containerformaten herum, die nicht allzu fest mit
          <application>MEncoder</application> verlinkt sind, wie etwa diejenigen,
          welche von <systemitem class="library">libavformat</systemitem> unterstützt
          werden, der keine Frameduplikation auf Container-Level unterstützt.
        </para>
      </sect3>


      <sect3 id="menc-feat-dvd-mpeg4-muxing-avi-limitations">
        <title>Limitierungen des AVI-Containers</title>
        <para>
          Obwohl es das am breitesten unterstützte Containerformat nach MPEG-1 ist,
          besitzt AVI auch einige gravierende Nachteile.
          Der vielleicht offensichtlichste ist der Overhead.
          Für jeden Block der AVI-Datei werden 24 Byte auf Header und Indizes
          verschwendet.
          Dies heißt übersetzt etwas mehr als 5 MB pro Stunde oder 1-2.5%
          Overhead für einen 700 MB Film. Das sieht nicht nach viel aus, könnte aber
          die Differenz zwischen einem Video mit 700 KBit/Sek oder 714 KBit/Sek
          bedeuten, und jedes bisschen mehr an Qualität zählt.
        </para>

        <para>
          Zu dieser schockierenden Ineffizienz kommen bei AVI noch folgende
          wesentlichen Einschränkungen:
        </para>

        <orderedlist>
          <listitem>
            <para>
              Nur Inhalt mit festen fps kann gespeichert werden. Dies ist insbesondere
              dann einschränkend, wenn das Originalmaterial, das du encodieren willst,
              gemischter Inhalt ist, zum Beispiel ein Mix aus NTSC-Video und
              Filmmaterial.
              Eigentlich gibt es Hacks, die es ermöglichen, Inhalt mit gemischter
              Framerate in einer AVI unterzubringen, diese vergrößern jedoch den
              (ohnehin großen) Overhead fünffach oder mehr und sind somit ungeeignet.
            </para>
          </listitem>
          <listitem>
            <para>
              Audio in AVI-Dateien muss entweder konstante Bitrate (CBR) oder
              konstante Framegröße haben (also alle Frames decodieren zur selben Anzahl
              Samples).
              Unglücklicherweise erfüllt Vorbis, der effektivste Codec, keine dieser
              Anforderungen.
              Deshalb wirst du einen weniger effizienten Codec wie MP3 oder AC3 verwenden
              müssen, wenn du planst, einen Film in AVI zu speichern.
            </para>
          </listitem>
        </orderedlist>

        <para>
          Nachdem ich nun all dies erzählt habe, muss ich anmerken, momentan
          unterstützt <application>MEncoder</application> keinen Output mit
          variablen fps oder Vorbis-Encodierung.
          Deswegen magst du dies nicht als Einschränkung ansehen, falls
          <application>MEncoder</application> das einzige Tool ist, das du
          nutzt, um deine Ecodierungen zu produzieren.
          Es ist dennoch möglich, <application>MEncoder</application> nur zur
          Videoencodierung zu verwenden und danach externe Tools, um Audio
          zu encodieren und in ein anderes Containerformat zu muxen.
        </para>
      </sect3>

      <sect3 id="menc-feat-dvd-mpeg4-muxing-matroska">
        <title>Muxen in den Matroska-Container</title>
        <para>
          Matroska ist ein freies, offenes Containerformat, das darauf abzielt,
          eine Menge erweiterter Features bereitzustellen, mit denen ältere Container
          wie AVI nicht umgehen können.
          Zum Beispiel unterstützt Matroska Audioinhalt mit variabler Bitrate (VBR),
          variable Frameraten (VFR), Kapitel, Dateianhänge,
          Fehlererkennung Error Detection Code (EDC) und modern A/V-Codecs wie "Advanced Audio
          Coding" (AAC), "Vorbis" oder "MPEG-4 AVC" (H.264), so gut wie nichts
          womit AVI etwas anfangen kann.
        </para>

        <para>
          Die zum Erzeugen von Matroska-Dateien erforderlichen Tools werden
          zusammen <application>mkvtoolnix</application> genannt und stehen
          für die meisten Unix-Plattformen wie auch <application>Windows</application>
          zur Verfügung.
          Weil Matroska ein offener Standard ist, findest du vielleicht andere
          Tools, die sich besser für dich eignen, aber da mkvtoolnix das am meisten
          Verbreitete ist und von Matroska selbst unterstützt wird, werden wir nur
          dessen Anwendung einbeziehen.
        </para>

        <para>
          Möglicherweise der einfachste Weg, mit Matroska anzufangen, ist
          <application>MMG</application> zu verwenden, das grafische Frontend,
          das mit <application>mkvtoolnix</application> daherkommt, und dem
          <ulink url="http://www.bunkus.org/videotools/mkvtoolnix/doc/mkvmerge-gui.html">guide to mkvmerge GUI (mmg)</ulink>
          zu folgen.
        </para>

        <para>
          Du kannst Audio und Video-Dateien auch per Befehlszeile muxen:
          <screen>mkvmerge -o <replaceable>output.mkv</replaceable> <replaceable>input_video.avi</replaceable> <replaceable>input_audio1.mp3</replaceable> <replaceable>input_audio2.ac3</replaceable></screen>
          würde die Video-Datei <replaceable>input_video.avi</replaceable>
          und die zwei Audio-Dateien <replaceable>input_audio1.mp3</replaceable>
          und <replaceable>input_audio2.ac3</replaceable> in die Matroska-Datei
          <replaceable>output.mkv</replaceable> mergen.
          Matroska, wie zuvor beschrieben, ist in der Lage, noch viel mehr als
          das zu tun, wie etwa multiple Audiotracks (inklusive Feintuning der
          Audio-/Videosynchronisation), Kapitel, Untertitel, Splitting, usw...
          Sieh bitte in den Dokumentationen dieser Anwendungen nach mehr Details.
        </para>

      </sect3>

    </sect2>

  </sect1>

  <sect1 id="menc-feat-telecine">
    <title>Wie mit telecine und interlacing in NTSC-DVDs umgehen</title>

    <sect2 id="menc-feat-telecine-intro">
      <title>Einführung</title>
      <formalpara>
        <title>Was ist telecine?</title>
        <para>
          Wenn du nicht viel von dem verstehst, was in diesem Dokument beschrieben wird, lies den
          <ulink url="http://en.wikipedia.org/wiki/Telecine">Wikipedia-Artikel über Telecine</ulink>.
          Dies ist eine verständliche und einigermaßen umfassende
          Beschreibung dessen, was telecine ist.
        </para>
      </formalpara>

      <formalpara>
        <title>Eine Anmerkung zu Zahlen</title>
        <para>
          Viele Dokumente, einschließlich des oben verlinkten Handbuchs, beziehen
          sich auf den Wert Felder pro Sekunde von NTSC-Video als 59.94 und den
          korrespondierenden Frames pro Sekunde als 29.97 (für telecined und
          interlaced) und 23.976 (für progressiv). Zur Vereinfachung runden
          manche dieser Dokumente sogar auf 60, 30 und 24 auf.
        </para>
      </formalpara>

      <para>
        Streng genommen sind alle diese Zahlen Näherungswerte. Das schwarz/weiße
        NTSC-Video war exakt 60 Felder pro Sekunde, später wurde jedoch 60000/1001
        gewählt, um die Farbdaten anzupassen, solange man gleichzeitig
        zu Schwarz/weiß-Fernsehen kompatibel blieb. Digitales NTSC-Video
        (so wie auf einer DVD) hat ebenfalls 60000/1001 Felder pro Sekunde. Hieraus
        wird interlaced und telecined Video als 30000/1001 Frames pro Sekunde
        enthaltend abgeleitet; progressive Video hat 24000/1001 Frames pro Sekunde.
      </para>

      <para>
        Ältere Versionen der <application>MEncoder</application>-Dokumentation
        und viele archivierten Posts in Mailing-Listen beziehen sich auf 59.94,
        29.97 und 23.976.
        Alle <application>MEncoder</application>-Dokumentationen wurden insofern
        aktualisiert, dass sie fraktionale Werte verwenden, und du solltest dies
        auch tun.
      </para>

      <para>
        <option>-ofps 23.976</option> ist inkorrekt.
        <option>-ofps 24000/1001</option> sollte statt dessen benutzt werden.
      </para>

      <formalpara>
        <title>Wie telecine angewandt wird</title>
        <para>
          Jedes Video, das zur Anzeige auf einem NTSC-Fernseh-Set vorgesehen ist,
          muss 60000/1001 Felder pro Sekunde haben. Für TV-Filme und Shows
          hergestellt sind sie häufig direkt mit 60000/1001 Feldern pro Sekunde
          aufgenommen, die Mehrheit der Kinofilme jedoch mit 24 oder 24000/1001
          Frames pro Sekunde. Wenn cinematische Movie-DVDs gemastert werden,
          wird das Video danach fürs Fernsehen mittels eines telecine genannten
          Prozesses konvertiert.
        </para>
      </formalpara>

      <para>
        Auf einer DVD wird das Video eigentlich nie als 60000/1001 Felder
        pro Sekunde abgelegt. Für ein Video, das ursprünglich 60000/1001 war,
        wird jedes Feldpaar zu einem Frame kombiniert, was dann 30000/1001
        Frames pro Sekunde ergibt. Hardware-DVD-Player lesen dann ein im
        Videostream eingebettetes Kennzeichen aus, um zu bestimmen, ob die gerade
        oder ungerade nummerierten Zeilen das erste Feld formen sollen.
      </para>

      <para>
        Üblicherweise bleibt ein Inhalt mit 24000/1001 Frames pro Sekunde
        so wie er ist, wenn er für eine DVD encodiert wird, und der DVD-Player
        muss das Telecining on-the-fly bewerkstelligen. Manchmal jedoch wird das
        Video telecined <emphasis>bevor</emphasis> es auf der DVD gespeichert wird;
        selbst wenn es ursprünglich 24000/1001 Frames pro Sekunde war, wird es
        60000/1001 Felder pro Sekunde. Wenn es auf der DVD gespeichert wird,
        werden Feldpaare zu 30000/1001 Frames pro Sekunde kombiniert.
      </para>

      <para>
        Wenn man das aus 60000/1001 Feldern pro Sekunde geformten Einzelframes
        erzeugte Video betrachtet, ist telecined oder anderenfalls Interlacing
        klar sichtbar woimmer Bewegung auftritt, da ein Feld (sagen wir, die
        geradzahlig nummerierten Zeilen) einen Moment zur Zeit 1/(60000/1001) Sekunden
        später als das andere repräsentiert. Spielt man ein interlaced Video auf
        einem Computer ab, sehen beide hässlich aus, weil der Monitor eine höhere
        Auflösung besitzt und weil das Video Frame für Frame anstatt Feld für Feld
        angezeigt wird.
      </para>

      <itemizedlist>
        <title>Anmerkungen</title>
        <listitem>
          <para>
            Dieser Abschnitt gilt nur für NTSC-DVDs und nicht für PAL.
          </para>
        </listitem>
        <listitem>
          <para>
            Die <application>MEncoder</application>-Beispielzeilen überall im
            Dokument sind <emphasis role="bold">nicht</emphasis> zum
            eigentlichen Gebrauch vorgesehen. Sie sind schlicht das bloße Minimum,
            das zum Encodieren der betreffenden Videokategorie benötigt wird.
            Wie mache ich gute DVD-Rips oder wie feintune ich
            <systemitem class="library">libavcodec</systemitem> auf maximale
            Qualität gehören nicht zum Umfang dieses Dokuments.
          </para>
        </listitem>
        <listitem>
          <para>
            Es gibt ein paar Fußnoten speziell für dieses Handbuch, die so ähnlich
            verlinkt sind:
            <link linkend="menc-feat-telecine-footnotes">[1]</link>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="menc-feat-telecine-ident">
      <title>Wie kann man sagen, welchen Typ Video man hat</title>

      <sect3 id="menc-feat-telecine-ident-progressive">
        <title>Progressiv</title>
        <para>
          Progressive Video wurde ursprünglich mit 24000/1001 fps gefilmt und
          ohne Änderung auf der DVD abgespeichert.
        </para>

        <para>
          Wenn du eine progressive DVD in <application>MPlayer</application> abspielst,
          wird <application>MPlayer</application> folgende Zeile ausgeben, sobald
          das Abspielen des Films beginnt:

          <screen> demux_mpg: 24000/1001 fps progressive NTSC content detected, switching framerate.</screen>

          Von diesem Punkt an vorwärts sollte demux_mpg nie erzählen, es finde
          "30000/1001 fps NTSC content."
        </para>

        <para>
          Wenn du progressives Video ankuckst, solltest du nie irgendein
          Interlacing sehen. Sei trotzdem vorsichtig, weil manchmal ein winziges
          bisschen telecine dort hineingemischt wurde, wo du es nicht erwartest.
          Ich bin TV-Serien-DVDs begegnet, die eine Sekunde telecine bei jedem
          Szenenwechsel haben oder an extrem zufälligen Stellen. Ich hatte mir einmal
          eine DVD angesehen, die eine progressive erste Hälfte besaß, und die
          zweite Hälfte war telecined. Willst du<emphasis>wirklich</emphasis>
          gründlich sein, kannst du den kompletten Film scannen:

          <screen>mplayer dvd://1 -nosound -vo null -benchmark</screen>

          Das Verwenden von <option>-benchmark</option> veranlasst
          <application>MPlayer</application>, den Film so schnell er es nur kann
          abzuspielen; dies dauert je nach Hardware trotzdem noch eine
          Weile. Jedesmal wenn demux_mpg einen Frameratenwechsel meldet, wird dir
          die Zeile unmittelbar darüber die Zeit zeigen, bei welcher der Wechsel
          auftrat.
        </para>

        <para>
          Manchmal wird progressive Video auf DVDs
          "soft telecine" zugeordnet, weil es dazu vorgesehen ist,
          vom DVD-Player telecined zu werden.
        </para>
      </sect3>

      <sect3 id="menc-feat-telecine-ident-telecined">
        <title>Telecined</title>
        <para>
          Telecined Video war ursprünglich mit 24000/1001 aufgenommen, wurde aber
          telecined, <emphasis>bevor</emphasis> es auf die DVD geschrieben wurde.
        </para>

        <para>
          <application>MPlayer</application> meldet keine (nie)
          Frameratenwechsel, wenn er telecined Video abspielt.
        </para>

        <para>
          Beim Betrachten eines telecined Videos wirst du Interlacing-Artefakte
          sehen, die zu "blinken" scheinen: sie erscheinen wiederholt
          und verschwinden wieder.
          Du kannst dir das so genauer hinschauen
          <orderedlist>
            <listitem>
              <screen>mplayer dvd://1</screen>
            </listitem>
            <listitem>
              <para>
                Suche einen Teil mit Bewegung.
              </para>
            </listitem>
            <listitem>
              <para>
                Benutze die Taste <keycap>.</keycap>, um jeweils einen Frame vorwärts zu rücken.
              </para>
            </listitem>
            <listitem>
              <para>
                Schau auf das Muster der interlaced und progressive aussehenden
                Frames. Ist das Muster, das du siehst PPPII,PPPII,PPPII,... dann ist das
                Video telecined. Siehst du andere Muster, dann wurde das Video womöglich
                mittels einiger Nicht-Standard-Methoden telecined;
                <application>MEncoder</application> kann ein Nicht-Standard-telecine
                nicht verlustfrei nach progressive konvertieren. Siehst du überhaupt
                keine Muster, ist es höchstwahrscheinlich interlaced.
              </para>
            </listitem>
          </orderedlist>
        </para>

        <para>
          Manchmal wird telecined Video auf DVDs "hard telecine"
          zugeordnet. Da hard telecine bereits 60000/1001 Felder pro Sekunde hat,
          spielt der DVD-Player das Video ohne irgendeine Manipulation ab.
        </para>

        <para>
          Ein anderer Weg, zu sagen, ob deine Quelle telecined ist oder nicht,
          ist die Quelle mit den Befehlszeilenoptionen <option>-vf pullup</option>
          und <option>-v</option> abzuspielen, um nachzusehen, wie
          <option>pullup</option> zu den Frames passt.
          Ist die Quelle telecined, solltest du in der Befehlszeile ein 3:2 Muster
          mit abwechselnd <systemitem>0+.1.+2</systemitem> und <systemitem>0++1</systemitem>
          anzeigen.
          Diese Technik hat den Vorteil, dass du die Quelle nicht zu beobachten
          brauchst, um sie zu identifizieren, was von Nutzen sein könnte, falls du
          den Encodiervorgang automatisieren willst oder besagte Prozedur ferngesteuert
          mittels einer langsamen Verbindung vornehmen willst.
        </para>

      </sect3>

      <sect3 id="menc-feat-telecine-ident-interlaced">
        <title>Interlaced</title>
        <para>
          Interlaced Video wurde ursprünglich als 60000/1001 Felder pro Sekunde
          aufgenommen und auf der DVD als 30000/1001 Frames pro Sekunde abgespeichert.
          Der interlacing-Effekt (oft "combing" genannt) ist ein Ergebnis
          von Kammpaaren von Feldern in Frames. Jedes Feld wird einzeln als
          1/(60000/1001) Sekunden angenommen, und wenn sie simultan angezeigt werden,
          wird der Unterschied offensichtlich.
        </para>

        <para>
          Wie bei telecined Video sollte <application>MPlayer</application> niemals
          einen Frameratewechsel beim Abspielen des interlaced Inhalts melden.
        </para>

        <para>
          Wenn du ein interlaced Video genau ansiehst, in dem du dich mit der Taste
          <keycap>.</keycap> durch die Frames bewegst, wirst du sehen, dass
          jeder einzelne Frame interlaced ist.
        </para>
      </sect3>

      <sect3 id="menc-feat-telecine-ident-mixedpt">
        <title>Gemischtes progressive und telecine</title>
        <para>
          Alle "gemischten progressive und telecine" Videos wurden ursprünglich
          als 24000/1001 Frames pro Sekunde aufgenommen, jedoch werden einige Teile
          telecined beendet.
        </para>

        <para>
          Spielt <application>MPlayer</application> diese Kategorie ab, wird er
          (oft wiederholt) zwischen "30000/1001 fps NTSC"
          und "24000/1001 fps progressive NTSC" zurück und vor wechseln.
          Beobachte die untere Hälfte von <application>MPlayer</application>s Ausgabe,
          um diese Meldungen anzusehen.
        </para>

        <para>
          Du solltest die Sektion "30000/1001 fps NTSC" überprüfen, um
          sicher zu gehen, dass sie auch wirklich telecine sind und nicht einfach
          interlaced.
        </para>
      </sect3>

      <sect3 id="menc-feat-telecine-ident-mixedpi">
        <title>Gemischtes progressive und interlaced</title>
        <para>
          In "gemischtem progressive und interlaced" Inhalt wurde progressive
          und interlaced Video zusammengeklebt.
        </para>

        <para>
          Diese Kategorie sieht aus wie "gemischtes progressive und telecine",
          bis du die Sektion 30000/1001 fps untersuchst und feststellst, dass
          sie das telecine-Muster nicht haben.
        </para>
      </sect3>

    </sect2>

    <sect2 id="menc-feat-telecine-encode">
      <title>Wie jede Kategorie encodieren</title>
      <para>
        Wie ich anfangs angemerkt hatte, sind die
        <application>MEncoder</application>-Beispielzeilen unten eigentlich
        <emphasis role="bold">nicht</emphasis> zur Anwendung bestimmt;
        sie demonstrieren nur die Minimalparameter zur korrekten Encodierung
        jeder Kategorie.
      </para>

      <sect3 id="menc-feat-telecine-encode-progressive">
        <title>Progressive</title>
        <para>
          Progressive Video erfordert kein spezielles Filtern, um es zu encodieren.
          Der einzige Parameter, den du gewiss anwenden solltest ist
          <option>-ofps 24000/1001</option>. Andernfalls wird
          <application>MEncoder</application> versuchen, bei 30000/1001 fps
          zu encodieren und Frames duplizieren.
        </para>

        <para>
          <screen>mencoder dvd://1 -oac copy -ovc lavc -ofps 24000/1001</screen>
        </para>

        <para>
          Dennoch ist es öfters der Fall, dass ein Video, das progressive aussieht,
          eigentlich kurze Teile telecine eingemischt hat. Solange du dir nicht
          sicher bist, ist es am sichersten, das Video als
          <link linkend="menc-feat-telecine-encode-mixedpt">gemischtes progressive und telecine</link>.
          zu behandeln. Der Performance-Verlust ist gering
          <link linkend="menc-feat-telecine-footnotes">[3]</link>.
        </para>
      </sect3>

      <sect3 id="menc-feat-telecine-encode-telecined">
        <title>Telecined</title>
        <para>
          Telecine kann umgekehrt werden, um den originalen 24000/1001-Inhalt zu erhalten,
          indem man einen Prozess verwendet, der inverse-telecine genannt wird.
          <application>MPlayer</application> enthält verschiedene Filter, um dies
          zu erreichen; der beste Filter, <option>pullup</option> wird in der Sektion
          <link linkend="menc-feat-telecine-encode-mixedpt">Gemischtes progressive und telecine</link>
          beschrieben.
        </para>
      </sect3>

      <sect3 id="menc-feat-telecine-encode-interlaced">
        <title>Interlaced</title>
        <para>

          In den meisten praktischen Fällen ist es nicht möglich, ein komplett
          progressives Video aus interlaced Inhalt zu erhalten. Der einzige Weg,
          dies ohne den Verlust der Hälfte der vertikalen Auflösung zu erreichen,
          ist das Verdoppeln der Framerate, und man kann versuchen zu
          "schätzen", wie die korrespondierenden Zeilen für jedes Feld
          vervollständigt werden sollten (dies hat Nachteile - siehe Methode 3).
        </para>

        <orderedlist>
          <listitem>
            <para>
              Das Video in interlaced Form encodieren. Normalerweise richtet Interlacing
              verheerenden Schaden für die Fähigkeit des Encoders an, gut zu komprimieren,
              <systemitem class="library">libavcodec</systemitem> hat jedoch zwei
              eigens für das ein wenig bessere Abspeichern von interlaced Video gedachte
              Parameter: <option>ildct</option> und <option>ilme</option>. Auch wenn
              die Verwendung von <option>mbd=2</option> dringend zu empfehlen ist
              <link linkend="menc-feat-telecine-footnotes">[2]</link>, weil es
              Macroblöcke wie nicht-interlaced an Stellen encodiert, an denen keine Bewegung
              stattfindet. Beachte, dass <option>-ofps</option> hier NICHT notwendig ist.

              <screen>mencoder dvd://1 -oac copy -ovc lavc -lavcopts ildct:ilme:mbd=2</screen>
            </para>
          </listitem>
          <listitem>
            <para>
              Nutze einen Deinterlacing-Filter vor dem Encodieren. Es stehen verschiedene
              dieser Filter zur Auswahl, jeder mit seinen eigenen Vor-
              und Nachteilen. Ziehe <option>mplayer -pphelp</option> und <option>mplayer -vf help</option>
              zu Rate, um zu sehen, welche
              verfügbar sind (suche nach "deint"), lies Michael Niedermayers
              <ulink url="http://guru.multimedia.cx/deinterlacing-filters/">Deinterlacing-Filter-Vergleich</ulink>
              und durchsuche die
              <ulink url="http://www.mplayerhq.hu/design7/mailing_lists.html">MPlayer-Mailinglisten</ulink>,
              um Diskussionen über die zahlreichen Filter zu finden.
              Nochmals, die Framerate ändert sich nicht, also kein
              <option>-ofps</option>. Deinterlacing sollte außerdem nach dem Zuschneiden
              (cropping) <link linkend="menc-feat-telecine-footnotes">[1]</link>
              und vor dem Skalieren angewandt werden.

              <screen>mencoder dvd://1 -oac copy -vf yadif -ovc lavc</screen>
            </para>
          </listitem>
          <listitem>
            <para>
              Unglücklicherweise arbeitet diese Option im Zusammenhang mit
              <application>MEncoder</application> fehlerhaft; sie sollte mit
              <application>MEncoder G2</application> gut funktionieren, den gibts aber
              noch nicht. Du könntest Abstürze erleben. Seis drum, der Zweck von
              <option> -vf tfields</option> ist es, einen vollen Frame aus jedem Feld
              zu erzeugen, was eine Framerate von 60000/1001 ergibt. Der Vorteil dieses
              Lösungsansatzes ist, dass nie irgendwelche Daten verloren gehen;
              dennoch, da jeder Frame aus nur einem Feld kommt, müssen die fehlenden Zeilen
              irgendwie interpoliert werden. Es gibt keine sehr guten Methoden, die
              fehlenden Daten zu generieren, und so wird das Resultat ein bisschen aussehen,
              als hätte man irgendeinen Deinterlacing-Filter verwendet. Die fehlenden Zeilen
              zu generieren erzeugt auch weitere Probleme, einfach weil sich die Menge
              an Daten verdoppelt. Somit sind höhere Encodier-Bitraten nötig, um
              die Qualität beizubehalten und mehr CPU-Power wird für beides,
              Encodieren und Decodieren, aufgewendet. Das Attribut tfields hat mehrere
              verschiedene Optionen dafür, wie die fehlenden Zeilen jedes Frames erzeugt
              werden.
              Wenn du diese Methode nutzt, dann nimm Bezug auf das Handbuch und wähle,
              welche Option auch immer am besten für dein Material aussieht.
              Beachte, dass du wenn <option>tfields</option> verwendet wird,
              sowohl <option>-fps</option> als auch <option>-ofps</option>spezifizieren <emphasis role="bold">musst</emphasis>,
              um die doppelte Framerate der originalen Quelle zu erhalten.

              <screen>mencoder dvd://1 -oac copy -vf tfields=2 -ovc lavc -fps 60000/1001 -ofps 60000/1001</screen>
            </para>
          </listitem>
          <listitem>
            <para>
              Wenn du vorhast, dramatisch herunterzuskalieren, kannst du nur eins
              der beiden Felder extrahieren und encodieren. Sicherlich, du wirst die
              Hälfte der vertikalen Auflösung verlieren, aber wenn du planst, bis auf
              1/2 des Originals herunter zu skalieren, macht der Verlust so gut wie
              gar nichts aus. Das Resultat wird eine progressive Datei mit 30000/1001
              Frames pro Sekunde sein. Die Prozedur ist, <option>-vf field</option>
              zu verwenden, dann die Ränder abzuschneiden
              <link linkend="menc-feat-telecine-footnotes">[1]</link> und angemessen
              zu skalieren. Vergiss nicht, dass du die Skalierung anpassen musst, um
              das Halbieren der vertikalen Auflösung zu kompensieren.
              <screen>mencoder dvd://1 -oac copy -vf field=0 -ovc lavc</screen>
            </para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3 id="menc-feat-telecine-encode-mixedpt">
        <title>Gemischtes progressive und telecine</title>
        <para>
          Um progressive und telecine Video komplett in progressive Video
          umzuwandeln, müssen die telecined Teile inverse-telecined werden.
          Die drei Wege, dies zu erreichen, werden unten beschrieben.
          Beachte, dass du inverse-telecine <emphasis role="bold">immer</emphasis>
          vor der Reskalierung durchführen solltest; es sei denn, du weißt wirklich,
          was du tust; mache inverse-telecine auch vor dem Entfernen der Ränder
          <link linkend="menc-feat-telecine-footnotes">[1]</link>.
          <option>-ofps 24000/1001</option> wird hier benötigt, weil das Output-Video
          24000/1001 Frames pro Sekunde werden soll.
        </para>

        <itemizedlist>
          <listitem>
            <para>
              <option>-vf pullup</option> wurde entworfen, um auf telecined Material
              inverse-telecine anzuwenden, während die progressiven Daten unangetastet
              bleiben. Damit dies richtig funktioniert, <emphasis role="bold">muss</emphasis>
              <option>pullup</option> vom <option>softskip</option>-Filter gefolgt werden, sonst
              wird <application>MEncoder</application> abstürzen.
              <option>pullup</option> ist trotz allem die sauberste und akkurateste
              Methode, die zum Encodieren von beidem telecine und
              "gemischtem progressive und telecine" zur Verfügung steht.

              <screen>mencoder dvd://1 -oac copy -vf pullup,softskip -ovc lavc -ofps 24000/1001</screen>
            </para>
          </listitem>

          <listitem>
            <para>
              Eine ältere Methode ist, anstatt inverse-telecine auf die telecined Teile
              anzuwenden, telecine auf nicht-telecined Teile und dann inverse-telecine auf das
              ganze Video anzuwenden. Hört sich verwirrend an? softpulldown ist
              ein Filter, der ein Video durchgeht und die komplette Datei telecined macht.
              Lassen wir auf softpulldown entweder <option>detc</option> oder <option>ivtc</option>
              folgen, wird das Endergebnis vollkommen progressiv. <option>-ofps 24000/1001</option>
              wird benötigt.

              <screen>mencoder dvd://1 -oac copy -vf softpulldown,ivtc=1 -ovc lavc -ofps 24000/1001</screen>
            </para>
          </listitem>

          <listitem>
            <para>
              Ich habe <option>-vf filmdint</option> selbst verwendet, aber lies hier, was
              D Richard Felker III zu erzählen hat:

              <blockquote>
                <para>
                  Es ist OK, aber IMO versucht er zu oft eher ein deinterlace
                  als ein inverse telecine durchzuführen (ganz wie Settop-DVD-Player
                  &amp; progressive TVs), was ein hässliches Flimmern erzeugt und
                  andere Artefakte. Wenn du vorhast, es anzuwenden, musst du zumindest
                  einige Zeit darauf verwenden, die Optionen zu tunen und zuerst den Output
                  zu beobachten, damit du auch sicher sein kannst, dass du nichts
                  vermasselst.
                </para>
              </blockquote>
            </para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 id="menc-feat-telecine-encode-mixedpi">
        <title>Gemischtes progressive und interlaced</title>
        <para>
          Es gibt zwei Optionen für den Umgang mit dieser Kategorie, jede von
          beiden stellt einen Kompromiss dar. Du solltest basierend auf
          Dauer/Stelle jedes Typs entscheiden.
        </para>

        <itemizedlist>
          <listitem>
            <para>
              Behandle es wie progressive. Die interlaced Teile werden interlaced
              aussehen und einige der interlaced Felder müssen weggelassen werden,
              was ein wenig zu Sprüngen führt. Du kannst einen
              Nachbearbeitungsfilter verwenden, wenn du willst, aber dies wird die
              progressive-Anteile geringfügig verringern.
            </para>

            <para>
              Diese Option sollte definitiv nicht verwendet werden, wenn du eventuell
              Video auf einem interlaced Gerät anzeigen willst (mit einer TV-Karte
              zum Beispiel). Wenn du interlaced Frames in einem Video mit 24000/1001
              Frames pro Sekunde hast, werden diese zusammen mit den progressive
              Frames telecined. Die Hälfte der interlaced "Frames" werden für die
              Dauer von drei Feldern (3/(60000/1001) Sekunden) angezeigt, was
              einen flimmernden "Zeitrücksprung"-Effekt zur Folge hat, der
              ziemlich schlecht aussieht. Solltest du dies dennoch versuchen,
              <emphasis role="bold">musst</emphasis> du einen
              Deinterlacing-Filter wie <option>lb</option> oder <option>l5</option>
              anwenden.
            </para>

            <para>
              Es wäre auch keine gute Idee für eine progressive Anzeige. Es wird
              Paare aufeinander folgender interlaced Felder auslassen, was eine
              Unstetigkeit zur Folge hat, die eher sichtbar ist als mit der
              zweiten Methode, die einige progressive Frames zweimal anzeigt.
              Ein interlaced Video mit 30000/1001 Frames pro Sekunde ist bereits
              ein bisschen abgehackt, weil es wirklich mit 60000/1001 Felder pro
              Sekunde angezeigt werden sollte, sodass sich die doppelten Frames
              nicht zu sehr abzeichnen.
            </para>

            <para>
              Egal welchen Weg du wählst, es ist das beste, deinen Inhalt
              zu berücksichtigen und wie du ihn anzeigen willst. Ist dein Video
              zu 90% progressive und du hast nie vor, es auf einem TV-Bildschirm
              anzuzeigen, solltest du einen progressive-Ansatz wählen. Ist es nur
              halb-progressive, willst du es eventuell so encodieren, als sei alles
              interlaced.
            </para>
          </listitem>

          <listitem>
            <para>
              Behandle es wie interlaced. Einige Frames des progressive-Anteils
              müssen dupliziert werden, was zu Sprüngen führt. Nochmal,
              Deinterlacing-Filter können die progressive-Anteile leicht verringern.
            </para>
          </listitem>

        </itemizedlist>
      </sect3>

    </sect2>

    <sect2 id="menc-feat-telecine-footnotes">
      <title>Fußnoten</title>
      <orderedlist>
        <listitem>
          <formalpara>
            <title>Über das Zuschneiden (cropping):</title>
            <para>
              Videodaten auf DVDs werden in einem YUV 4:2:0 genannten Format abgelegt.
              In einem YUV-Video, werden Helligkeit und Chrominanz separat gespeichert.
              Da das menschliche Auge ein bisschen weniger empfindlich auf Farbe
              reagiert als auf Helligkeit, ist in einem YUV 4:2:0 Bild nur ein
              Chrominanz-Pixel für alle vier Helligkeits-Pixel vorhanden.
              In einem progressive Bild, besitzt jedes Quadrat von vier luma-Pixeln (zwei
              auf jeder Seite) ein gemeinsames chroma-Pixel. Du musst progressive YUV
              4:2:0 zu geradzahligen Auflösungen zurechtschneiden und geradzahlige
              Offsets verwenden. Zum Beispiel ist
              <option>crop=716:380:2:26</option> OK,
              <option>crop=716:380:3:26 </option> aber nicht.
            </para>
          </formalpara>

          <para>
            Wenn du es mit interlaced YUV 4:2:0 zu tun hast, ist die Situation
            ein wenig komplizierter. Anstatt dass immer vier luma-Pixel im
            <emphasis>Frame</emphasis> sich ein chroma-Pixel teilen, teilen sich
            immer vier luma-Pixel in jedem <emphasis>Feld</emphasis> ein
            chroma-Pixel. Wenn Felder zur Formung eines Frames interlaced werden,
            ist jede Scanzeile ein Pixel hoch. Jetzt liegen anstatt je vier
            luma-Pixel in einem Quadrat immer zwei Pixel nebeneinander und die
            anderen zwei Pixel liegen zwei Scanzeilen weiter unten nebeneinander.
            Die zwei luma-Pixel in der dazwischen liegenden Scanzeile sind vom
            anderen Feld und teilen sich somit ein anderes chroma-Pixel mit
            zwei luma-Pixeln zwei Scanzeile entfernt. All diese Konfusion macht
            es notwendig, vertikale Ausschneide-Abmessungen und Offsets zu
            haben, die ein Vielfaches von vier sind. Horizontal kann geradzahlig
            bleiben.
          </para>

          <para>
            Für telecined Video empfehle ich, das Zuschneiden nach dem inverse
            telecining stattfinden zu lassen. Ist das Video einmal progressive,
            musst du nur noch mit geraden Zahlen zuschneiden. Wenn du wirklich die
            leichte Beschleunigung haben willst, die zuerst zuzuschneiden
            möglicherweise bietet, musst du vertikal mit einem Vielfachen von vier
            zuschneiden, oder der inverse-telecine Filter wird keine korrekten Daten
            haben.
          </para>

          <para>
            Für interlaced (nicht telecined) Video musst du immer
            mit einem Vielfachen von vier zuschneiden, es sei denn, du verwendest
            <option>-vf field</option> vor dem Schneiden.
          </para>
        </listitem>

        <listitem><formalpara>
            <title>Über Encodier-Parameter und Qualität:</title>
            <para>
              Nur weil ich hier <option>mbd=2</option> vorschlage, heißt das nicht,
              dass es woanders benutzt werden soll. Zusammen mit <option>trell</option>
              ist <option>mbd=2</option> eine der Optionen von
              <systemitem class="library">libavcodec</systemitem>, welche die
              Qualität am deutlichsten heben, und du solltest stets das letzte der beiden
              anwenden, außer das Abfallen der Encodiergeschwindigkeit ist abschreckend
              hoch (z.B. Encodierung in Echtzeit). Es gibt eine Menge anderer Optionen für
              <systemitem class="library">libavcodec</systemitem>, die die Encodierqualität
              verbessern (und die Encodiergeschwindigkeit verringern), dies liegt aber jenseits
              des Rahmens dieses Dokuments.
            </para>
          </formalpara>
        </listitem>

        <listitem>
          <formalpara>
            <title>Über die Performance von pullup:</title>
            <para>
              <option>Pullup</option> kann sicher (zusammen mit <option>softskip</option>)
              auf progressive Video angewandt werden und ist für gewöhnlich eine gute Idee,
              es sei denn, die Quelle wurde definitiv als vollkommen progressive verifiziert.
              Der Performaceverlust ist in den meisten Fällen gering. Bei einer Minimalencodierung
              macht <option>pullup</option> <application>MEncoder</application>
              50% langsamer. Das Hinzufügen von Soundverarbeitung und erweiterten
              <option>lavcopts</option> überschattet diesen Unterschied
              und drückt den Performanceabfall, der mit dem Verwenden von <option>pullup</option>
              verbunden war, runter auf 2%.
            </para>
          </formalpara>
        </listitem>

      </orderedlist>

    </sect2>

  </sect1>


  <sect1 id="menc-feat-enc-libavcodec">
    <title>Encodieren mit der <systemitem class="library">libavcodec</systemitem>
      Codecfamilie</title>

    <para>
      <systemitem class="library">libavcodec</systemitem>
      stellt einfache Encodierung für eine Menge interessanter Video- und Audioformate
      zur Verfügung.
      Du kannst folgende Codecs encodieren (mehr oder weniger aktuell):
    </para>

    <sect2 id="menc-feat-enc-libavcodec-video-codecs">
      <title>Videocodecs von <systemitem class="library">libavcodec</systemitem></title>

      <para>
        <informaltable frame="all">
          <tgroup cols="2">
            <thead>
              <row><entry>Name des Videocodecs</entry><entry>Beschreibung</entry></row>
            </thead>
            <tbody>
              <row><entry>mjpeg</entry><entry>
                  Motion-JPEG
                </entry></row>
              <row><entry>ljpeg</entry><entry>
                  Verlustfreies JPEG
                </entry></row>
              <row><entry>jpegls</entry><entry>
                  JPEG LS
                </entry></row>
              <row><entry>targa</entry><entry>
                  Targa-Bild
                </entry></row>
              <row><entry>gif</entry><entry>
                  GIF-Bild
                </entry></row>
              <row><entry>png</entry><entry>
                  PNG-Bild
                </entry></row>
              <row><entry>bmp</entry><entry>
                  BMP-Bild
                </entry></row>
              <row><entry>h261</entry><entry>
                  H.261
                </entry></row>
              <row><entry>h263</entry><entry>
                  H.263
                </entry></row>
              <row><entry>h263p</entry><entry>
                  H.263+
                </entry></row>
              <row><entry>mpeg4</entry><entry>
                  ISO Standard MPEG-4 (DivX, Xvid-kompatibel)
                </entry></row>
              <row><entry>msmpeg4</entry><entry>
                  Pre-Standard MPEG-4 Variante von MS, v3 (AKA DivX3)
                </entry></row>
              <row><entry>msmpeg4v1</entry><entry>
                  Pre-Standard MPEG-4 von MS, v1
                </entry></row>
              <row><entry>msmpeg4v2</entry><entry>
                  Pre-Standard MPEG-4 von MS, v2 (in alten ASF-Dateien verwendet)
                </entry></row>
              <row><entry>wmv1</entry><entry>
                  Windows Media Video, Version 1 (AKA WMV7)
                </entry></row>
              <row><entry>wmv2</entry><entry>
                  Windows Media Video, Version 2 (AKA WMV8)
                </entry></row>
              <row><entry>rv10</entry><entry>
                  RealVideo 1.0
                </entry></row>
              <row><entry>rv20</entry><entry>
                  RealVideo 2.0
                </entry></row>
              <row><entry>mpeg1video</entry><entry>
                  MPEG-1 Video
                </entry></row>
              <row><entry>mpeg2video</entry><entry>
                  MPEG-2 Video
                </entry></row>
              <row><entry>huffyuv</entry><entry>
                  Verlustfreie (lossless) Kompression
                </entry></row>
              <row><entry>ffvhuff</entry><entry>
                  FFmpeg-modifizierter huffyuv, verlustfrei
                </entry></row>
              <row><entry>asv1</entry><entry>
                  ASUS Video v1
                </entry></row>
              <row><entry>asv2</entry><entry>
                  ASUS Video v2
                </entry></row>
              <row><entry>vcr1</entry><entry>
                  ATI VCR1 codec
                </entry></row>
              <row><entry>ffv1</entry><entry>
                  FFmpeg's verlustfreier (lossless) Videocodec
                </entry></row>
              <row><entry>svq1</entry><entry>
                  Sorenson Video 1
                </entry></row>
              <row><entry>flv</entry><entry>
                  Sorenson H.263, der in Flash Video benutzt wird
                </entry></row>
              <row><entry>flashsv</entry><entry>
                  Flash Screen Video
                </entry></row>
              <row><entry>dvvideo</entry><entry>
                  Sony Digital Video
                </entry></row>
              <row><entry>snow</entry><entry>
                  FFmpeg's experimenteller Wavelet-basierter Codec
                </entry></row>
              <row><entry>zbmv</entry><entry>
                  Zip Blocks Motion Video
                </entry></row>
              <row><entry>cljr</entry><entry>
                  Cirrus Logic AccuPak Codec
                </entry></row>
            </tbody>
          </tgroup>
        </informaltable>

        Die erste Spalte enthält die Codecnamen, die nach der Konfiguration
        <literal>vcodec</literal> übergeben werden müssen, wie:
        <option>-lavcopts vcodec=msmpeg4</option>
      </para>
      <informalexample>
        <para>
          Ein Beispiel mit MJPEG-Komprimierung:
          <screen>mencoder dvd://2 -o title2.avi -ovc lavc -lavcopts vcodec=mjpeg -oac copy</screen>
        </para>
      </informalexample>
    </sect2>

    <sect2 id="menc-feat-enc-libavcodec-audio-codecs">
      <title>Audiocodecs von <systemitem class="library">libavcodec</systemitem></title>
      <para>
        <informaltable frame="all">
          <tgroup cols="2">
            <thead>
              <row><entry>Name des Audiocodecs</entry><entry>Beschreibung</entry></row>
            </thead>
            <tbody>
              <row>
                <entry>ac3</entry>
                <entry>Dolby Digital (AC-3)</entry>
              </row>
              <row>
                <entry>adpcm_*</entry>
                <entry>Adaptive PCM-Formate - siehe begleitende Tabelle</entry>
              </row>
              <row>
                <entry>flac</entry>
                <entry>Free Lossless Audio Codec (FLAC)</entry>
              </row>
              <row>
                <entry>g726</entry>
                <entry>G.726 ADPCM</entry>
              </row>
              <row>
                <entry>libamr_nb</entry>
                <entry>3GPP Adaptive Multi-Rate (AMR) narrow-band</entry>
              </row>
              <row>
                <entry>libamr_wb</entry>
                <entry>3GPP Adaptive Multi-Rate (AMR) wide-band</entry>
              </row>
              <row>
                <entry>libfaac</entry>
                <entry>Advanced Audio Coding (AAC) - verwendet FAAC</entry>
              </row>
              <row>
                <entry>libgsm</entry>
                <entry>ETSI GSM 06.10 full rate</entry>
              </row>
              <row>
                <entry>libgsm_ms</entry>
                <entry>Microsoft GSM</entry>
              </row>
              <row>
                <entry>libmp3lame</entry>
                <entry>MPEG-1 audio layer 3 (MP3) - verwendet LAME</entry>
              </row>
              <row>
                <entry>mp2</entry>
                <entry>MPEG-1 Audio Layer 2</entry>
              </row>
              <row>
                <entry>pcm_*</entry>
                <entry>PCM-Formate - siehe begleitende Tabelle</entry>
              </row>
              <row>
                <entry>roq_dpcm</entry>
                <entry>Id Software RoQ DPCM</entry>
              </row>
              <row>
                <entry>sonic</entry>
                <entry>experimenteller verlustbehafteter FFmpeg-Codec</entry>
              </row>
              <row>
                <entry>sonicls</entry>
                <entry>experimenteller verlustfreier FFmpeg-Codec</entry>
              </row>
              <row>
                <entry>vorbis</entry>
                <entry>Vorbis</entry>
              </row>
              <row>
                <entry>wma1</entry>
                <entry>Windows Media Audio v1</entry>
              </row>
              <row>
                <entry>wma2</entry>
                <entry>Windows Media Audio v2</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        Die erste Spalte enthält die Codecnamen, die nach der Konfiguration
        <literal>acodec</literal> übergeben werden müssen, wie:
        <option>-lavcopts acodec=ac3</option>
      </para>

      <informalexample>
        <para>
          Ein Beispiel mit AC3-Kompression:
          <screen>mencoder dvd://2 -o title2.avi -oac lavc -lavcopts acodec=ac3 -ovc copy</screen>
        </para>
      </informalexample>

      <para>
        Im Gegensatz zu den Videocodecs von <systemitem class="library">libavcodec</systemitem>
        machen dessen Audiocodecs keinen weisen Gebrauch von den Bits, die ihnen übergeben
        werden, da es ihnen an einem minimalen psychoakustischen Modell fehlt (falls
        überhaupt eins vorhanden ist), wodurch sich die meisten anderen
        Codec-Implementierungen auszeichnen.
        Beachte jedoch, dass all diese Audiocodecs sehr schnell sind und überall dort
        hervorragend arbeiten, wo <application>MEncoder</application> mit
        <systemitem class="library">libavcodec</systemitem> kompiliert wurde (was
        meistens der Fall ist) und nicht von externen Programmbibliotheken abhängt.
      </para>

      <sect3 id="menc-feat-enc-libavcodec-audio-codecs-pcmadpcm">
        <title>PCM/ADPCM-Format, begleitende Tabelle</title>

        <para>
        <informaltable frame="all">
        <tgroup cols="2">
        <thead>
        <row><entry>PCM/ADPCM Codecname</entry><entry>Beschreibung</entry></row>
        </thead>
        <tbody>
        <row>
          <entry>pcm_s32le</entry>
          <entry>signed 32-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_s32be</entry>
          <entry>signed 32-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_u32le</entry>
          <entry>unsigned 32-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_u32be</entry>
          <entry>unsigned 32-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_s24le</entry>
          <entry>signed 24-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_s24be</entry>
          <entry>signed 24-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_u24le</entry>
          <entry>unsigned 24-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_u24be</entry>
          <entry>unsigned 24-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_s16le</entry>
          <entry>signed 16-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_s16be</entry>
          <entry>signed 16-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_u16le</entry>
          <entry>unsigned 16-bit little-endian</entry>
        </row>
        <row>
          <entry>pcm_u16be</entry>
          <entry>unsigned 16-bit big-endian</entry>
        </row>
        <row>
          <entry>pcm_s8</entry>
          <entry>signed 8-bit</entry>
        </row>
        <row>
          <entry>pcm_u8</entry>
          <entry>unsigned 8-bit</entry>
        </row>
        <row>
          <entry>pcm_alaw</entry>
          <entry>G.711 A-LAW </entry>
        </row>
        <row>
          <entry>pcm_mulaw</entry>
          <entry>G.711 &mu;-LAW</entry>
        </row>
        <row>
          <entry>pcm_s24daud</entry>
          <entry>signed 24-bit D-Cinema Audioformat</entry>
        </row>
        <row>
          <entry>pcm_zork</entry>
          <entry>Activision Zork Nemesis</entry>
        </row>
        <row>
          <entry>adpcm_ima_qt</entry>
          <entry>Apple QuickTime</entry>
        </row>
        <row>
          <entry>adpcm_ima_wav</entry>
          <entry>Microsoft/IBM WAVE</entry>
        </row>
        <row>
          <entry>adpcm_ima_dk3</entry>
          <entry>Duck DK3</entry>
        </row>
        <row>
          <entry>adpcm_ima_dk4</entry>
          <entry>Duck DK4</entry>
        </row>
        <row>
          <entry>adpcm_ima_ws</entry>
          <entry>Westwood Studios</entry>
        </row>
        <row>
          <entry>adpcm_ima_smjpeg</entry>
          <entry>SDL Motion JPEG</entry>
        </row>
        <row>
          <entry>adpcm_ms</entry>
          <entry>Microsoft</entry>
        </row>
        <row>
          <entry>adpcm_4xm</entry>
          <entry>4X Technologies</entry>
        </row>
        <row>
          <entry>adpcm_xa</entry>
          <entry>Phillips Yellow Book CD-ROM eXtended Architecture</entry>
        </row>
        <row>
          <entry>adpcm_ea</entry>
          <entry>Electronic Arts</entry>
        </row>
        <row>
          <entry>adpcm_ct</entry>
          <entry>Creative 16->4-bit</entry>
        </row>
        <row>
          <entry>adpcm_swf</entry>
          <entry>Adobe Shockwave Flash</entry>
        </row>
        <row>
          <entry>adpcm_yamaha</entry>
          <entry>Yamaha</entry>
        </row>
        <row>
          <entry>adpcm_sbpro_4</entry>
          <entry>Creative VOC SoundBlaster Pro 8->4-bit</entry>
        </row>
        <row>
          <entry>adpcm_sbpro_3</entry>
          <entry>Creative VOC SoundBlaster Pro 8->2.6-bit</entry>
        </row>
        <row>
          <entry>adpcm_sbpro_2</entry>
          <entry>Creative VOC SoundBlaster Pro 8->2-bit</entry>
        </row>
        <row>
          <entry>adpcm_thp</entry>
          <entry>Nintendo GameCube FMV THP</entry>
        </row>
        <row>
          <entry>adpcm_adx</entry>
          <entry>Sega/CRI ADX</entry>
        </row>
        </tbody>
        </tgroup>
        </informaltable>
        </para>
      </sect3>

    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-lavc-encoding-options">
      <title>Encodieroptionen von libavcodec</title>

      <para>
        Idealerweise möchtest du eventuell in der Lage sein, dem Encoder einfach zu sagen,
        er soll in den "hochqualitativen" Modus wechseln und weiter machen.
        Das wäre vermutlich nett, aber unglücklicherweise schwer zu implementieren, da
        verschiedene Encodieroptionen unterschiedliche Qualitätsresultate hervorbringen,
        abhängig vom Quellmaterial.
        Das liegt daran, dass die Komprimierung von den visuellen Eigenschaften des fraglichen Videos abhängt.
        Zum Beispiel haben Anime und Live-Action sehr unterschiedliche Eigenschaften und
        benötigen aus diesm Grund verschiedene Optionen, um optimale Encodierung zu erreichen.
        Die gute Neuigkeit ist, dass einige Optionen wie <option>mbd=2</option>,
        <option>trell</option> und <option>v4mv</option> nie ausgelassen werden sollten.
        Siehe unten nach der detaillierten Beschreibung allgemeiner Encodieroptionen.
      </para>


      <itemizedlist>
        <title>Anzupassende Optionen:</title>
        <listitem>
          <para>
            <emphasis role="bold">vmax_b_frames</emphasis>: 1 oder 2 ist gut, abhängig vom Film.
            Beachte, dass du, falls deine Encodierung von DivX5 decodierbar sein muss, den
            Support für "closed GOP" aktivieren musst, indem du die
            <systemitem class="library">libavcodec</systemitem>-Option <option>cgop</option>
            verwendest, du musst jedoch Szenenerkennung deaktivieren, was wiederum keine gute
            Idee ist, da es die Ecodierungseffizienz etwas angreift.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">vb_strategy=1</emphasis>: hilft in Szenen mit viel
            Bewegung (high-motion).
            Bei manchen Videos wird vmax_b_frames der Qualität schaden, vmax_b_frames=2
            zusammen mit vb_strategy=1 hilft jedoch.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">dia</emphasis>: Bewegungssuchbereich. Größer ist besser
            als kleiner.
            Negative Werte sind ein komplett anderer Maßstab.
            Gute Werte sind -1 für ein schnelle oder 2-4 für langsame Encodierung.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">predia</emphasis>: Bewegungssuche Vorabdurchlauf (pre-pass).
            Nicht so wichtig wie dia. Gute Werte sind 1 (Standard) bis 4. Erfordert preme=2, um
            wirklich was zu nützen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">cmp, subcmp, precmp</emphasis>: Vergleichsfunktion zur
            Bewegungseinschätzung.
            Experimentiere mit Werten von 0 (Standard), 2 (hadamard), 3 (dct) und
            6 (Ratenverzerrung).
            0 ist am schnellsten und ausreichend für precmp.
            Für cmp und subcmp ist 2 gut bei Anime, und 3 ist gut bei Live-Action.
            6 kann leicht besser sein oder auch nicht, ist aber langsam.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">last_pred</emphasis>: Anzahl der Bewegungsvorhersagen, die
            vom vorherigen Frame genommen werden sollen.
            1-3 oder so hilft bei geringer Geschwindigkeitseinbuße.
            Höhere Werte sind langsam bei keinerlei Zusatzgewinn.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">cbp, mv0</emphasis>: Kontrolliert die Auswahl von Macroblöcken.
            Kleine Geschwindigkeitseinbußen bei kleinem Qualitätsgewinn.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">qprd</emphasis>: adaptive Quantisierung basierend auf der
            Komplexität des Macroblocks.
            Kann hilfreich sein oder schaden, abhängig vom Video und anderen Optionen.
            Dies kann Artefakte verursachen, es sei denn, du setzt vqmax auf einen halbwegs
            kleinen Wert (6 ist gut, vielleicht so langsam wie 4); vqmin=1 sollte ebenfalls
            helfen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">qns</emphasis>: sehr langsam, speziell wenn kombiniert
            mit qprd.
            Diese Option veranlasst den Encoder, durch Kompressionsartefakte entstandenes
            Rauschen zu minimieren anstatt das encodierte Video strikt der Quelle anzupassen.
            Verwende dies nicht, es sei denn du, hast bereits alles andere so weit wie möglich
            optimiert und die Resultate sind immer noch nicht gut genug.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">vqcomp</emphasis>: Frequenzkontrolle optimieren.
            Welche Werte gut sind, hängt vom Film ab.
            Du kannst dies sicher so lassen wie es ist, wenn du willst.
            Wird vqcomp verringert, werden mehr Bits auf Szenen mit geringer Komlexität
            gelegt, wird es erhöht, legt es diese Bits auf Szenen mit hoher Komlexität
            (Standard: 0.5, Bereich: 0-1. empfohlener Bereich: 0.5-0.7).
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">vlelim, vcelim</emphasis>: Setzt die Schwelle für die
            Eliminierung einzelner Koeffizienten bei Helligkeits- und Farbanteilen.
            Sie werden in allen MPEG-ähnlichen Algorithmen getrennt encodiert.
            Die Idee hinter diesen Optionen ist, einige gute Heuristiken zu verwenden,
            um zu bestimmen, wenn ein Wechsel innerhalb eines Blocks kleiner als der
            der von dir festgelegte Schwellenwert ist und in solch einem Fall den
            Block einfach so zu encodieren als fände "kein Wechsel" statt.
            Das spart Bits und beschleunigt womöglich die Encodierunng. vlelim=-4 und vcelim=9
            scheinen gut für Live-Filme zu sein, helfen aber scheinbar nicht bei Anime;
            beim Encodieren einer Animation solltest du sie womöglich unverändert lassen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">qpel</emphasis>: Bewegungsabschätzung auf ein viertel
            Pixel (quarter pel).
            MPEG-4 verwendet als Voreinstellung eine Halbpixel-Genauigkeit für die Bewegungssuche,
            deswegen hat diese Option einen Overhead, da mehr Informationen in der
            encodierte Datei untergebracht werden.
            Der Kompressionsgewinn/-verlust hängt vom Film ab, ist aber in der Regel nicht
            sonderlich effektiv bei Anime.
            qpel zieht immer eine signifikante Erhöhung der CPU-Decodierzeit nach
            sich (+25% in der Praxis).
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">psnr</emphasis>: wirkt sich eigentlich nicht auf
            das Encodieren aus, schreibt jedoch eine Log-Datei mit Typ/Größe/Qualität
            jedes Frames und gibt am Ende die Summe des PSNR Signal-zu-Rauschabstands
            (Peak Signal to Noise Ratio) aus.
          </para>
        </listitem>

      </itemizedlist>

      <itemizedlist>
        <title>Optionen, mit denen besser nicht herumgespielt werden sollte:</title>
        <listitem>
          <para>
            <emphasis role="bold">vme</emphasis>: Der Standardwert ist der beste.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">lumi_mask, dark_mask</emphasis>: Psychovisuell adaptive
            Quantisierung.
            Du solltest nicht im Traum daran denken, mit diesen Optionen herumzuspielen,
            wenn dir Qualität wichtig ist.
            Vernünftige Werte mögen in deinem Fall effektiv sein, aber sei gewarnt,
            dies ist sehr subjektiv.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">scplx_mask</emphasis>: Versucht, Blockartefakte
            zu verhindern, Postprocessing ist aber besser.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="menc-feat-mpeg4-lavc-example-settings">
      <title>Beispiele für Encodierungseinstellungen</title>

      <para>
        Die folgenden Einstellungen sind Beispiele verschiedener Kombinationen
        von Encodierungsoptionen, die den Kompromiss Geschwindigkeit gegenüber
        Qualität bei gleicher Zielbitrate beeinflussen.
      </para>

      <para>
        Alle Encodierungseinstellungen wurden auf einem Beispielvideo
        mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps und
        der Rechner war ein AMD-64 3400+ mit 2400 MHz im 64bit-Modus.
        Jede Encodiereinstellung zeichnet sich aus durch die gemessene
        Encodiergeschwindigkeit (in Frames pro Sekunde) und den PSNR-Verlust
        (in dB) im Vergleich zu Einstellungen für "sehr hohe Qualität".
        Bitte habe Verständnis, dass du abhängig von deiner Quelldatei,
        deinem Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche
        Resultate erzielen wirst.
      </para>

      <para>
        <informaltable frame="all">
          <tgroup cols="4">
            <thead>
              <row><entry>Beschreibung</entry><entry>Encodieroptionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
            </thead>
            <tbody>
              <row>
                <entry>Sehr hohe Qualität</entry>
                <entry><option>vcodec=mpeg4:mbd=2:mv0:trell:v4mv:cbp:last_pred=3:predia=2:dia=2:vmax_b_frames=2:vb_strategy=1:precmp=2:cmp=2:subcmp=2:preme=2:qns=2</option></entry>
                <entry>6fps</entry>
                <entry>0dB</entry>
              </row>
              <row>
                <entry>Hohe Qualität</entry>
                <entry><option>vcodec=mpeg4:mbd=2:trell:v4mv:last_pred=2:dia=-1:vmax_b_frames=2:vb_strategy=1:cmp=3:subcmp=3:precmp=0:vqcomp=0.6:turbo</option></entry>
                <entry>15fps</entry>
                <entry>-0.5dB</entry>
              </row>
              <row>
                <entry>Schnell</entry>
                <entry><option>vcodec=mpeg4:mbd=2:trell:v4mv:turbo</option></entry>
                <entry>42fps</entry>
                <entry>-0.74dB</entry>
              </row>
              <row>
                <entry>Echtzeit</entry>
                <entry><option>vcodec=mpeg4:mbd=2:turbo</option></entry>
                <entry>54fps</entry>
                <entry>-1.21dB</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </sect2>

    <sect2 id="custommatrices"><title>Maßgeschneiderte inter/intra-Matrizen</title>

      <para>
        Mit diesem Feature von <systemitem class="library">libavcodec</systemitem>
        bist du in der Lage, eigene inter- (I-Frames/Keyframes) und intra-Matrizen
        (P-Frames/predicted Frames) zu setzen. Es wird von vielen Codecs unterstützt:
        <systemitem>mpeg1video</systemitem> und <systemitem>mpeg2video</systemitem>
        sollen damit funktionieren.
      </para>

      <para>
        Eine typische Anwendung dieses Features ist, die von den
        <ulink url="http://www.kvcd.net/">KVCD</ulink>-Specifikationen
        bevorzugten Matrizen zu setzen.
      </para>

      <para>
        Die <emphasis role="bold">KVCD "Notch" Quantisierungsmatrix:</emphasis>
      </para>

      <para>
        Intra:
<screen>8  9 12 22 26 27 29 34
9 10 14 26 27 29 34 37
12 14 18 27 29 34 37 38
22 26 27 31 36 37 38 40
26 27 29 36 39 38 40 48
27 29 34 37 38 40 48 58
29 34 37 38 40 48 58 69
34 37 38 40 48 58 69 79</screen>

        Inter:
<screen>16 18 20 22 24 26 28 30
18 20 22 24 26 28 30 32
20 22 24 26 28 30 32 34
22 24 26 30 32 32 34 36
24 26 28 32 34 34 36 38
26 28 30 32 34 36 38 40
28 30 32 34 36 38 42 42
30 32 34 36 38 40 42 44</screen>
      </para>

      <para>
        Anwendung:
        <screen>$ mencoder <replaceable>input.avi</replaceable> -o <replaceable>output.avi</replaceable> -oac copy -ovc lavc -lavcopts inter_matrix=...:intra_matrix=... </screen>
      </para>

      <para>
<screen>$ mencoder <replaceable>input.avi</replaceable> -ovc lavc -lavcopts
vcodec=mpeg2video:intra_matrix=8,9,12,22,26,27,29,34,9,10,14,26,27,29,34,37,
12,14,18,27,29,34,37,38,22,26,27,31,36,37,38,40,26,27,29,36,39,38,40,48,27,
29,34,37,38,40,48,58,29,34,37,38,40,48,58,69,34,37,38,40,48,58,69,79
:inter_matrix=16,18,20,22,24,26,28,30,18,20,22,24,26,28,30,32,20,22,24,26,
28,30,32,34,22,24,26,30,32,32,34,36,24,26,28,32,34,34,36,38,26,28,30,32,34,
36,38,40,28,30,32,34,36,38,42,42,30,32,34,36,38,40,42,44 -oac copy -o svcd.mpg</screen>
      </para>
    </sect2>


    <sect2 id="menc-feat-dvd-mpeg4-example">
      <title>Beispiel</title>

      <para>
        Jetzt hast du gerade eben deine brandneue Kopie von Harry Potter und die
        Kammer des Schreckens gekauft (natürlich die Breitbildedition), und du
        willst diese DVD so rippen, dass du sie deinem Home Theatre PC hinzufügen
        kannst. Dies ist eine Region-1-DVD, also ist sie NTSC. Das unten stehende
        Beispiel wird auch auf PAL zutreffen, nur dass du
        <option>-ofps 24000/1001</option> weglässt (weil die Ausgabeframerate die
        gleiche ist wie die Eingabeframerate), und logischerweise werden die
        Ausschnittsabmessungen anders sein.
      </para>

      <para>
        Nach dem Start von <option>mplayer dvd://1</option>, verfolgen wir den
        detailliert in der Sektion <link linkend="menc-feat-telecine">Wie mit telecine
          und interlacing in NTSC-DVDs umgehen</link> beschriebenen Prozess und
        entdecken, dass es progressive Video mit 24000/1001 fps ist, was bedeutet, dass
        wir keinen inverse telecine-Filter wie <option>pullup</option> oder
        <option>filmdint</option> anwenden müssen.
      </para>

      <para id="menc-feat-dvd-mpeg4-example-crop">
        Als Nächstes wollen wir das passende Ausschnittsrechteck bestimmen, also
        verwenden wir den cropdetect-Filter:

        <screen>mplayer dvd://1 -vf cropdetect</screen>

        Stelle sicher, dass du einen voll gefüllten Frame anstrebst (wie zum
        Beispiel eine helle Szene, nach den Eröffnungs-Credits und Filmlogos),
        und dass du diese Ausgabe in <application>MPlayer</application>s Konsole siehst:

        <screen>crop area: X: 0..719  Y: 57..419  (-vf crop=720:362:0:58)</screen>

        Wir spielen den Film dann mit diesem Filter ab, um seine Korrektheit zu testen:

        <screen>mplayer dvd://1 -vf crop=720:362:0:58</screen>

        Und wir sehen, dass er einfach perfekt aussieht. Als Nächstes vergewissern wir
        uns, dass Breite und Höhe ein Vielfaches von 16 sind. Die Breite ist gut,
        aber die Höhe ist es nicht. Da wir in der 7-ten Klasse in Mathe nicht gefehlt
        haben, wissen wir, dass das am nähesten liegende Vielfache von 16 kleiner
        als 362 der Wert 352 ist (Taschenrechner ist erlaubt).
      </para>

      <para>
        Wir könnten einfach <option>crop=720:352:0:58</option> verwenden, aber es wäre
        nett, ein bisschen von oben und ein bisschen von unten wegzunehmen, sodass
        wir zentriert bleiben. Wir haben die Höhe um 10 Pixel schrumpfen lassen, aber
        wir wollen das y-Offset nicht um 5 Pixel erhöhen, da dies eine ungerade Zahl
        ist und die Qualität nachteilig beeinflussen würde. Statt dessen werden wir
        das y-Offset um 4 Pixel erhöhen:

        <screen>mplayer dvd://1 -vf crop=720:352:0:62</screen>

        Ein anderer Grund, Pixel von beidem - oben und unten - abzuschnipseln ist,
        dass wir sicher gehen wollen, jegliches halbschwarze Pixel eliminiert zu
        haben, falls welche existieren. Beachte, falls das Video telecined
        ist, stelle sicher, dass der <option>pullup</option>-Filter (oder für
        welchen umgekehrten telecine-Filter auch immer du dich entschieden hast)
        in der Filterkette auftaucht, bevor du zuschneidest. Ist es interlaced,
        deinterlace es vor dem Zuschneiden.
        (Wenn du dich entscheidest, interlaced Video beizubehalten, dann vergewissere dich, dass
        das vertikale crop-Offset ein Vielfaches von 4 ist.)
      </para>

      <para>
        Wenn du wirklich besorgt um den Verlust dieser 10 Pixel bist, ziehst du
        statt dessen etwa das Herunterskalieren der Abmessungen auf das am nächsten
        liegende Vielfache von 16 vor.
        Die Filterkette würde dann etwa so aussehen:

        <screen>-vf crop=720:362:0:58,scale=720:352</screen>

        Das Video auf diese Art herunter zu skalieren wird bedeuten, dass eine
        kleine Menge Details verloren geht, obwohl es vermutlich nicht wahrnehmbar
        sein wird. Hoch zu skalieren führt zu niedrigerer Qualität (es sei denn,
        du erhöhst die Bitrate). Ausschneiden sondert sämtliche dieser Pixel
        aus. Es ist ein Kompromiss, den du unter allen Umständen
        in Betracht ziehen solltest. Zum Beispiel, wenn das DVD-Video für das Fernsehen
        hergestellt wurde, solltest du vertikales Skalieren vermeiden, da das
        Zeilensampling mit der Art und Weise korrespondiert, für die der Inhalt
        ursprünglich aufgenommen wurde.
      </para>

      <para>
        Bei der Überprüfung sehen wir, dass unser Film ordentlich Action enthält
        und sehr viele Details, also wählen wir 2400Kbit für unsere Bitrate.
      </para>

      <para>
        Wir sind nun bereit, die 2-pass Encodierung durchzuführen. Erster Durchlauf:

<screen>mencoder dvd://1 -ofps 24000/1001 -oac copy -vf pullup,softskip,crop=720:352:0:62,hqdn3d=2:1:2 -ovc lavc \
  -lavcopts vcodec=mpeg4:vbitrate=2400:v4mv:mbd=2:trell:cmp=3:subcmp=3:mbcmp=3:autoaspect:vpass=1 \
  -o Harry_Potter_2.avi</screen>

        Und der zweite Durchlauf ist derselbe, außer dass wir <option>vpass=2</option>
        festlegen:

<screen>mencoder dvd://1 -ofps 24000/1001 -oac copy -vf pullup,softskip,crop=720:352:0:62,hqdn3d=2:1:2 -ovc lavc \
  -lavcopts vcodec=mpeg4:vbitrate=2400:v4mv:mbd=2:trell:cmp=3:subcmp=3:mbcmp=3:autoaspect:vpass=2 \
  -o Harry_Potter_2.avi</screen>
      </para>

      <para>
        Die Optionen <option>v4mv:mbd=2:trell</option> werden die Qualität
        außerordentlich erhöhen, auf Kosten der Encodierdauer. Es gibt
        einen kleinen Grund, diese Optionen auszulassen, wenn das Primärziel
        die Qualität ist. Die Optionen
        <option>cmp=3:subcmp=3:mbcmp=3</option> wählen eine Vergleichsfunktion,
        die eine höhere Qualität liefert als die Standardeinstellungen.
        Du darfst mit diesem Parameter rumexperimentieren (ziehe die Manpage
        zu möglichen Werten zu Rate) da verschiedene Funktionen abhängig vom
        Quellmaterial einen starken Einfluss auf die Qualität haben. Wenn du zum Beispiel
        meinst, dass <systemitem class="library">libavcodec</systemitem> zu
        viele Blockartefakte produziert, könntest du ja das experimentelle
        NSSE als Vergleichsfunktion via <option>*cmp=10</option> wählen.
      </para>

      <para>
        Für diesen Film wird das resultierende AVI 138 Minuten lang und nahezu
        3GB groß sein. Und weil du erzählt hast, dass eine große Datei nichts
        ausmacht, ist dies eine perfekt akzeptierbare Größe. Wolltest du sie aber
        kleiner haben, könntest du eine niedrigere Bitrate hernehmen. Erhöhte
        Bitraten haben verminderte Rückgaben, während wir also deutlich eine
        Verbesserung von 1800Kbit nach 2000Kbit sehen, ist es oberhalb 2000Kbit
        nicht so auffällig. Fühl dich frei solange herum zu experimentieren bis
        du glücklich bist.
      </para>

      <para>
        Weil wir das Quellvideo durch einen Denoise-Filter geschickt haben,
        könntest du einige davon während des Playbacks wieder hinzufügen wollen.
        Dies zusammen mit dem Nachbearbeitungsfilter <option>spp</option>
        verbessert die Wahrnehmung der Qualität drastisch und hilft dabei,
        blockhafte Artefakte aus dem Video zu eliminieren.
        Mit <application>MPlayer</application>s Option <option>autoq</option>
        kannst du den Nachbearbeitungsaufwand des spp-Filters abhängig von der
        verfügbaren CPU variieren. An dieser Stelle kannst du auch Gamma- und/oder
        Farbkorrektur zur besten Anpassung an dein Display verwenden, wenn du willst.
        Zum Beispiel:

        <screen>mplayer Harry_Potter_2.avi -vf spp,noise=9ah:5ah,eq2=1.2 -autoq 3</screen>
      </para>

    </sect2>
  </sect1>


  <sect1 id="menc-feat-xvid">
    <title>Encodieren mit dem <systemitem class="library">Xvid</systemitem>-Codec</title>

    <para>
      <systemitem class="library">Xvid</systemitem> ist eine freie
      Programmbibliothek zum Encodieren von MPEG-4 ASP-Videostreams.
      Bevor du mit <link linkend="xvid"> zu encodieren beginnst, musst du
        <application>MEncoder</application> so einstellen, dass er es unterstützt</link>.
    </para>

    <para>
      Dieses Handbuch beabsichtigt, sich vorwiegend durch dieselbe Art von
      Informationen auszuzeichnen wie x264's Encodier-Handbuch.
      Beginne deshalb damit,
      <link linkend="menc-feat-x264-encoding-options-intro">den ersten Teil</link>
      dieses Handbuchs zu lesen.
    </para>


    <sect2 id="menc-feat-xvid-intro">
      <title>Welche Optionen sollte ich verwenden, um die besten Resultate zu erzielen?</title>

      <para>
        Bitte beginne mit der Durchsicht der
        <systemitem class="library">Xvid</systemitem>-Sektion von
        <application>MPlayer</application>s Manpage.
        Diese Sektion ist als Ergänzung zur Manpage zu verstehen.
      </para>

      <para>
        Die Standardeinstellungen von Xvid sind bereits ein guter Kompromiss zwischen
        Geschwindigkeit und Qualität, deshalb kannst du ruhig bei ihnen
        bleiben, wenn nachfolgender Abschnitt dich allzusehr ins Grübeln bringt.
      </para>
    </sect2>

    <sect2 id="menc-feat-xvid-encoding-options">
      <title>Encodieroptionen von <systemitem class="library">Xvid</systemitem></title>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">vhq</emphasis>
            Diese Einstellung betreffen den Entscheidungsalgorithmus für
            Macroblöcke, wobei gilt, je höher die Einstellung desto weiser die
            Entscheidung.
            Die Standardeinstellung kann für jede Encodierung sicher verwendet
            werden, während höhere Einstellungen immer für PSNR hilfreich, jedoch
            signifikant langsamer sind.
            Nimm bitte zur Kenntnis, dass ein besserer PSNR nicht notwedigerweise
            bedeutet, dass das Bild besser aussehen wird, aber er zeigt dir, dass
            du näher am Original bist.
            Wird er deaktiviert, beschleunigt dies die Encodierung spürbar; wenn
            Geschwindigkeit ein Kriterium für dich ist, kann dieser Kompromiss es wert sein.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">bvhq</emphasis>
            Dies erledigt dieselbe Arbeit wie vhq, macht dies jedoch bei B-Frames.
            Es hat einen vernachlässigbar kleinen Einfluss auf die Geschwindigkeit, und
            verbessert geringfügig die Qualität (um etwa +0.1dB PSNR).
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">max_bframes</emphasis>
            Eine höhere Anzahl von erlaubten hintereinander folgenden B-frames verbessert
            gewöhnlich die Komprimierbarkeit, obwohl dies auch zu mehr Blockartefakten
            führt.
            Die Standardeinstellung ist ein guter Kompromiss zwischen Komprimierbarkeit
            und Qualität, aber wenn du Bitraten-hungrig bist kannst du sie bis auf 3
            hochschrauben.
            Du kannst sie auch auf 1 oder 0 verringern, wenn du auf perfekte Qualität
            abzielst, wenngleich du in diesem Fall sicherstellen solltest, dass deine
            Zielbitrate hoch genug ist, um zu gewährleisten, dass der Encoder nicht
            die Quantisierer höher setzen muss, um den Wert zu erreichen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">bf_threshold</emphasis>
            Dies kontrolliert die B-Frame-Empfindlichkeit des Encoders, wobei ein
            höherer Wert dazu führt, dass mehr B-Frames angewendet werden (und
            umgekehrt).
            Diese Einstellung muss zusammen mit <option>max_bframes</option>
            verwendet werden; bist du Bitraten-hungrig, solltest du beides erhöhen,
            <option>max_bframes</option> und <option>bf_threshold</option>,
            während du <option>max_bframes</option> erhöhen und
            <option>bf_threshold</option> verringern kannst, sodass der Encoder
            B-Frames nur an Stellen anwendet, die diese auch
            <emphasis role="bold">wirklich</emphasis> brauchen.
            Eine niedrigere Zahl an <option>max_bframes</option> und ein höherer Wert
            bei <option>bf_threshold</option> ist möglicherweise keine kluge Wahl,
            da dies den Encoder zwingt, B-Frames in Stellen zu setzen, die nicht
            davon profitieren würden und dies daher die visuelle Qualität reduziert.
            Wie auch immer, wenn du mit Standalone-Playern kompatibel bleiben musst,
            die nur alte DivX-Profile unterstützen (der wiederum höchstens einen
            aufeinander folgenden B-Frame unterstützt), wäre dies dein einziger Weg,
            die Komprimierbarkeit mittels B-Frames zu verbessern.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">trellis</emphasis>
            Optimiert den Quantisierungsprozess um einen optimalen Kompromiss
            zwischen PSNR und Bitrate zu erhalten, was signifikant Bit-sparend
            wirkt.
            Diese Bits können woanders im Video wieder verwendet werden
            und verbessern die visuelle Gesamtqualität.
            Du solltest es immer eingeschaltet lassen, da sein Einfluss auf
            die Qualität gewaltig ist.
            Gerade wenn du Geschwindigkeit haben willst, darfst du es nicht
            deaktivieren, solange du nicht <option>vhq</option>
            und alle anderen CPU-hungrigeren Optionen auf
            ein Minimum heruntergesetzt hast.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">hq_ac</emphasis>
            Aktiviert die Vorhersagemethode für einen besseren Koeffizientenaufwand, was
            die Dateigröße leicht um etwa 0.15 bis 0.19% reduziert (was mit einer
            PSNR-Erhöhung um weniger als 0.01dB einhergeht), während es eine
            vernachlässigbar kleine Einwirkung auf die Geschwindigkeit hat.
            Es empfiehlt sich deshalb, dies immer eingeschaltet zu lassen.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">cartoon</emphasis>
            Entworfen, um Kartoon-Inhalt besser zu encodieren, und hat keine Auswirkung
            auf die Geschwindigkeit, da es lediglich die Heuristiken zur Bestimmung des
            Modus für diese Art Inhalt abstimmt.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">me_quality</emphasis>
            Diese Einstellung ist da, um die Präzision der Bewegungseinschätzung zu
            kontrollieren.
            Je höher <option>me_quality</option>, desto präziser wird die Schätzung
            der Originalbewegung sein, und desto besser wird der resultierende Ausschnitt
            die Originalbewegung einfangen.
          </para>

          <para>
            Die Standardeinstellung ist in jedem Fall die beste;
            folglich ist es nicht empfehlenswert, sie herunter zu drehen,
            es sei denn du hast es wirklich auf Geschwindigkeit abgesehen,
            da alle durch eine gute Bewegungseinschätzung gesparten Bits
            woanders verwendet würden, was die Gesamtqualität verbessern
            würde.
            Gehe deshalb nie unter 5, selbst wenn es der letzte Ausweg
            sein sollte.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">chroma_me</emphasis>
            Verbessert die Bewegungsabschätzung dadurch, dass auch die
            chroma-(Farb)-Informationen einbezogen werden, wobei
            <option>me_quality</option> alleine nur luma (Graustufen)
            verwendet.
            Dies verlangsamt die Encodierung um 5-10%, verbessert aber die
            visuelle Qualität durch Reduzieren von Blockeffekten ein wenig
            und reduziert die Dateigröße um rund 1.3%.
            Wenn du Geschwindigkeit haben willst, solltest du diese Option
            deaktivieren, bevor du anfängst zu überlegen,
            <option>me_quality</option> zu reduzieren.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">chroma_opt</emphasis>
            Ist dafür vorgesehen, die chroma-Bildqualität rund um reine
            weiße/schwarze Kanten zu verbessern, eher noch als die
            Kompression zu verbessern.
            Dies kann dabei helfen, den "Rote Stufen"-Effekt zu reduzieren.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">lumi_mask</emphasis>
            Versucht, weniger Bitrate auf den Teil eines Bildes zu übergeben,
            der vom menschlichen Auge nicht gut zu sehen ist, was dem Encoder
            erlauben sollte, die eingesparten Bits auf wichtigere Teile des
            Bildes anzuwenden.
            Die durch diese Option gewonnene Encodierungsqualität hängt in
            hohem Maße von persönlichen Vorlieben und von Monitortyp und
            dessen Einstellungen ab (typischerweise wird es nicht gut aussehen,
            wenn er hell oder ein TFT-Monitor ist).
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">qpel</emphasis>
            Hebt die Anzahl Kandidaten der Bewegungsvektoren durch
            Erhöhung der Präzision der Bewegungsabschätzung von einem
            halben Pixel (halfpel) auf ein viertel Pixel
            (quarterpel) an.
            Die Idee dahinter ist, bessere Bewegungsvektoren zu finden,
            was wiederum die Bitrate reduziert (deshalb wird die Qualität
            verbessert).
            Bewegungsvektoren mit viertel Pixel Präzision brauchen ein
            paar Extrabits für die Codierung, die Bewegungsvektoren ergeben aber
            nicht immer ein (viel) besseres Resultat.
            Sehr oft verbraucht der Codec dennoch Bits für die Extrapräzision,
            jedoch wird im Gegenzug eine geringe oder keine Extraqualität
            gewonnen.
            Unglücklicherweise gibt es keinen Weg, den möglichen Gewinn von
            <option>qpel</option> vorzuaussagen, also musst du eigentlich
            mit und ohne encodieren, um sicher zu gehen.
          </para>
          <para>
            <option>qpel</option> kann fast die doppelte Encodierzeit in
            Anspruch nehmen und erfordert etwa 25% mehr
            Verarbeitungsleistung fürs Decodieren.
            Es wird nicht von allen Standalone-Playern unterstützt.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis role="bold">gmc</emphasis>
            Versucht, Bits beim Schwenken von Szenen einzusparen, indem es einen
            einzelnen Bewegungsvektor für den gesamten Frame verwendet.
            Dies erhöht fast immer den PSNR, verlangsamt aber signifikant
            die Encodierung (genauso wie die Decodierung).
            Deshalb solltest du es nur nutzen, wenn du <option>vhq</option>
            auf das Maximum gestellt hast.
            <systemitem class="library">Xvid</systemitem>s GMC ist höher
            entwickelt als das von DivX, wird aber nur von ein paar
            Standalone-Playern unterstützt.
          </para>
        </listitem>

      </itemizedlist>
    </sect2>

    <sect2 id="menc-feat-xvid-encoding-profiles">
      <title>Encodierung Profile</title>
      <para>
        Xvid unterstützt Encodierungsprofile über die Option <option>profile</option>,
        die dazu verwendet werden, den Eigenschaften des Xvid-Videostreams
        Restriktionen so aufzuerlegen, dass es überall dort abgespielt werden kann,
        wo das gewählte Profil unterstützt wird.
        Die Restriktionen beziehen sich auf Auflösungen, Bitraten und
        bestimmte MPEG-4-Features.
        Die folgende Tabelle zeigt, was jedes Profil unterstützt.
      </para>
      <informaltable>
        <tgroup cols="16" align="center">
          <colspec colnum="1"  colname="col1"/>
          <colspec colnum="2"  colname="col2"/>
          <colspec colnum="3"  colname="col3"/>
          <colspec colnum="4"  colname="col4"/>
          <colspec colnum="5"  colname="col5"/>
          <colspec colnum="6"  colname="col6"/>
          <colspec colnum="7"  colname="col7"/>
          <colspec colnum="8"  colname="col8"/>
          <colspec colnum="9"  colname="col9"/>
          <colspec colnum="10" colname="col10"/>
          <colspec colnum="11" colname="col11"/>
          <colspec colnum="12" colname="col12"/>
          <colspec colnum="13" colname="col13"/>
          <colspec colnum="14" colname="col14"/>
          <colspec colnum="15" colname="col15"/>
          <colspec colnum="16" colname="col16"/>
          <colspec colnum="17" colname="col17"/>
          <spanspec spanname="spa2-5"   namest="col2" nameend="col5"/>
          <spanspec spanname="spa6-11"  namest="col6" nameend="col11"/>
          <spanspec spanname="spa12-17" namest="col12" nameend="col17"/>
          <tbody>
            <row>
              <entry></entry>
              <entry spanname="spa2-5">Einfach</entry>
              <entry spanname="spa6-11">Einfach erweitert</entry>
              <entry spanname="spa12-17">DivX</entry>
            </row>
            <row>
              <entry>Profilname</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>2</entry>
              <entry>3</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>2</entry>
              <entry>3</entry>
              <entry>4</entry>
              <entry>5</entry>
              <entry>Handheld</entry>
              <entry>Portable NTSC</entry>
              <entry>Portable PAL</entry>
              <entry>Home Theater NTSC</entry>
              <entry>Home Theater PAL</entry>
              <entry>HDTV</entry>
            </row>
            <row>
              <entry>Breite [Pixel]</entry>
              <entry>176</entry>
              <entry>176</entry>
              <entry>352</entry>
              <entry>352</entry>
              <entry>176</entry>
              <entry>176</entry>
              <entry>352</entry>
              <entry>352</entry>
              <entry>352</entry>
              <entry>720</entry>
              <entry>176</entry>
              <entry>352</entry>
              <entry>352</entry>
              <entry>720</entry>
              <entry>720</entry>
              <entry>1280</entry>
            </row>
            <row>
              <entry>Höhe [Pixel]</entry>
              <entry>144</entry>
              <entry>144</entry>
              <entry>288</entry>
              <entry>288</entry>
              <entry>144</entry>
              <entry>144</entry>
              <entry>288</entry>
              <entry>288</entry>
              <entry>576</entry>
              <entry>576</entry>
              <entry>144</entry>
              <entry>240</entry>
              <entry>288</entry>
              <entry>480</entry>
              <entry>576</entry>
              <entry>720</entry>
            </row>
            <row>
              <entry>Framerate [fps]</entry>
              <entry>15</entry>
              <entry>15</entry>
              <entry>15</entry>
              <entry>15</entry>
              <entry>30</entry>
              <entry>30</entry>
              <entry>15</entry>
              <entry>30</entry>
              <entry>30</entry>
              <entry>30</entry>
              <entry>15</entry>
              <entry>30</entry>
              <entry>25</entry>
              <entry>30</entry>
              <entry>25</entry>
              <entry>30</entry>
            </row>
            <row>
              <entry>Max. mittlere Bitrate [kbps]</entry>
              <entry>64</entry>
              <entry>64</entry>
              <entry>128</entry>
              <entry>384</entry>
              <entry>128</entry>
              <entry>128</entry>
              <entry>384</entry>
              <entry>768</entry>
              <entry>3000</entry>
              <entry>8000</entry>
              <entry>537.6</entry>
              <entry>4854</entry>
              <entry>4854</entry>
              <entry>4854</entry>
              <entry>4854</entry>
              <entry>9708.4</entry>
            </row>
            <row>
              <entry>Höchstwert mittlere Bitrate über 3 Sek. [kbps]</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>800</entry>
              <entry>8000</entry>
              <entry>8000</entry>
              <entry>8000</entry>
              <entry>8000</entry>
              <entry>16000</entry>
            </row>
            <row>
              <entry>Max. B-Frames</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry>MPEG-Quantisierung</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Adaptive Quantisierung</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
            </row>
            <row>
              <entry>Interlaced Encodierung</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
            </row>
            <row>
              <entry>Viertelpixel</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Globale Bewegungskompensierung</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry>X</entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="menc-feat-xvid-example-settings">
      <title>Encodierungseinstellungen Beispiele</title>

      <para>
        Die folgenden Einstellungen sind Beispiele unterschiedlicher
        Kombinationen von Encodierungsoptionen, die den Kompromiss
        zwischen Geschwindigkeit gegenüber Qualität bei gleicher
        Zielbitrate betreffen.
      </para>

      <para>
        Alle Encodierungseinstellungen wurden auf einem Beispielvideo
        mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps,
        und der Rechner war ein
        AMD-64 3400+ mit 2400 MHz im 64bit-Modus.
        Jede Encodierungseinstellung zeichnet sich aus durch die gemessene
        Encodiergeschwindigkeit (in Frames pro Sekunde) und den PSNR-Verlust
        (in dB) im Vergleich zu Einstellungen für "sehr hohe Qualität".
        Bitte hab Verständnis, dass du abhängig von deiner Quelldatei,
        deinem Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche
        Resultate erzielen wirst.
      </para>

      <para>
        <informaltable frame="all">
          <tgroup cols="4">
            <thead>
              <row><entry>Beschreibung</entry><entry>Encodieroptionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
            </thead>
            <tbody>
              <row>
                <entry>Sehr hohe Qualität</entry>
                <entry><option>chroma_opt:vhq=4:bvhq=1:quant_type=mpeg</option></entry>
                <entry>16fps</entry>
                <entry>0dB</entry>
              </row>
              <row>
                <entry>Hohe Qualität</entry>
                <entry><option>vhq=2:bvhq=1:chroma_opt:quant_type=mpeg</option></entry>
                <entry>18fps</entry>
                <entry>-0.1dB</entry>
              </row>
              <row>
                <entry>Schnell</entry>
                <entry><option>turbo:vhq=0</option></entry>
                <entry>28fps</entry>
                <entry>-0.69dB</entry>
              </row>
              <row>
                <entry>Echtzeit</entry>
                <entry><option>turbo:nochroma_me:notrellis:max_bframes=0:vhq=0</option></entry>
                <entry>38fps</entry>
                <entry>-1.48dB</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </sect2>

  </sect1>

  <sect1 id="menc-feat-x264">
    <title>Encodieren mit dem <systemitem class="library">x264</systemitem>-Codec</title>
    <para>
      <systemitem class="library">x264</systemitem> ist eine freie
      Programmbibliothek zum Encodieren von H.264/AVC-Videostreams.
      Bevor du mit <link linkend="xvid"> zu encodieren beginnst, musst
      du <application>MEncoder</application> so einstellen, dass er es unterstützt</link>.
    </para>

    <sect2 id="menc-feat-x264-encoding-options">
      <title>Encodieroptionen von x264</title>

      <para>
        Bitte beginne mit der Durchsicht der
        <systemitem class="library">x264</systemitem>-Sektion von
        <application>MPlayer</application>s Manpage.
        Diese Sektion ist als Anhang zur Manpage vorgesehen.
        Hier wirst du Schnellhinweise dazu finden, welche Optionen am
        wahrscheinlichsten die meisten Leute interessieren. Die Manpage
        ist knapper gehalten, aber auch vollständiger, und zeigt oft
        viel bessere technische Details.
      </para>

      <sect3 id="menc-feat-x264-encoding-options-intro">
        <title>Einführung</title>
        <para>Dieses Handbuch berücksichtigt zwei Hauptkategorien der Encodieroptionen:</para>

        <orderedlist>
          <listitem>
            <para>
              Optionen, die hauptsächlich Encodierdauer gegenüber Qualität abwägen
            </para>
          </listitem>
          <listitem>
            <para>
              Optionen, die zur Erfüllung zahlreicher persönlicher Vorlieben und spezieller Anforderungen nützlich sind
            </para>
          </listitem>
        </orderedlist>

        <para>
          Letztendlich kannst nur du entscheiden, welche Optionen für deine
          Zwecke am besten geeignet sind. Die Entscheidung für die erste
          Klasse der Optionen ist die einfachste:
          Du musst nur entscheiden, ob du denkst, dass Qualitätsunterschiede
          Geschwindigkeitsunterschiede rechtfertigen. Für die zweite Klasse
          der Optionen sind die Vorzüge weitaus subjektiver, und mehr Faktoren
          können involviert sein. Beachte, dass manche der Optionen für
          "persönliche Vorlieben und spezielle Anforderungen"
          noch große Auswirkungen auf Geschwindigkeit oder Qualität haben können,
          das ist aber nicht, wozu sie primär benutzt werden. Ein paar der
          Optionen für "persönliche Vorlieben" können sogar Änderungen
          verursachen, die für manche Leute besser aussehen aber schlechter
          für andere.
        </para>

        <para>
          Bevor du fortfährst, musst du verstehen, dass dieses Handbuch nur
          eine Qualitätsmetrik verwendet: globaler PSNR.
          Für eine kurze Erklärung, was PSNR ist, schau dir
          <ulink url="http://en.wikipedia.org/wiki/PSNR">den Wikipedia-Artikel zu PSNR</ulink>
          an.
          Globaler PSNR ist die letzte gemeldete PSNR-Nummer, wenn du die
          Option <option>psnr</option> in <option>x264encopts</option>
          einbindest.
          Jedesmal wenn du eine Forderung nach PSNR liest, ist eine der Annahmen
          hinter dieser Forderung, dass gleiche Bitraten verwendet werden.
        </para>

        <para>
          Nahezu alle dieser Handbuchkommentare unterstellen, dass du
          2-pass anwendest.
          Beim Vergleich der Optionen gibt es zwei Hauptgründe, 2-pass-Encodierung
          zu nutzen.
          Der erste ist, 2-pass bringt rund 1dB PSNR, was einen sehr
          großen Unterschied ausmacht.
          Der zweite ist, Optionen zu testen, indem man direkte Qualitätsvergleiche
          zu 1-pass-Encodierung anstellt, führt einen einen wichtigen verwirrenden
          Faktor ein: die Bitrate variiert bei jeder Encodierung oft signifikant.
          Es ist nicht immer einfach zu sagen, ob Qualitätsänderungen vorwiegend
          auf geänderte Optionen zurückzuführen sind oder ob sie meist
          essentielle, zufällige Unterschiede in der erhaltenen Bitrate reflektieren.
        </para>

      </sect3>

      <sect3 id="menc-feat-x264-encoding-options-speedvquality">
        <title>Optionen, die primär Geschwindigkeit und Qualität betreffen</title>

        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="bold">subq</emphasis>:
              Von den Optionen, die dir erlauben, einen Kompromiss zwischen
              Geschwindigkeit und Qualität einzugehen, sind <option>subq</option>
              und <option>frameref</option> (siehe unten) gewöhnlich die bei weitem
              wichtigsten.
              Wenn du dich für die Optimierung von entweder Geschwindigkeit oder Qualität
              interessierst, sind diese die ersten, die du in Erwägung ziehen solltest.
              Bei der Dimension Geschwindigkeit, interagieren die Optionen
              <option>frameref</option> und <option>subq</option> ziemlich stark
              miteinander.
              Die Erfahrung zeigt, dass mit einem Referenzframe <option>subq=5</option>
              (die Standardeinstellung) das ganze etwa 35% mehr Zeit in Anspruch nimmt als
              <option>subq=1</option>.
              Mit 6 Referenzframes wächst der Nachteil auf 60%.
              Der Effekt, den <option>subq</option> auf den PSNR ausübt, scheint ziemlich
              konstant zu sein, ungeachtet der Anzahl der Referenzframes.
              Typischerweise erreicht <option>subq=5</option> einen 0.2-0.5 dB höheren globalen
              PSNR im Vergleich zu <option>subq=1</option>.
              Dies ist gewöhnlich ausreichend, um sichtbar zu werden.
            </para>
            <para>
              <option>subq=6</option> ist langsamer und führt bei erträglichen Kosten zu besserer
              Qualität.
              Im Vergleich zu <option>subq=5</option> gewinnt sie gewöhnlich 0.1-0.4 dB
              globalen PSNR mit Geschwindigkeitseinbußen, die sich zwischen 25%-100%
              bewegen.
              Im Unterschied zu anderen Levels von <option>subq</option> hängt das
              Verhalten von <option>subq=6</option> nicht sehr von <option>frameref</option>
              und <option>me</option> ab.  Statt dessen hängt die Effektivität von
              <option>subq=6</option> größtenteils von der Anzahl der verwendeten
              B-Frames ab. Im Normalgebrauch bedeutet dies, <option>subq=6</option>
              hat einen großen Einfluss auf Geschwindigkeit und Qualität
              in komplexen, stark bewegten Szenen, kann aber auch einen geringen Effekt
              in Szenen mit wenig Bewegung haben. Beachte, dass dennoch empfohlen wird,
              <option>bframes</option> immer auf etwas anderes als null
              zu setzen (siehe unten).
            </para>
             <para>
               <option>subq=7</option> ist der langsamste Modus mit der höchsten Qualität.
               Im Vergleich zu <option>subq=6</option> erreicht er normalerweise zwischen 0.01-0.05 dB
               Zuwachs des globalen PSNR bei Geschwindigkeitseinbußen variierend von 15%-33%.
               Da der Kompromiss zwischen Zeit gegenüber Qualität recht gering ist, solltest
               du ihn nur benutzen, wenn du jedes mögliche Bit einsparen möchtest und
               Encodierzeit keine Rolle spielt.
             </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">frameref</emphasis>:
              <option>frameref</option> ist per Voreinstellung auf 1 gesetzt, jedoch
              solltest du deshalb nicht darauf schließen, dass es unbedingt
              auf 1 gesetzt sein muss.
              Allein die Erhöhung von <option>frameref</option> auf 2 bringt rund
              0.15dB PSNR mit einem Geschwindigkeitsnachteil von 5-10%; dies sieht nach
              einem guten Kompromiss aus.
              <option>frameref=3</option> bringt rund 0.25dB PSNR mehr als
              <option>frameref=1</option>, was einen sichtbaren Unterschied machen
              sollte.
              <option>frameref=3</option> ist rund 15% langsamer als
              <option>frameref=1</option>.
              Leider setzen vermindernde Rückgaben schnell ein.
              <option>frameref=6</option> kann erwartungsgemäß nur
              0.05-0.1 dB mehr als <option>frameref=3</option> bei zusätzlichen
              15% Geschwindigkeitsnachteil.
              Oberhalb <option>frameref=6</option> sind die Qualitätsgewinne
              für gewöhnlich sehr klein (obwohl du während der ganzen Diskussion
              im Kopf behalten solltest, dass sie abhängig von deiner Quelle stark
              variieren können).
              In einem ziemlich typischen Fall wird <option>frameref=12</option>
              den globalen PSNR um ein bisschen mehr als 0.02dB gegenüber
              <option>frameref=6</option> verbessern, bei Geschwindigkeitseinbußen
              von 15%-20%.
              Bei so hohen <option>frameref</option>-Werten ist das wirklich
              einzig Gute, dass man sagen kann, dass ein weiteres Anheben dieses
              Wertes ziemlich sicher nie den PSNR <emphasis role="bold">schädigen</emphasis>
              wird, jedoch sind zusätzliche Qualitätsvorteile sogar kaum messbar,
              geschweige denn wahrnehmbar.
            </para>
            <note><title>Beachte:</title>
              <para>
                Das Erhöhen von <option>frameref</option> auf unnötig hohe Werte
                <emphasis role="bold">kann</emphasis> und
                <emphasis role="bold">tut dies üblicherweise auch</emphasis>
                die Codiereffizienz schädigen, wenn du CABAC ausschaltest.
                Mit eingeschaltetem CABAC (das Standardverhalten) scheint die
                Möglichkeit, <option>frameref</option> "zu hoch"
                zu setzen, gegenwärtig zu weit entfernt um sich Sorgen zu machen,
                und in der Zukunft werden womöglich Optimierungen diese Möglichkeit
                ganz und gar ausschließen.
              </para>
            </note>
            <para>
              Wenn du auf Geschwindigkeit abzielst, ist ein vernünftiger
              Kompromiss, im ersten Durchgang niedrigere <option>subq</option>- und
              <option>frameref</option>-Werte zu nehmen, und sie danach im
              zweten Durchgang zu erhöhen.
              Typischerweise hat dies einen vernachlässigbar negativen Effekt
              auf die Encodierqualität: Du wirst womöglich unter 0.1dB PSNR
              verlieren, was viel zu klein für einen sichtbaren Unterschied
              sein sollte.
              Trotzdem, unterschiedliche Werte für <option>frameref</option>
              können auf verschiedene Weise die Frametypenbestimmung beeinflussen.
              Höchstwahrscheinlich sind dies außerordentlich seltene Fälle,
              willst du jedoch wirklich sicher gehen, ziehe in Betracht, ob
              dein Video entweder Vollbild- respektive Einblendungsmuster
              oder sehr große temporäre Überdeckungen enthält, was einen I-Frame
              erzwingen könnte.
              Passe <option>frameref</option> des ersten Durchgangs so an,
              dass es groß genug ist, die Dauer des Einblendungszyklus
              (oder der Überdeckungen) zu enthalten.
              Zum Beispiel, wenn die Szene zwischen zwei Bildern über eine
              Zeitspanne von drei Frames rückwärts und vorwärts springt,
              setze <option>frameref</option> des ersten Durchgangs auf 3
              oder höher.
              Dieser Sachverhalt kommt vermutlich extrem selten in
              Videomaterial mit Live Action vor, erscheint aber manchmal
              bei eingefangenen Computerspiel-Sequenzen.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">me</emphasis>:
              Diese Option dient der Wahl der Suchmethode der Bewegungseinschätzung.
              Diese Option zu verändern stellt einen überschaubaren Kompromiss
              zwischen Qualität und Geschwindigkeit dar.
              <option>me=dia</option> ist nur ein paar Prozent schneller als
              die Standardsuche, auf Kosten von unter 0.1dB globalem PSNR. Die
              Standardeinstellung (<option>me=hex</option>) ist ein angemessener
              Kompromiss zwischen Qualität und Geschwindigkeit.
              <option>me=umh</option> bringt ein wenig unter 0.1dB globalem PSNR,
              mit Geschwindigkeitsnachteil, der abhängig von <option>frameref</option>
              variiert. Bei hohen <option>frameref</option>-Werten (z.B. 12 oder so)
              ist <option>me=umh</option> etwa 40% langsamer als die Standardeinstellung
              <option>me=hex</option>. Mit <option>frameref=3</option> fällt der
              Geschwindigkeitsnachteil auf 25%-30%.
            </para>
            <para>
              <option>me=esa</option> verwendet eine gründliche, für die praktische
              Anwendung zu langsame Suche.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">partitions=all</emphasis>:
              Diese Option aktiviert die Verwendung von 8x4, 4x8 und 4x4 Unterteilungen
              in den vorhergesagten Macroblöcken (zusätzlich zu den Standardunterteilungen).
              Sie zu aktivieren führt zu einem
              recht beständigen Geschwindigkeitsverlust von 10%-15%. Sie ist
              ziemlich nutzlos bei Quellen, die nur langsame Bewegungen enthalten,
              obwohl in manchen Quellen mit sehr viel Bewegung und vielen kleinen,
              sich bewegenden Objekten Zugewinne von etwa 0.1dB erwartet werden können.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">bframes</emphasis>:
              Wenn du gewohnt bist, mit anderen Codecs zu encodieren, hast du
              womöglich empfunden, dass B-Frames nicht immer nützlich sind.
              Bei H.264 wurde dies geändert: es gibt neue Techniken und Blocktypen,
              die in B-Frames möglich sind.
              Für gewöhnlich kann selbst ein einfältiger Algorithmus zur Wahl
              der B-Frames einen signifikanten PSNR-Vorteil bringen.
              Es ist interessant festzustellen, dass die Anwendung von B-Frames
              normalerweise den zweiten Durchgang ein bisschen beschleunigt,
              und er kann auch eine Encodierung mit einfachem Durchgang etwas
              schneller machen, wenn adaptive B-Frame-Bestimmung deaktiviert
              ist.
            </para>
            <para>
              Mit deaktivierter adaptiver B-Framebestimmung
              (<option>nob_adapt</option> von <option>x264encopts</option>)
              ist der optimale Wert für diese Einstellung normalerweise nicht
              mehr als <option>bframes=1</option>, andernfalls leiden Szenen
              mit sehr viel Bewegung darunter.
              Mit aktivierter adaptiver B-Framebestimmung (das Standardverhalten)
              ist es sicher, höhere Werte zu verwenden; der Encoder wird die Anwendung
              von B-Frames in Szenen reduzieren, in denen sie die Kompression
              schädigen könnten.
              Der Encoder zieht es selten vor, mehr als 3 oder 4 B-Frames zu
              verwenden; diese Option höher zu setzen wird einen geringen Effekt haben.
            </para></listitem>

          <listitem>
            <para>
              <emphasis role="bold">b_adapt</emphasis>:
              Beachte: Dies ist standardmäßig eingeschaltet.
            </para>
            <para>
              Ist diese Option aktiviert, wird der Encoder einen einigermaßen schnellen
              Entscheidungsprozess zur Reduzierung der Anzahl B-Frames in Szenen anwenden, die
              nicht viel von ihnen profitieren würden.
              Du kannst <option>b_bias</option> dazu verwenden, zu optimieren wie
              froh der Encoder über B-Frames sein soll.
              Der Geschwindigkeitsnachteil adaptiver B-Frames ist gegenwärtig ziemlich
              bescheiden, und genauso ist der potentielle Qualitätsgewinn.
              Es sollte aber normalerweise nicht schaden.
              Beachte, dass dies nur Geschwindigkeit und Frametypenbestimmung im ersten
              Durchgang betrifft.
              <option>b_adapt</option> und <option>b_bias</option> haben keinen
              Effekt auf nachfolgende Durchgänge.
            </para>
          </listitem>

          <listitem><para>
              <emphasis role="bold">b_pyramid</emphasis>:
              Du kannst diese Option genauso gut aktivieren, falls du >=2 B-Frames
              verwendest; wie die Manpage dir sagt, erreichst du eine kleine
              Qualitätsverbesserung bei keinerlei Geschwindigkeitseinbuße.
              Beachte, dass diese Videos von libavcodec-basierten Decodern
              älter als etwa 5. März 2005 nicht gelesen werden können.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">weight_b</emphasis>:
              In typischen Fällen gibt es nicht viel Gewinn mit dieser Option.
              Trotzdem, in überblendenden oder ins Schwarze übergehenden Szenen
              liefert die gewichtete Vorhersage ziemlich große Einsparungen bei der Bitrate.
              In MPEG-4 ASP wird ein Übergang ins Schwarze gewöhnlich am besten
              als eine Serie aufwändiger I-Frames codiert; das Verwenden einer
              gewichteten Vorhersage in B-Frames macht es möglich, wenigstens
              manche von diesen in viel kleinere B-Frames zu wandeln.
              Der Verlust an Encodierzeit ist minimal, da keine extra Bestimmungen
              vorgenommen werden müssen.
              Auch werden die CPU-Anforderungen des Encoders, im Gegensatz zu den
              Einschätzungen mancher Leute, von gewichteter Vorhersage nicht sonderlich
              beeinflusst, ansonsten bleibt alles gleich.
            </para>
            <para>
              Leider hat der aktuelle Algorithmus zur adaptiven B-Frame-Bestimmung
              eine starke Tendenz, B-Frames während des Fadens zu verhindern.
              Bis sich dies ändert, kann es eine gute Idee sein,
              <option>nob_adapt</option> zu deinen x264encopts hinzuzufügen, falls
              du erwartest, dass Fades einen großen Effekt in deinem jeweiligen
              Videoclip erzeugen.
            </para>
          </listitem>
          <listitem id="menc-feat-x264-encoding-options-speedvquality-threads">
            <para>
              <emphasis role="bold">threads</emphasis>:
              Diese Option erlaubt es, mehrere Threads zu erstellen, um parallel auf mehreren
              CPUs zu encodieren. Du kannst die Anzahl der Threads manuell wählen oder,
              besser, setze <option>threads=auto</option> und lasse
              <systemitem class="library">x264</systemitem> erkennen, wie viele CPUs
              verfügbar sind, und die passende Anzahl Threads automatisch wählen.
              Wenn du eine Multi-Prozessor-Maschine hast, solltest du wirklich in Erwägung
              ziehen, dies zu benutzen, da es die Encodiergeschwindigkeit linear in
              der Anzahl der CPU-Kerne (ca. 94% pro CPU-Kern) erhöhen kann, bei sehr
              geringem Qualitätsverlust (ca. 0.005dB bei Dualprozessor, ca. 0.01dB bei
              einer Quad-Prozessor-Maschine).
            </para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 id="menc-feat-x264-encoding-options-misc-preferences">
        <title>Diverse Eigenschaften betreffende Optionen</title>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="bold">2-pass-Encodierung</emphasis>:
              Oben wurde vorgeschlagen, immer 2-pass-Encodierung anzuwenden.
              Es gibt aber durchaus Gründe, dies nicht zu tun. Beispielsweise bist du,
              wenn du Live-TV aufnimmst und in Echtzeit encodierst,
              gezwungen, einen einzigen Durchgang zu verwenden.
              Auch ist ein Durchgang offensichtlich schneller als zwei Durchgänge;
              wenn du exakt die gleichen Optionen bei beiden Durchgängen anwendest,
              ist das Encodieren in zwei Durchgängen mindestens zweimal so langsam.
            </para>
            <para>
              Noch gibt es sehr gute Gründe, in zwei Durchgängen zu encodieren.
              Zum einen ist Ratenkontrolle in einem Durchgang kein Allheilmittel.
              Sie trifft oft eine unvernünftige Auswahl, weil sie das große
              Bild nicht sehen kann. Zum Beispiel angenommen, du hast ein zwei Minuten
              langes Video bestehend aus zwei ausgeprägten Hälften.  Die erste Hälfte
              besitzt eine 60 Sekunden dauernde Szene mit sehr viel Bewegung, die
              einzeln für sich etwa 2500kbps benötigt, um anständig auszusehen.
              Direkt daruffolgend kommt eine viel weniger anspruchsvolle 60 Sekunden
              lange Szene, die bei 300kbps gut aussieht. Angenommen du forderst in
              der Theorie 1400kbps an, was beiden Szenen ausreichend entgegenkommen
              würde. Die Ratenkontrolle in einem Durchgang wird in diesem Fall
              ein paar "Fehler" machen. Zuallererst wird es in beiden Segmenten
              1400kbps anpeilen. Das erste Segment könnte schwer überquantisiert enden,
              was es unakzeptabel und unangemessen blockhaft aussehen lässt.
              Das zweite Segment wird schwer unterquantisiert sein; es sieht vielleicht
              perfekt aus, aber der Bitratenverlust dieser Perfektion wird komplett
              unangemessen sein.
              Noch schwerer vermeidbar ist das Problem am Übergang beider Szenen.
              Die ersten Sekunden der Hälfte mit wenig Bewegung wird enorm
              überquantisiert sein, weil die Ratenkontrolle noch die Art Anforderung
              an die Bitrate erwartet, der sie in der ersten Hälfte des Videos begegnet
              war. Diese "Fehlerperiode" der extrem überquantisierten Szene
              mit wenig Bewegung wird fürchterlich schlecht aussehen, und wird sogar
              weniger als die 300kbps in Anspruch nehmen als das, was sie genommen hätte, um annehmbar
              auszusehen. Es gibt Mittel und Wege, diese Fälle des Encodierens in einem
              Durchgang zu mildern, diese werden allerdingst dahin tendieren, die
              fehlerhaften Vorhersagen der Bitraten zu häufen.
            </para>
            <para>
              Multipass-Ratenkontrolle kann gegenüber der eines einzigen Durchgangs
              enorm große Vorteile bieten.
              Indem sie die im ersten Encodierungsdurchlauf gesammelte Statistik
              verwendet, kann der Encoder mit angemessener Genauigkeit den Aufwand
              (in Bit) abschätzen, den das Encodieren jeden gegebenen Frames bei
              jedem gegebenen Quantisierer erfordert. Dies erlaubt eine viel
              rationalere, besser geplante Zuweisung von Bits zwischen den
              bithungrigen Szenen mit viel Bewegung und denen bescheidenen mit
              wenig Bewegung.
              Siehe <option>qcomp</option> unten für einige Ideen darüber, wie man
              diese Zuweisungen nach seinem Geschmack optimiert.
            </para>
            <para>
              Darüber hinaus brauchen zwei Durchgänge zweimal so lang wie ein Durchgang.
              Du kannst die Optionen im ersten Durchgang auf höhere Geschwindigkeit
              und niedrigere Qualität optimieren.
              Wenn du deine Optionen geschickt wählst, kannst du einen sehr schnellen
              ersten Durchgang hinkriegen.
              Die resultierende Qualität im zweiten Durchgang wird geringfügig niedriger
              ausfallen, weil die Größenvorhersage weniger akkurat ist, jedoch
              ist die Qualitätsdifferenz normalerweise viel zu klein, um sichtbar zu sein.
              Versuche zum Beispiel <option>subq=1:frameref=1</option> zu
              <option>x264encopts</option> des ersten Durchgangs hinzuzufügen.
              Verwende dann im zweiten Durchgang langsamere, hochwertigere Optionen:
              <option>subq=6:frameref=15:partitions=all:me=umh</option>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">Encodierung mit drei Durchgängen</emphasis>?

              x264 bietet die Möglichkeit, eine beliebige Anzahl aufeinander folgender
              Durchgänge auszuführen. Wenn du <option>pass=1</option> im ersten Durchgang
              spezifizierst, dann verwende <option>pass=3</option> im nachfolgenden
              Durchgang, der nachfolgende Durchgang wird beides tun, die Statistik des
              vorhergehenden Durchgangs lesen und seine eigene Statistik schreiben.
              Ein zusätzlicher Durchgang, der diesem folgt, wird eine sehr gute Basis
              haben, von der aus er hochpräzise Vorhersagen der Framegrößen bei
              einem gewählten Quantisierer machen kann.
              In der Praxis ist der damit erzielte gesamte Qualitätsgewinn
              gewöhnlich nahezu null, und ziemlich wahrscheinlich resultiert ein dritter
              Durchgang in einem geringfügig schlechteren globalen PSNR als der Durchgang
              davor. In der typischen Anwendung helfen drei Durchgänge, wenn du entweder
              eine schleche Vorhersage der Bitraten oder schlecht aussehende Szenenübergänge
              beim Verwenden nur eines Durchlaufs bekommst.
              Dies passiert mit ziemlicher Wahrscheinlichkeit bei extrem kurzen Clips.
              Ebenso gibt es ein paar Spezialfälle, in denen drei (oder mehr) Durchgänge
              erfahrenen Nutzern dienlich sind, aber um es kurz zu machen, dieses Handbuch
              behandelt die Diskussion solcher speziellen Fälle nicht.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">qcomp</emphasis>:
              <option>qcomp</option> wägt die Anzahl der für "aufwändige" Frames
              mit viel Bewegung vorgesehenen Bits gegen die für "weniger aufwändige"
              Frames mit wenig Bewegung ab.
              Bei einem Extrem zielt <option>qcomp=0</option> auf eine echte konstante
              Bitrate ab. Typischerweise würde dies Szenen mit viel Bewegung vollkommen
              ätzend aussehen lassen, während Szenen mit wenig Bewegung womöglich absolut
              perfekt aussehen, jedoch öfter mehr Bitrate verwenden würden, als sie es für
              lediglich sehr gutes Aussehen bräuchten. Beim anderen Extrem
              erreicht <option>qcomp=1</option> nahezu konstante Quantisierungsparameter
              (QP). Ein konstanter QP sieht nicht schlecht aus, die meisten Leute meinen
              aber, es sei vernünftiger, etwas Bitrate aus den extrem aufwändigen Szenen
              zu nehmen (wobei dort der Qualitätsverlust micht ganz so augenfällig ist)
              und sie wieder den Szenen zuzuweisen, die bei sehr guter Qualität leichter
              zu encodieren sind.
              <option>qcomp</option> ist per Voreinstellung auf 0.6 gesetzt, was für den
              Geschmack mancher Leute etwas zu langsam sein könnte (0.7-0.8 werden im
              Allgemeinen auch verwendet).
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">keyint</emphasis>:
              <option>keyint</option> ist einzig und allein zur Abwägung der
              Durchsuchbarkeit der Datei gegenüber der Codiereffiziez da.
              Als Standardwert ist <option>keyint</option> auf 250 gesetzt. In
              Material mit 25fps garantiert dies, auf 10 Sekunden genau
              suchen zu können. Wenn du meinst, es wäre wichtig und nützlich,
              auf 5 Sekunden genau suchen zu können, setze es auf <option>keyint=125</option>;
              dies wird der Qualität/Bitrate leicht schaden. Wenn es dir nur um Qualität
              geht und nicht um die Durchsuchbarkeit, kannst du viel höhere Werte
              setzen (vorausgesetzt du verstehst, daß es verringerte Resultate gibt, die verschwindend
              klein werden oder sogar gegen null gehen). Der Videostream wird nach
              wie vor suchbare Stellen besitzen, solange einige Szenenwechsel
              vorhanden sind.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">deblock</emphasis>:
              Dieses Thema ist im Begriff etwas kontrovers zu geraten.
            </para>
            <para>
              H.264 definiert eine simple Deblocking-Prozedur bei I-Blöcken, die
              von vorgegebenen Stärken und vom QP des strittigen Blocks
              abhängigen.
              Mit dem Standardwert werden hohe QP-Blöcke stark gefiltert, und
              niedrige QP-Blöcke werden überhaupt nicht entblockt.
              Die vom Standard definierten vorgegebenen Stärken sind mit
              Bedacht gewählt und die Chancen stehen sehr gut, dass sie
              PSNR-optimal sind, egal welches Video auch immer du zu encodieren
              versuchst.
              Der Parameter <option>deblock</option> erlaubt dir, Offsets festzulegen,
              um Deblocking-Schwellen voreinzustellen.
            </para>
            <para>
              Viele Leute scheinen zu glauben, es sei eine gute Idee, die Stärke
              des Deblocking-Filters um hohe Beträge abzusenken (sagen wir -3).
              Dies ist jedoch meist keine gute Idee, und in den meisten Fällen
              verstehen Leute, die das machen, nicht viel davon wie Deblocking
              standardmäßig funktioniert.
            </para>
            <para>
              Die erste und wichtigste Sache, die man über den
              in-loop-Deblocking-Filter wissen sollte, ist, dass die
              Standardschwellenwerte meistens PSNR-optimal sind.
              In den seltenen Fällen, in denen sie nicht optimal sind, ist das
              ideale Offset plus oder minus 1.
              Die Deblocking-Parameter durch einen höheren Betrag anzupassen
              garantiert meist, dem PSNR zu schaden.
              Das Verstärken des Filters wird mehr Details verwischen; den
              Filter zu schwächen wird das Auftreten von Blockeffekten
              erhöhen.
            </para>
            <para>
              Es ist definitiv eine schlechte Idee, die Deblocking-Schwellenwerte
              herabzusetzen, falls deine Quelle eine vorwiegend niedrige räumliche
              Komplexität besitzt (z.B. nicht viele Details oder Rauschen).
              Der in-loop-Filter macht eigentlich einen exzellenten Job durch
              das Kaschieren auftretender Artefakte.
              Besitzt die Quelle eine hohe räumliche Komplexität, sind Artefakte
              weniger bemerkbar.
              Dies ist so, weil das Schwingen (ringing) dazu neigt, wie Details
              oder Rauschen auszusehen.
              Die viselle Wahrnehmung des Menschen erkennt leicht, wenn Details
              entfernt wurden, aber erkennt nicht so leicht, wenn Rauschen falsch
              dargestellt wird.
              Wird die Qualität subjektiv, sind Details und Rauschen etwas
              austauschbares.
              Durch das Herabsetzen der Deblocking-Filterstärke verstärkst du
              höchstwahrscheinlich Fehler durch Hinzufügen von
              Schwingungsartefakten, aber dem Auge fällt nichts auf, weil
              es die Artefakte mit Details verwechselt.
            </para>

            <para>
              Dies rechtfertigt jedoch <emphasis role="bold">nach wie vor</emphasis>
              nicht das Herabsetzen der Deblocking-Filterstärke.
              Du kannst im Allgemeinen besseres Qualitätsrauschen im Postprocessing
              erzielen.
              Falls deine H.264-Encodierungen zu verschwommen oder verschmiert
              aussehen, versuche, mit
              <option>-vf noise</option> beim Abspielen des encodierten Films
              herumzuspielen.
              <option>-vf noise=8a:4a</option> sollte die meisten weichen Artefakte
              kaschieren.
              Es wird meist mit Sicherheit besser aussehen als die Resultate, die
              du durch einfaches Herumtüfteln mit dem Deblocking-Filter bekommen
              hättest.
            </para></listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="menc-feat-x264-example-settings">
      <title>Beispiele für Encodieroptionen</title>

      <para>
        Die folgenden Einstellungen sind Beispiele unterschiedlicher
        Kombinationen von Encodier-Optionen, die einen Kompromiss zwischen
        Geschwindigkeit und Qualität bei gleicher Zielbitrate darstellen.
      </para>

      <para>
        All diese Encodier-Einstellungen wurden an einem Beispielvideo
        mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps,
        und der Rechner war ein
        AMD-64 3400+ mit 2400 MHz im 64bit-Modus.
        Jede Encodier-Einstellung zeichnet sich durch eine gemessene
        Encodiergeschwindigkeit (in Frames pro Sekunde) und dem
        PSNR-Verlust (in dB) im Vergleich zu den "sehr
        hochwertigen" Einstellung aus.
        Bitte hab dafür Verständnis, dass du abhängig von deiner Quelle, deinem
        Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche Resultate
        erhalten kannst.
      </para>

      <para>
        <informaltable frame="all">
          <tgroup cols="4">
            <thead>
              <row><entry>Beschreibung</entry><entry>Encodier-Optionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
            </thead>
            <tbody>
              <row>
                <entry>Sehr hohe Qualität</entry>
                <entry><option>subq=6:partitions=all:8x8dct:me=umh:frameref=5:bframes=3:b_pyramid:weight_b</option></entry>
                <entry>6fps</entry>
                <entry>0dB</entry>
              </row>
              <row>
                <entry>Hohe Qualität</entry>
                <entry><option>subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b</option></entry>
                <entry>13fps</entry>
                <entry>-0.89dB</entry>
              </row>
              <row>
                <entry>Schnell</entry>
                <entry><option>subq=4:bframes=2:b_pyramid:weight_b</option></entry>
                <entry>17fps</entry>
                <entry>-1.48dB</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </sect2>

  </sect1>

  <sect1 id="menc-feat-video-for-windows">
    <title>Encodieren mit der <systemitem class="library">Video for Windows</systemitem> Codecfamilie</title>

    <para>
      Video for Windows bietet einfaches Encodieren mittels binärer Video-Codecs.
      Du kannst mit folgenden Codecs encodieren (solltest du mehr haben, teile es
      uns bitte mit!)
    </para>
    <para>
      Beachte, dass der Support hierfür sehr experimentell ist, und
      einige Codecs arbeiten vielleicht nicht korrekt. Manche Codecs werden
      nur in bestimmten Farbräumen funktionieren, versuche
      <option>-vf format=bgr24</option> und <option>-vf format=yuy2</option>,
      falls ein Codec versagt oder einen falschen Output liefert.
    </para>

    <sect2 id="menc-feat-enc-vfw-video-codecs">
      <title>Von Video for Windows unterstützte Codecs</title>

      <para>
        <informaltable frame="all">
          <tgroup cols="4">
            <thead>
              <row>
                <entry>Video-Codec Dateiname</entry>
                <entry>Beschreibung (FourCC)</entry>
                <entry>md5sum</entry>
                <entry>Kommentar</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>aslcodec_vfw.dll</entry>
                <entry>Alparysoft verlustfreier (lossless) Codec vfw (ASLC)</entry>
                <entry>608af234a6ea4d90cdc7246af5f3f29a</entry>
                <entry></entry>
              </row>
              <row>
                <entry>avimszh.dll</entry>
                <entry>AVImszh (MSZH)</entry>
                <entry>253118fe1eedea04a95ed6e5f4c28878</entry>
                <entry>benötigt <option>-vf format</option></entry>
              </row>
              <row>
                <entry>avizlib.dll</entry>
                <entry>AVIzlib (ZLIB)</entry>
                <entry>2f1cc76bbcf6d77d40d0e23392fa8eda</entry>
                <entry></entry>
              </row>
              <row>
                <entry>divx.dll</entry>
                <entry>DivX4Windows-VFW</entry>
                <entry>acf35b2fc004a89c829531555d73f1e6</entry>
                <entry></entry>
              </row>
              <row>
                <entry>huffyuv.dll</entry>
                <entry>HuffYUV verlustfrei (lossless) (HFYU)</entry>
                <entry>b74695b50230be4a6ef2c4293a58ac3b</entry>
                <entry></entry>
              </row>
              <row>
                <entry>iccvid.dll</entry>
                <entry>Cinepak Video (cvid)</entry>
                <entry>cb3b7ee47ba7dbb3d23d34e274895133</entry>
                <entry></entry>
              </row>
              <row>
                <entry>icmw_32.dll</entry>
                <entry>Motion Wavelets (MWV1)</entry>
                <entry>c9618a8fc73ce219ba918e3e09e227f2</entry>
                <entry></entry>
              </row>
              <row>
                <entry>jp2avi.dll</entry>
                <entry>ImagePower MJPEG2000 (IPJ2)</entry>
                <entry>d860a11766da0d0ea064672c6833768b</entry>
                <entry><option>-vf flip</option></entry>
              </row>
              <row>
                <entry>m3jp2k32.dll</entry>
                <entry>Morgan MJPEG2000 (MJ2C)</entry>
                <entry>f3c174edcbaef7cb947d6357cdfde7ff</entry>
                <entry></entry>
              </row>
              <row>
                <entry>m3jpeg32.dll</entry>
                <entry>Morgan Motion JPEG Codec (MJPG)</entry>
                <entry>1cd13fff5960aa2aae43790242c323b1</entry>
                <entry></entry>
              </row>
              <row>
                <entry>mpg4c32.dll</entry>
                <entry>Microsoft MPEG-4 v1/v2</entry>
                <entry>b5791ea23f33010d37ab8314681f1256</entry>
                <entry></entry>
              </row>
              <row>
                <entry>tsccvid.dll</entry>
                <entry>TechSmith Camtasia Screen Codec (TSCC)</entry>
                <entry>8230d8560c41d444f249802a2700d1d5</entry>
                <entry></entry>
              </row>
              <row>
                <entry>vp31vfw.dll</entry>
                <entry>On2 Open Source VP3 Codec (VP31)</entry>
                <entry>845f3590ea489e2e45e876ab107ee7d2</entry>
                <entry></entry>
              </row>
              <row>
                <entry>vp4vfw.dll</entry>
                <entry>On2 VP4 Personal Codec (VP40)</entry>
                <entry>fc5480a482ccc594c2898dcc4188b58f</entry>
                <entry></entry>
              </row>
              <row>
                <entry>vp6vfw.dll</entry>
                <entry>On2 VP6 Personal Codec (VP60)</entry>
                <entry>04d635a364243013898fd09484f913fb</entry>
                <entry></entry>
              </row>
              <row>
                <entry>vp7vfw.dll</entry>
                <entry>On2 VP7 Personal Codec (VP70)</entry>
                <entry>cb4cc3d4ea7c94a35f1d81c3d750bc8d</entry>
                <entry>falscher FourCC?</entry>
              </row>
              <row>
                <entry>ViVD2.dll</entry>
                <entry>SoftMedia ViVD V2 Codec VfW (GXVE)</entry>
                <entry>a7b4bf5cac630bb9262c3f80d8a773a1</entry>
                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        Die erste Spalte enthält die Codec-Namen, die nach dem Parameter
        <literal>codec</literal> übergeben werden sollten, wie:
        <option>-xvfwopts codec=divx.dll</option>.
        Der FourCC-Code, der von jedem Codec verwendet wird, steht in Klammern.
      </para>
      <informalexample>
        <para>
          Ein Beispiel für die Konvertierung eines ISO DVD Trailers in eine
          VP5-Flash-Videodatei unter Benutzung der compdata-Bitrateneinstellungen:
<screen>mencoder -dvd-device <replaceable>zeiram.iso</replaceable> dvd://7 -o <replaceable>trailer.flv</replaceable> \
-ovc vfw -xvfwopts codec=vp6vfw.dll:compdata=onepass.mcf -oac mp3lame \
-lameopts cbr:br=64 -af lavcresample=22050 -vf yadif,scale=320:240,flip \
-of lavf
</screen>
        </para>
      </informalexample>

    </sect2>

    <sect2 id="menc-feat-video-for-windows-bitrate-settings">
      <title>Benutzung von vfw2menc, um eine Datei für Codeceinstellungen zu erzeugen</title>

      <para>
        Um mit Video für Windows Codecs zu encodieren, musst du Bitrate und andere
        Optionen setzen. Nach dem Stand der Dinge funktioniert dies für x86
        sowohl unter *NIX als auch unter Windows.
      </para>

      <para>
        Zuerst musst du das <application>vfw2menc</application>-Programm erzeugen.
        Es befindet sich im Ordner <filename class="directory">TOOLS</filename>
        des MPlayer-Sourcebaums.
        Um es unter Linux zu erstellen, kann <application>Wine</application> benutzt werden:

        <screen>winegcc vfw2menc.c -o vfw2menc -lwinmm -lole32</screen>

        Unter <application>MinGW</application> oder <application>Cygwin</application> verwende:

        <screen>gcc vfw2menc.c -o vfw2menc.exe -lwinmm -lole32</screen>

        Um es unter <application>MSVC</application> zu erstellen, wirst du getopt brauchen.
        Getopt findest du im Original-<application>vfw2menc</application>-Archiv, das
        es hier gibt:
        Das Projekt <ulink url="http://oss.netfarm.it/mplayer-win32.php">MPlayer on win32</ulink>.
      </para>

      <informalexample>
        <para>
          Unten steht ein Beispiel für den VP6-Codec.
          <screen>vfw2menc -f VP62 -d vp6vfw.dll -s firstpass.mcf</screen>
          Dies wird den Konfigurationsdialog des VP6-Codecs öffnen.
          Wiederhole diesen Schritt für den zweiten Durchlauf und benutze
          <option>-s <replaceable>secondpass.mcf</replaceable></option>.
        </para>
      </informalexample>

      <para>
        Windows-Benutzer können
        <option>-xvfwopts codec=vp6vfw.dll:compdata=dialog</option>
        verwenden, damit der Dialog angezeigt wird, bevor die Encodierung startet.
      </para>
    </sect2>
  </sect1>


  <sect1 id="menc-feat-quicktime-7">
    <title>
      <application>MEncoder</application> benutzen, um <application>QuickTime</application>-kompatible Dateien zu erstellen
    </title>

    <sect2 id="menc-feat-quicktime-7-why-use-it">
      <title>
        Warum sollte jemand <application>QuickTime</application>-kompatible Dateien erstellen wollen?
      </title>

      <para>
        Es gibt mehrere Gründe, warum das Erstellen von <application>QuickTime</application>-kompatiblen
        Dateien wünschenswert sein kann.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Du willst, dass jeder Computeranalphabet deine Encodierung auf jeder größeren
            Plattform (Windows, Mac OS X, Unices &hellip;) anschauen kann.
          </para>
        </listitem>
        <listitem>
          <para>
            <application>QuickTime</application> kann von mehr Features der Hardware- und
            Softwarebeschleunigung von Max OS X gebrauch machen als plattformunabhängige
            Player wie <application>MPlayer</application> oder <application>VLC</application>.
            Das heißt, dass deine Encodierungen eine bessere Chance haben, auf älteren
            G4-Machinen flüssig abgespielt werden zu können.
          </para>
        </listitem>
        <listitem>
          <para>
            <application>QuickTime</application> 7 unterstützt den Next-Generation-Codec H.264,
            der deutlich bessere Bildqualität erreicht als vorige Codecgenerationen
            (MPEG-2, MPEG-4 &hellip;).
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="menc-feat-quicktime-7-constraints">
      <title>Beschränkungen von <application>QuickTime</application> 7</title>

      <para>
        <application>QuickTime</application> 7 unterstützt H.264 Video und AAC Audio,
        aber es unterstützt diese nicht gemuxt im AVI-Containerformat.
        Du kannst jedoch <application>MEncoder</application> verwenden, um Video
        und Audio zu encodieren, und dann ein separates Programm wie
        <application>mp4creator</application> (Teil des
        <ulink url="http://mpeg4ip.sourceforge.net/">MPEG4IP-Pakets</ulink>)
        verwenden, um Video- und Tonspuren in einen MP4-Container zu muxen.
      </para>

      <para>
        <application>QuickTime</application>s Unterstützung für H.264 ist begrenzt,
        daher wirst du ein paar fortgeschrittene Features weglassen müssen.
        Wenn du dein Video mit Features encodierst, die
        <application>QuickTime</application> 7 nicht unterstützt, werden dir
        <application>QuickTime</application>-basierte Player ein ziemlich weißes
        Bild zeigen an Stelle des erwarteten Videos.
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">B-Frames</emphasis>:
            <application>QuickTime</application> 7 unterstützt maximal einen B-Frame, z.B.
            <option>-x264encopts bframes=1</option>. Dies bedeutet, dass
            <option>b_pyramid</option> and <option>weight_b</option> keine Auswirkungen
            haben werden, da sie <option>bframes</option> größer als 1 erwarten.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Macroblöcke</emphasis>:
            <application>QuickTime</application> 7 unterstützt keine 8x8 DCT Macroblöcke.
            Diese Option (<option>8x8dct</option>) ist per Voreinstellung aus, stelle daher sicher,
            dass du sie nicht explizit aktiviert.
            Dies bedeutet auch, dass die Option <option>i8x8</option> keine Auswirkungen haben
            wird, denn sie benötigt <option>8x8dct</option>.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Seitenverhältnis</emphasis>:
            <application>QuickTime</application> 7 unterstützt Informationen über
            SAR (sample aspect ratio) nicht; es nimmt SAR=1 an.
            Lies <link linkend="menc-feat-quicktime-7-scale">den Abschnitt über Skalierung</link>
            für eine Umgehung dieses Problems.
          </para>
        </listitem>
      </itemizedlist>

      </sect2>

      <sect2 id="menc-feat-quicktime-7-crop">
        <title>Beschneidung der Ränder (Cropping)</title>

        <para>
          Angenommen, du willst deine nagelneu gekaufte Kopie von "Chroniken von Narnia"
          rippen. Deine DVD ist Region 1, d.h. sie ist in NTSC.
          Das weiter unten stehende Beispiel kann man auch auf PAL anwenden, nur
          dass du dann <option>-ofps 24000/1001</option> weglassen und etwas andere
          Maße für <option>crop</option> und <option>scale</option> verwenden musst.
        </para>

        <para>
          Nach dem Ausführen von <option>mplayer dvd://1</option> folgst du den Anweisungen,
          die detailliert im Abschnitt
          <link linkend="menc-feat-telecine">Wie mit telecine und interlacing in NTSC-DVDs umgehen</link>
          beschrieben sind, und stellst fest, dass es sich um
          24000/1001 fps progressives Video handelt. Das vereinfacht das Vorgehen etwas,
          da du keinen inverse telecine Filter wie <option>pullup</option> oder einen
          Deinterlacing-Filter wie <option>yadif</option> anwenden musst.
        </para>

        <para>
          Als nächstes musst du die schwarzen Streifen oben und unten vom Video entfernen
          wie in <link linkend="menc-feat-dvd-mpeg4-example-crop">vorigem</link>
          Abschnitt beschrieben.
        </para>

      </sect2>

      <sect2 id="menc-feat-quicktime-7-scale">
        <title>Skalierung</title>

        <para>
          Der nächste Schritt ist wirklich herzzerreißend.
          <application>QuickTime</application> 7 unterstützt keine MPEG-4-Videos
          mit einer sample aspect ratio ungleich 1, daher wirst du das Video auf quadratische
          Pixel hochskalieren (was eine Menge Platz verschwendet) oder herunterskalieren
          (was ein paar Details der Quelle verliert) müssen.
          Beides ist höchst ineffizient, jedoch einfach nicht zu vermeiden, wenn
          dein Video von <application>QuickTime</application> 7 abspielbar sein soll.
          <application>MEncoder</application> kann die passende Hoch- oder Herunterskalierung
          durchführen bei Angabe von <option>-vf scale=-10:-1</option> oder
          <option>-vf scale=-1:-10</option> respektive.
          Dies wird dein Video auf die für die geschnittene Höhe korrekte Breite
          schneiden, gerundet auf das nächste Vielfache von 16 für optimale Kompression.
          Beachte, dass wenn du schneidest, solltest du zuerst schneiden und erst dann skalieren:
          <screen>-vf crop=720:352:0:62,scale=-10:-1</screen>
        </para>

      </sect2>

      <sect2 id="menc-feat-quicktime-7-avsync">
        <title>A/V-Synchronisation</title>

        <para>
          Weil du in einen anderen Container muxen wirst, solltest du immer die Option
          <option>harddup</option> verwenden, um sicherzustellen, dass doppelte
          Frames in der Videoausgabe tatsächlich dupliziert werden.
          Ohne diese Option wird <application>MEncoder</application> einfach eine Markierung
          im Videostream machen, dass ein doppelter Frame vorkommt, und sich darauf
          verlassen, dass die Software dafür sorgt, dass derselbe Frame zweimal
          angezeigt wird. Leider überlebt diese "weiche Duplikation" das Remuxen
          nicht, daher wird der Ton langsam Synchronisation zum Video verlieren.
        </para>

        <para>
          Die endgültige Filterkette sieht so aus:
          <screen>-vf crop=720:352:0:62,scale=-10:-1,harddup</screen>
        </para>

      </sect2>

      <sect2 id="menc-feat-quicktime-7-bitrate">
        <title>Bitrate</title>

        <para>
          Wie immer geht es bei der Wahl der Bitrate sowohl um technische Gegebenheiten
          der Quelle, wie <link linkend="menc-feat-dvd-mpeg4-resolution-bitrate">hier</link>
          erklärt wird, als auch um persönlichen Geschmack.
          Dieser Film enthält durchaus einige Actionszenen und viele Details, aber
          H.264-Video sieht gut aus auch bei viel geringeren Bitraten als XviD oder
          andere MPEG-4-Codecs.
          Nach vielem Experimentieren hat der Autor dieser Anleitung beschlossen,
          den Film bei 900kbps zu encodieren, und dachte, er sehe ziemlich gut aus.
          Du kannst die Bitrate verringern, um Platz zu sparen, oder erhöhen, um
          die Qualität zu verbessern.
        </para>

      </sect2>

      <sect2 id="menc-feat-quicktime-7-example">
        <title>Encoding-Beispiel</title>

        <para>
          Du bist jetzt soweit, das Video zu encodieren. Da du auf Qualität Wert legst,
          wirst du natürlich eine Encodierung mit zwei Durchläufen machen.
          Um etwas Encodierzeit zu sparen, kannst du die Option <option>turbo</option>
          beim ersten Durchlauf angeben; dies verringert <option>subq</option> und
          <option>frameref</option> auf 1. Um etwas Platz zu sparen, kannst du die
          Option <option>ss</option> verwenden, um die ersten Sekunden des Videos zu
          überspringen. (Ich fand, dass dieser bestimmte Film 32 Sekunden Vorspann hat.)
          <option>bframes</option> kann 0 oder 1 sein.
          Die anderen Optionen werden in
          <link linkend="menc-feat-x264-encoding-options-speedvquality">Encodierung mit dem <systemitem class="library">x264</systemitem>-Codec</link>
          und der Manpage beschrieben.

<screen>mencoder dvd://1 -o /dev/null -ss 32 -ovc x264 \
-x264encopts pass=1:turbo:bitrate=900:bframes=1:\
me=umh:partitions=all:trellis=1:qp_step=4:qcomp=0.7:direct_pred=auto:keyint=300 \
-vf crop=720:352:0:62,scale=-10:-1,harddup \
-oac faac -faacopts br=192:mpeg=4:object=2 -channels 2 -srate 48000 \
-ofps 24000/1001</screen>

          Wenn du einen Rechner mit mehreren Prozessoren hast, nutze die Chance, den
          Encodierungsvorgang dramatisch zu beschleunigen, indem du
          <link linkend="menc-feat-x264-encoding-options-speedvquality-threads">
            <systemitem class="library">x264</systemitem>'s Multithreading-Modus
          </link>
          verwendest, indem du die Option <option>threads=auto</option> der
          <option>x264encopts</option>-Kommandozeile hinzufügst.
        </para>

        <para>
          Der zweite Durchlauf ist derselbe, außer dass du die Ausgabedatei angibst
          und <option>pass=2</option> setzt.

<screen>mencoder dvd://1 <emphasis role="bold">-o narnia.avi</emphasis> -ss 32 -ovc x264 \
-x264encopts <emphasis role="bold">pass=2</emphasis>:turbo:bitrate=900:frameref=5:bframes=1:\
me=umh:partitions=all:trellis=1:qp_step=4:qcomp=0.7:direct_pred=auto:keyint=300 \
-vf crop=720:352:0:62,scale=-10:-1,harddup \
-oac faac -faacopts br=192:mpeg=4:object=2 -channels 2 -srate 48000 \
-ofps 24000/1001</screen>
          </para>
          <para>
            Das resultierende AVI sollte in <application>MPlayer</application>
            perfekt abspielbar sein, aber natürlich kann <application>QuickTime</application>
            es nicht abspielen. Denn es unterstützt H264 in AVI nicht.
            Der nächste Schritt ist also, das Video in einen MP4-Container zu muxen.

          </para>

        </sect2>

        <sect2 id="menc-feat-quicktime-7-remux">
          <title>Remuxen zu MP4</title>

          <para>
            Es gibt mehrere Möglichkeiten, AVI-Dateien nach MP4 zu muxen. Du kannst
            <application>mp4creator</application> verwenden, welches Teil des
            <ulink url="http://mpeg4ip.sourceforge.net/">MPEG4IP-Pakets</ulink> ist.
          </para>

          <para>
            Demuxe das AVI <application>MPlayer</application> zuerst in separate Audio- und Videostreams.

<screen>mplayer narnia.avi -dumpaudio -dumpfile narnia.aac
mplayer narnia.avi -dumpvideo -dumpfile narnia.h264</screen>
          Die Dateinamen sind wichtig; <application>mp4creator</application>
          verlangt, dass AAC-Audiostreams <systemitem>.aac</systemitem> und
          H.264-Videostreams <systemitem>.h264</systemitem> heißen.
        </para>

        <para>
          Benutze nun <application>mp4creator</application>, um aus Audio- und
          Videostreams eine MP4-Datei zu erzeugen.

 <screen>mp4creator -create=narnia.aac narnia.mp4
mp4creator -create=narnia.h264 -rate=23.976 narnia.mp4</screen>

          Anders als bei der Encodierung musst du die Framerate als Dezimalzahl
          (23.976) und nicht als Bruch (24000/1001) angeben.
        </para>

        <para>
          Diese Datei <systemitem>narnia.mp4</systemitem> sollte nun mit jeder
          <application>QuickTime</application> 7 Anwendung wie dem
          <application>QuickTime Player</application> oder
          <application>iTunes</application> abspielbar sein.
          Wenn du vorhast, das Video mit einem <application>QuickTime</application>-Plugin
          im Browser anzuschauen, solltest du den Film außerdem "hinten", so dass
          das <application>QuickTime</application>-Plugin während des Downloads
          die Wiedergabe starten kann.
          <application>mp4creator</application> kann diese Art Tracks erstellen:

<screen>mp4creator -hint=1 narnia.mp4
mp4creator -hint=2 narnia.mp4
mp4creator -optimize narnia.mp4</screen>

          Du kannst das Ergebnis überprüfen, um sicherzustellen, dass die Hint-Tracks
          erfolgreich erstellt wurden:
          <screen>mp4creator -list narnia.mp4</screen>

          Du solltest eine Auflistung der Tracks sehen:
          1 Audio-, 1 Video- und 2 Hint-Tracks.

<screen>Track   Type    Info
1       audio   MPEG-4 AAC LC, 8548.714 secs, 190 kbps, 48000 Hz
2       video   H264 Main@5.1, 8549.132 secs, 899 kbps, 848x352 @ 23.976001 fps
3       hint    Payload mpeg4-generic for track 1
4       hint    Payload H264 for track 2
</screen>

          </para>

        </sect2>

        <sect2 id="menc-feat-quicktime-7-metadata">
          <title>Metadata-Tags hinzufügen</title>

          <para>
            Wenn du deinem Video Tags hinzufügen möchtest, die in iTunes angezeigt werden,
            kannst du dazu
            <ulink url="http://atomicparsley.sourceforge.net/">AtomicParsley</ulink>
            verwenden.

            <screen>AtomicParsley narnia.mp4 --metaEnema --title "The Chronicles of Narnia" --year 2005 --stik Movie --freefree --overWrite</screen>

            Die Option <option>--metaEnema</option> entfernt jegliche existierenden Metadaten
            (<application>mp4creator</application> fügt seinen Namen im Tag
            "encoding tool" hinzu), und <option>--freefree</option> macht den frei
            gewordenen Platz geltend.
            Die Option <option>--stik</option> setzt den Videotyp
            (wie z.B. Film und Serie), den iTunes verwendet, um verwandte Videodateien
            zu gruppieren.
            Die Option <option>--overWrite</option> überschreibt die ursprüngliche Datei.
            Ohne sie erstellt <application>AtomicParsley</application> eine automatisch
            benannte Datei im selben Verzeichnis und lässt die Originaldatei unberührt.
          </para>

        </sect2>

      </sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="menc-feat-vcd-dvd">
    <title>Verwendung von <application>MEncoder</application> zum Erzeugen VCD/SVCD/DVD-konformer Dateien.</title>

    <sect2 id="menc-feat-vcd-dvd-constraints">
      <title>Formatbeschränkungen</title>
      <para>
        <application>MEncoder</application> ist in der Lage, MPEG-Dateien im VCD-, SCVD-
        und DVD-Format durch Verwendung der
        <systemitem class="library">libavcodec</systemitem>-Programmbibliothek
        zu erzeugen.
        Diese Dateien können danach im Zusammenhang mit
        <ulink url="http://www.gnu.org/software/vcdimager/vcdimager.html">vcdimager</ulink>
        oder
        <ulink url="http://dvdauthor.sourceforge.net/">dvdauthor</ulink>
        zum Erzeugen von Disks verwendet werden, die auf einem Standard Set-Top-Player
        abgespielt werden können.
      </para>

      <para>
        Die Formate DVD, SVCD und VCD sind starken Beschränkungen unterworfen.
        Es ist nur eine kleine Auswahl an encodierten Bildgrößen und Seitenverhältnissen
        verfügbar.
        Wenn dein Film nicht bereits die Anforderungen erfüllt, musst du das Bild
        skalieren, zuschneiden oder schwarze Ränder hinzufügen, um es konform zu machen.
      </para>

      <sect3 id="menc-feat-vcd-dvd-constraints-resolution">
        <title>Formatbeschränkungen</title>

        <informaltable frame="all">
          <tgroup cols="9">
            <thead>
              <row>
                <entry>Format</entry>
                <entry>Auflösung</entry>
                <entry>V. Codec</entry>
                <entry>V. Bitrate</entry>
                <entry>Samplerate</entry>
                <entry>A. Codec</entry>
                <entry>A. Bitrate</entry>
                <entry>FPS</entry>
                <entry>Seitenverhältnis</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>NTSC DVD</entry>
                <entry>720x480, 704x480, 352x480, 352x240</entry>
                <entry>MPEG-2</entry>
                <entry>9800 kbps</entry>
                <entry>48000 Hz</entry>
                <entry>AC3,PCM</entry>
                <entry>1536 kbps (max)</entry>
                <entry>30000/1001, 24000/1001</entry>
                <entry>4:3, 16:9 (nur für 720x480)</entry>
              </row>
              <row>
                <entry>NTSC DVD</entry>
                <entry>352x240<footnote id='fn-rare-resolutions'><para>
                      Diese Auflösungen werden selten für DVDs verwendet, da sie von
                      ziemlch niedriger Qualität sind.</para></footnote></entry>
                <entry>MPEG-1</entry>
                <entry>1856 kbps</entry>
                <entry>48000 Hz</entry>
                <entry>AC3,PCM</entry>
                <entry>1536 kbps (max)</entry>
                <entry>30000/1001, 24000/1001</entry>
                <entry>4:3, 16:9</entry>
              </row>
              <row>
                <entry>NTSC SVCD</entry>
                <entry>480x480</entry>
                <entry>MPEG-2</entry>
                <entry>2600 kbps</entry>
                <entry>44100 Hz</entry>
                <entry>MP2</entry>
                <entry>384 kbps (max)</entry>
                <entry>30000/1001</entry>
                <entry>4:3</entry>
              </row>
              <row>
                <entry>NTSC VCD</entry>
                <entry>352x240</entry>
                <entry>MPEG-1</entry>
                <entry>1150 kbps</entry>
                <entry>44100 Hz</entry>
                <entry>MP2</entry>
                <entry>224 kbps</entry>
                <entry>24000/1001, 30000/1001</entry>
                <entry>4:3</entry>
              </row>
              <row>
                <entry>PAL DVD</entry>
                <entry>720x576, 704x576, 352x576, 352x288</entry>
                <entry>MPEG-2</entry>
                <entry>9800 kbps</entry>
                <entry>48000 Hz</entry>
                <entry>MP2,AC3,PCM</entry>
                <entry>1536 kbps (max)</entry>
                <entry>25</entry>
                <entry>4:3, 16:9 (nur für 720x576)</entry>
              </row>
              <row>
                <entry>PAL DVD</entry>
                <entry>352x288<footnoteref linkend='fn-rare-resolutions'/></entry>
                <entry>MPEG-1</entry>
                <entry>1856 kbps</entry>
                <entry>48000 Hz</entry>
                <entry>MP2,AC3,PCM</entry>
                <entry>1536 kbps (max)</entry>
                <entry>25</entry>
                <entry>4:3, 16:9</entry>
              </row>
              <row>
                <entry>PAL SVCD</entry>
                <entry>480x576</entry>
                <entry>MPEG-2</entry>
                <entry>2600 kbps</entry>
                <entry>44100 Hz</entry>
                <entry>MP2</entry>
                <entry>384 kbps (max)</entry>
                <entry>25</entry>
                <entry>4:3</entry>
              </row>
              <row>
                <entry>PAL VCD</entry>
                <entry>352x288</entry>
                <entry>MPEG-1</entry>
                <entry>1152 kbps</entry>
                <entry>44100 Hz</entry>
                <entry>MP2</entry>
                <entry>224 kbps</entry>
                <entry>25</entry>
                <entry>4:3</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>
          Wenn ein Film ein 2.35:1 Seitenverhältnis hat (die meisten aktuellen Action-Filme),
          wirst du schwarze Ränder hinzufügen oder den Film auf 16:9 zuschneiden müssen,
          um eine DVD oder VCD herzustellen.
          Wenn du schwarze Ränder hinzufügst, versuche diese an 16-Pixel-Rändern
          auszurichten, um den Einfluß auf die Encodier-Performance zu minimieren.
          Zum Glück besitzen DVDs eine ausreichend hohe Bitrate, damit du dich
          nicht zu sehr um die Encodier-Effizienz sorgen musst. SVCD
          und VCD jedoch sind höchst mager an Bitrate und erfordern Aufwand, um akzeptable
          Qualität zu erreichen.
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-constraints-gop">
        <title>GOP-Größenbeschränkungen</title>
        <para>
          DVD, VCD und SVCD zwingen dich auch zu relativ niedrigen
          GOP-Größen (Group of Pictures).
          Für Material mit 30 fps ist die größte erlaubte GOP-Größe 18.
          Für 25 oder 24 fps ist das Maximum 15.
          Die GOP-Größe wird mittels der Option <option>keyint</option> gesetzt.
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-constraints-bitrate">
        <title>Bitraten-Beschränkungen</title>
        <para>
          VCD-Video muss bei CBR 1152 kbps sein.
          Zu dieser nach oben begrenzten Einschränkung kommt auch noch eine
          extrem niedrige vbv-Puffergröße von 327 Kilobit.
          SVCD erlaubt das Variieren der Video-Bitraten auf bis zu 2500 kbps,
          und eine etwas weniger restriktive vbv-Puffergröße von 917 Kilobit
          ist erlaubt.
          DVD-Video-Bitraten können sich bis auf irgendwo um die 9800 kbps
          einpegeln (wenngleich typische Bitraten etwa halb so groß sind),
          und die vbv-Puffergröße ist 1835 Kilobit.
        </para>
      </sect3>
    </sect2>

    <sect2 id="menc-feat-vcd-dvd-output">
      <title>Output-Optionen</title>
      <para>
        <application>MEncoder</application> besitzt Optionen zur Kontrolle des
        Output-Formats.
        Durch das Verwenden dieser Optionen können wir ihn anweisen, den
        korrekten Dateityp zu erzeugen.
      </para>

      <para>
        Die Optionen für VCD und SVCD werden xvcd und xsvcd genannt, weil sie
        erweiterte Formate sind.
        Sie sind nicht strikt Standard-konform, hauptsächlich weil der Output
        keine Scan-Offsets enthält.
        Wenn du ein SVCD-Image generieren musst, solltest du die Output-Datei
        dem
        <ulink url="http://www.gnu.org/software/vcdimager/vcdimager.html">vcdimager</ulink>
        übergeben.
      </para>

      <para>
        VCD:
        <screen>-of mpeg -mpegopts format=xvcd</screen>
      </para>

      <para>
        SVCD:
        <screen>-of mpeg -mpegopts format=xsvcd</screen>
      </para>

      <para>
        DVD (mit Zeitstempeln für jeden Frame, wenn möglich):
        <screen>-of mpeg -mpegopts format=dvd:tsaf</screen>
      </para>

      <para>
        DVD mit NTSC-Pullup:
        <screen>-of mpeg -mpegopts format=dvd:tsaf:telecine -ofps 24000/1001</screen>
        Dies erlaubt 24000/1001 fps progressive-Inhalt bei 30000/1001
        fps encodiert zu werden, wobei die DVD-Konformität erhalten bleibt.
      </para>

      <sect3 id="menc-feat-vcd-dvd-output-aspect">
        <title>Seitenverhältnis</title>
        <para>
          Der Parameter für das Seitenverhältnis von <option>-lavcopts</option> wird zum Encodieren
          des Seitenverhältnisses einer Datei verwendet.
          Während des Playbacks wird das Seitenverhältnis dazu benutzt, die korrekte
          Größe des Videos wieder herzustellen.
        </para>

        <para>
          16:9 oder "Breitbild"
          <screen>-lavcopts aspect=16/9</screen>
        </para>

        <para>
          4:3 oder "Vollbild"
          <screen>-lavcopts aspect=4/3</screen>
        </para>

        <para>
          2.35:1 oder "Cinemascope" NTSC
          <screen>-vf scale=720:368,expand=720:480 -lavcopts aspect=16/9</screen>
          Um die korrekte Skalierungsgröße zu berechnen, verwende die
          erweiterte NTSC-Breite von 854/2.35 = 368
        </para>

        <para>
          2.35:1 oder "Cinemascope" PAL
          <screen>-vf scale=720:432,expand=720:576 -lavcopts aspect=16/9</screen>
          Um die korrekte Skalierungsgröße zu berechnen, verwende die
          erweiterte PAL-Breite von 1024/2.35 = 432
        </para>

      </sect3>

      <sect3 id="menc-feat-vcd-dvd-a-v-sync">
        <title>Aufrechterhalten der A/V-Synchronisation</title>
        <para>
          Um die Audio-/Video-Synchronisation während der kompletten
          Encodierung aufrechtzuerhalten, muss
          <application>MEncoder</application> Frames auslassen oder duplizieren.
          Dies funktioniert beim Muxen in eine AVI-Datei ziemlich gut,
          aber meist schlägt das Aufrechterhalten der A/V-Synchronisation mit
          anderen Muxern wie etwa MPEG garantiert fehl.
          Dies ist der Grund, weshalb es nötig ist, den
          <option>harddup</option>-Video-Filter am Ende der Filterkette anzuhängen,
          um diese Art Problem zu vermeiden.
          Du findest mehr technische Informationen zu <option>harddup</option>
          im Abschnitt
          <link linkend="menc-feat-dvd-mpeg4-muxing-filter-issues">Verbessern der Mux- und A/V-Synchronisationszuverlässigkeit</link>
          oder in der Manpage.
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-output-srate">
        <title>Sampleraten-Konvertierung</title>
        <para>
          Wenn die Audio-Samplerate in der Originaldatei nicht dieselbe wie die
          vom Zielformat angeforderte ist, wird eine Sampleraten-Konvertierung
          erforderlich.
          Dies wird erreicht, indem man die Option <option>-srate</option> und
          den <option>-af lavcresample</option> Audio-Filter zusammen
          anwedet.
        </para>
        <para>
          DVD:
          <screen>-srate 48000 -af lavcresample=48000</screen>
        </para>
        <para>
          VCD und SVCD:
          <screen>-srate 44100 -af lavcresample=44100</screen>
        </para>
      </sect3>
    </sect2>

    <sect2 id="menc-feat-vcd-dvd-lavc">
      <title>Verwenden des libavcodec zur VCD/SVCD/DVD-Encodierung</title>

      <sect3 id="menc-feat-vcd-dvd-lavc-intro">
        <title>Einführung</title>
        <para>
          <systemitem class="library">libavcodec</systemitem> kann verwendet
          werden, um ein VCD/SVCD/DVD-konformes Video durch die Anwendung der
          passenden Optionen zu erzeugen.
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-lavc-options">
        <title>lavcopts</title>
        <para>
          Dies ist eine Liste von Feldern in <option>-lavcopts</option>, die du
          möglicherweise ändern musst, um einen für VCD, SVCD
          oder DVD konformen Film herzustellen:
        </para>

        <itemizedlist>
          <listitem>
            <para>
              <emphasis role="bold">acodec</emphasis>:
              <option>mp2</option> für VCD, SVCD oder PAL DVD;
              <option>ac3</option> wird am häufigsten für DVD verwendet.
              PCM-Audio kann auch für DVD verwendet werden, aber dies ist meistens
              eine riesen Platzverschwendung.
              Beachte, dass MP3-Audio nicht konform für irgendeines dieser Formate
              ist, aber Player haben oft ohnehin kein Problem, es abzuspielen.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">abitrate</emphasis>:
              224 für VCD; bis zu 384 für SVCD; bis zu 1536 für  DVD, aber
              übliche Werte reichen von 192 kbps für Stereo bis 384 kbps für
              5.1-Kanal-Sound.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">vcodec</emphasis>:
              <option>mpeg1video</option> für VCD;
              <option>mpeg2video</option> für SVCD;
              <option>mpeg2video</option> wird gewöhnlich für DVD verwendet, man kann aber auch
              <option>mpeg1video</option> für CIF-Auflösungen verwenden.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">keyint</emphasis>:
              Angewandt, um die GOP-Größe zu setzen.
              18 für Material mit 30fps oder 15 für Material mit 25/24 fps.
              Kommerzielle Hersteller scheinen Keyframe-Intervalle von 12 zu bevorzugen.
              Es ist möglich, dies viel größer zu machen und dennoch die Kompatibilität
              zu den meisten Player zu behalten.
              Ein <option>keyint</option> von 25 sollte nie irgendwelche Probleme machen.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">vrc_buf_size</emphasis>:
              327 für VCD, 917 für SVCD und 1835 für DVD.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">vrc_minrate</emphasis>:
              1152 für VCD. kann für SVCD und DVD so gelassen werden.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">vrc_maxrate</emphasis>:
              1152 für VCD; 2500 für SVCD; 9800 für DVD.
              Für SVCD und DVD könntest du niedrigere Werte verwenden, abhängig von
              deinen persönlichen Vorlieben und Anforderungen.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis role="bold">vbitrate</emphasis>:
              1152 für VCD;
              bis zu 2500 für SVCD;
              bis zu 9800 für DVD.
              Für letztere zwei Formate sollte vbitrate basierend auf persönliche
              Vorlieben gesetzt werden.
              Zum Beispiel, wenn du darauf bestehst, 20 Stunden oder so passend auf
              eine DVD zu bringen, könntest du vbitrate=400 benutzen.
              Die sich daraus ergebende Video-Qualität würde womöglich äußerst mies.
              Wenn du versuchst, die maximal mögliche Qualität auf eine DVD zu quetschen,
              nimm vbitrate=9800, aber sei gewarnt, dass dich dies zu weniger als
              einer Stunde Video auf einer Single-Layer DVD zwingen würde.
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis role="bold">vstrict</emphasis>:
              <option>vstrict</option>=0 sollte verwendet werden, um DVDs zu erstellen.
              Ohne diese Option erzeugt <application>MPlayer</application> einen Stream, der von
              manchen standalone DVD-Playern nicht korrekt decodiert werden kann.
            </para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-lavc-examples">
        <title>Beispiele</title>
        <para>
          Dies ist eine typische Zusammenstellung von mindestens zu verwendenden
          <option>-lavcopts</option>-Optionen zum Encodieren eines Videos:
        </para>
        <para>
          VCD:
<screen>-lavcopts vcodec=mpeg1video:vrc_buf_size=327:vrc_minrate=1152:\
vrc_maxrate=1152:vbitrate=1152:keyint=15:acodec=mp2</screen>
        </para>

        <para>
          SVCD:
<screen>-lavcopts vcodec=mpeg2video:vrc_buf_size=917:vrc_maxrate=2500:vbitrate=1800:\
keyint=15:acodec=mp2</screen>
        </para>

        <para>
          DVD:
<screen>-lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:\
keyint=15:vstrict=0:acodec=ac3</screen>
        </para>

      </sect3>

      <sect3 id="menc-feat-vcd-dvd-lavc-advanced">
        <title>Erweiterte Optionen</title>
        <para>
          Für das Encodieren höherer Qualität könntest du auch qualitätssteigernde
          Optionen an lavcopts anfügen, wie etwa <option>trell</option>,
          <option>mbd=2</option> und weitere.
          Beachte, dass <option>qpel</option> und <option>v4mv</option>, obwohl
          oft bei MPEG-4 nützlich, nicht auf MPEG-1 oder MPEG-2 anwendbar sind.
          Außerdem, wenn du versuchst, eine sehr hochwertige DVD-Encodierung zu
          machen, kann es nützlich sein, <option>dc=10</option> an lavcopts
          anzufügen.
          Wobei dies helfen könnte, das Auftreten von Blöcken in fahl-farbenen
          Bereichen zu reduzieren.
          Zusammenfassend ist dies ein Beispiel einer Zusammenstellung von lavcopts für
          für eine höherwertige DVD:
        </para>

        <para>
<screen>-lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=8000:\
keyint=15:trell:mbd=2:precmp=2:subcmp=2:cmp=2:dia=-10:predia=-10:cbp:mv0:\
vqmin=1:lmin=1:dc=10:vstrict=0</screen>
        </para>

      </sect3>
    </sect2>

    <sect2 id="menc-feat-vcd-dvd-audio">
      <title>Encodieren von Audio</title>
      <para>
        VCD und SVCD unterstützen MPEG-1 Layer II Audio, indem sie einen
        MP2-Encoder von
        <systemitem class="library">toolame</systemitem>,
        <systemitem class="library">twolame</systemitem>,
        oder <systemitem class="library">libavcodec</systemitem>
        verwenden.
        Der libavcodec MP2 ist weit davon entfernt, so gut zu sein wie die
        anderen zwei Bibliotheken, dennoch sollte er immer verfügbar sein.
        VCD unterstützt nur Audio mit konstanten Bitraten (CBR) wogegen SVCD
        auch variable Bitraten (VBR) unterstützt.
        Sei vorsichtig, wenn du VBR benutzt, weil einige schlechte
        Standalone-Player diese nicht so gut unterstützen könnten.
      </para>

      <para>
        Für DVD-Audio wird der AC3-Codec von
        <systemitem class="library">libavcodec</systemitem>
        verwendet.
      </para>

      <sect3 id="menc-feat-vcd-dvd-audio-toolame">
        <title>toolame</title>
        <para>
          Für VCD und SVCD:
          <screen>-oac toolame -toolameopts br=224</screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-audio-twolame">
        <title>twolame</title>
        <para>
          Für VCD und SVCD:
          <screen>-oac twolame -twolameopts br=224</screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-audio-lavc">
        <title>libavcodec</title>
        <para>
          Für DVD mit 2-Kanal-Sound:
          <screen>-oac lavc -lavcopts acodec=ac3:abitrate=192</screen>
        </para>
        <para>
          Für DVD mit 5.1-Kanal-Sound:
          <screen>-channels 6 -oac lavc -lavcopts acodec=ac3:abitrate=384</screen>
        </para>
        <para>
          Für VCD und SVCD:
          <screen>-oac lavc -lavcopts acodec=mp2:abitrate=224</screen>
        </para>
      </sect3>

    </sect2>

    <sect2 id="menc-feat-vcd-dvd-all">
      <title>Zusammenfassung</title>
      <para>
        Diese Sektion zeigt einige komplette Befehle zum Erzeugen von
        VCD/SVCD/DVD-konformen Videos.
      </para>

      <sect3 id="menc-feat-vcd-dvd-all-pal-dvd">
        <title>PAL DVD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=dvd:tsaf -vf scale=720:576,\
harddup -srate 48000 -af lavcresample=48000 -lavcopts vcodec=mpeg2video:\
vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:keyint=15:vstrict=0:acodec=ac3:\
abitrate=192:aspect=16/9 -ofps 25 \
-o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-ntsc-dvd">
        <title>NTSC DVD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=dvd:tsaf -vf scale=720:480,\
  harddup -srate 48000 -af lavcresample=48000 -lavcopts vcodec=mpeg2video:\
  vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:keyint=18:vstrict=0:acodec=ac3:\
  abitrate=192:aspect=16/9 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-pal-ac3-copy">
        <title>PAL AVI mit enthaltenem AC3 Audio nach DVD</title>
        <para>
          Hat die Quelle bereits AC3-Audio, nimm -oac copy anstatt es
          erneut zu encodieren.
<screen>mencoder -oac copy -ovc lavc -of mpeg -mpegopts format=dvd:tsaf -vf scale=720:576,\
  harddup -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:\
  vbitrate=5000:keyint=15:vstrict=0:aspect=16/9 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-ntsc-ac3-copy">
        <title>NTSC AVI mit AC3-Ton nach DVD</title>
        <para>
          Hat die Quelle bereits AC3-Audio und ist NTSC @ 24000/1001 fps:
<screen>mencoder -oac copy -ovc lavc -of mpeg -mpegopts format=dvd:tsaf:telecine \
  -vf scale=720:480,harddup -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:\
  vrc_maxrate=9800:vbitrate=5000:keyint=15:vstrict=0:aspect=16/9 -ofps 24000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-pal-svcd">
        <title>PAL SVCD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xsvcd -vf \
  scale=480:576,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg2video:mbd=2:keyint=15:vrc_buf_size=917:vrc_minrate=600:\
  vbitrate=2500:vrc_maxrate=2500:acodec=mp2:abitrate=224 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-ntsc-svcd">
        <title>NTSC SVCD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xsvcd  -vf \
  scale=480:480,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg2video:mbd=2:keyint=18:vrc_buf_size=917:vrc_minrate=600:\
  vbitrate=2500:vrc_maxrate=2500:acodec=mp2:abitrate=224 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-pal-vcd">
        <title>PAL VCD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xvcd -vf \
  scale=352:288,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg1video:keyint=15:vrc_buf_size=327:vrc_minrate=1152:vbitrate=1152:\
  vrc_maxrate=1152:acodec=mp2:abitrate=224 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

      <sect3 id="menc-feat-vcd-dvd-all-ntsc-vcd">
        <title>NTSC VCD</title>
        <para>
<screen>mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xvcd -vf \
  scale=352:240,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg1video:keyint=18:vrc_buf_size=327:vrc_minrate=1152:vbitrate=1152:\
  vrc_maxrate=1152:acodec=mp2:abitrate=224 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable></screen>
        </para>
      </sect3>

    </sect2>

  </sect1>

</chapter>
