<?xml version="1.0" encoding="utf-8"?>
<!-- in sync with r23594 -->
<!-- missing cosmetic commit 21537 -->
<chapter id="video">
<title>Videoausgabegeräte</title>

<sect1 id="mtrr">
<title>MTRR einrichten</title>

<para>
  Du solltest UNBEDINGT sicherstellen, dass die MTRR-Register richtig belegt
  sind, denn sie können einen großen Geschwindigkeitsschub
  bringen.
</para>

<para>
  Gib den Befehl <command>cat /proc/mtrr</command> ein:
<screen>
<prompt>--($:~)--</prompt> cat /proc/mtrr
reg00: base=0xe4000000 (3648MB), size=  16MB: write-combining, count=9
reg01: base=0xd8000000 (3456MB), size= 128MB: write-combining, count=1<!--
--></screen>
</para>

<para>
  Diese Anzeige ist richtig. Sie zeigt meine Matrox G400 mit 16MB Speicher.
  Ich habe die Einstellung von XFree 4.x.x, der die MTRR-Register automatisch
  einstellt.
</para>

<para>
  Wenn nichts funktioniert, musst du sie manuell setzen. Als erstes musst du
  die Basisadresse finden. Dazu gibt es drei Möglichkeiten:

<orderedlist>
<listitem><para>
  durch die X11 Start-Meldungen, zum Beispiel:
  <screen>
(--) SVGA: PCI: Matrox MGA G400 AGP rev 4, Memory @ 0xd8000000, 0xd4000000
(--) SVGA: Linear framebuffer at 0xD8000000<!--
--></screen>
  </para></listitem>
<listitem><para>
  von <filename>/proc/pci</filename> (verwende den Befehl
<command>lspci -v</command>):
  <screen>
01:00.0 VGA compatible controller: Matrox Graphics, Inc.: Unknown device 0525
Memory at d8000000 (32-bit, prefetchable)<!--
--></screen>
  </para></listitem>
<listitem><para>
  von den mga_vid Kerneltreiber-Meldungen (verwende <command>dmesg</command>):
  <screen>mga_mem_base = d8000000</screen>
  </para></listitem>
</orderedlist>
</para>

<para>
  So, nun gilt es, die Speichergröße zu finden. Dies ist sehr
  einfach, konvertiere einfach die Video-RAM-Größe nach hexadezimal,
  oder verwende diese Tabelle:
<informaltable frame="none">
<tgroup cols="2">
<tbody>
<row><entry>1 MB</entry><entry>0x100000</entry></row>
<row><entry>2 MB</entry><entry>0x200000</entry></row>
<row><entry>4 MB</entry><entry>0x400000</entry></row>
<row><entry>8 MB</entry><entry>0x800000</entry></row>
<row><entry>16 MB</entry><entry>0x1000000</entry></row>
<row><entry>32 MB</entry><entry>0x2000000</entry></row>
</tbody>
</tgroup>
</informaltable>
</para>

<para>
  Du kennst die Basisadresse und die Speichergröße? Lass uns
  die MTRR Register einstellen! Für die Matrox-Karte von oben
  (<literal>base=0xd8000000</literal>) mit 32MB RAM (<literal>size=0x2000000</literal>)
  führst du einfach folgendes aus:
<screen>
echo "base=0xd8000000 size=0x2000000 type=write-combining" &gt; /proc/mtrr
</screen>
</para>

<para>
  Nicht alle CPUs unterstützen MTRRs. Zum Beispiel ältere K6-2s
  [bei ca. 266MHz, stepping 0] unterstützen kein MTRR, aber Stepping-12-CPUs
  tun es (<command>cat /proc/cpuinfo</command> gibt Aufschluss).
</para>
</sect1>

<sect1 id="xv">
<title>Xv</title>

<para>
  Mit XFree86 4.0.2 oder neueren Versionen kannst du die Hardware-YUV-Routinen
  deiner Grafikkarte mit Hilfe der XVideo-Erweiterungen benutzen. Das ist die
  Technik, die <option>-vo xv</option> benutzt. Dieser Treiber unterstützt
  darüber hinaus die Anpassung von Helligkeit/Kontrast/Sättigung etc.
  (es sei denn, du benutzt den alten und langsamen DirectShow DivX-Codec,
  welcher diese Anpassungen unabhängig vom Videoausgabetreiber unterstützt).
  Schau in der Manpage nach.
</para>

<para>
  Um Xv zum Laufen zu bringen, musst du auf die folgenden Punkte achten:

<orderedlist>
<listitem><para>
  Du musst XFree86 4.0.2 oder eine neuere Version verwenden, da die
  älteren Versionen XVideo noch nicht kannten.
  </para></listitem>
<listitem><para>
  Deine Grafikkarte muss Hardware-Unterstützung für YUV bieten, was alle
  modernen Karten tun.
  </para></listitem>
<listitem><para>
  X muss die XVideo-Erweiterung auch tatsächlich laden, was zu
  Meldungen ähnlich der folgenden führt:

  <programlisting>(II) Loading extension XVideo</programlisting>

  in <filename>/var/log/XFree86.0.log</filename>

  <note><para>
  Diese Meldung besagt nur, dass die XFree86-Erweiterung
  geladen wird. Bei einer guten Installation sollte das immer der Fall
  sein. Das heißt allerdings noch nicht, dass die
  <emphasis role="bold">XVideo-Unterstützung der Grafikkarte</emphasis>
  auch geladen wurde!
  </para></note>
  </para></listitem>
<listitem><para>
  Deine Karte muss unter Linux Xv-Unterstützung haben. Du kannst dich
  dessen mit <command>xvinfo</command> vergewissern, das Teil der
  XFree86-Distribution ist. Es sollte einen längeren Text ausgeben,
  der ungefähr so aussieht:

<screen>
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
(...)
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
(...etc...)<!--
--></screen>
  Damit <application>MPlayer</application> Xv benutzen kann, müssen die
  Pixelformate YUY2 packed und YV12 planar unterstützt werden.
  </para></listitem>
  <listitem><para>
  Stelle als letztes sicher, dass <application>MPlayer</application> mit
  Unterstützung für Xv compiliert wurde. <command>configure</command> gibt eine
  entsprechende Meldung aus.
  Führe den Befehl <command>mplayer -vo help | grep xv </command> aus.
  Wurde Unterstützung für Xv eingebaut, sollte eine ähnliche Meldung
  wie diese erscheinen:
  <screen>xv      X11/Xv</screen>
  </para></listitem>
</orderedlist>
</para>

<sect2 id="tdfx">
<title>3dfx-Karten</title>

<para>
  Ältere 3dfx-Treiber hatten bekanntermaßen Probleme mit der
  XVideo-Beschleuningung, die weder YUY2 noch YV12 unterstützte.
  Stelle sicher, dass du XFree86 Version 4.2.0 oder neuer verwendest, da diese
  Versionen mit YV12 und YUY2 keine Probleme haben, während frühere Versionen, auch
  4.1.0, <emphasis role="bold">bei YV12 abgestürzen</emphasis>.
  Wenn du merkwürdige Effekte bei der Verwendung von <option>-vo xv</option>
  bemerkst, dann probier aus, ob mit SDL, das ebenfalls XVideo nutzen kann,
  diese Effekte verschwinden. In der <link linkend="sdl">SDL</link> stehen
  Details darüber.
</para>

<para>
  <emphasis role="bold">Alternativ</emphasis> kannst du auch den NEUEN
  tdfxfb-Treiber mit <option>-vo tdfxfb</option> verwenden!
  Lies dazu die <link linkend="tdfxfb">tdfxfb</link>-Sektion.
</para>
</sect2>


<sect2 id="s3">
<title>S3-Karten</title>

<para>
  S3 Savage3D-Karten sollten problemlos funktionieren, aber bei Savage4-
  Chips solltest du XFree86 4.0.3 oder neuer verwenden. Probier bei Problemen
  den 16bpp-Farbmodus aus. Und der S3 Virge... Es gibt für ihn zwar Xv-
  Unterstützung, aber die Karte selbst ist so langsam, dass du sie besser
  verkaufst.
</para>
<para>
  Es gibt inzwischen einen nativen Framebuffer-Treiber für S3 Virge-Karten, ähnlich
  tdfxfb. Mache die Einstellungen (hänge z.B.
  "<option>vga=792 video=vesa:mtrr</option>" an die Kernelkommandozeile an) und benutze
  <option>-vo s3fb</option> (<option>-vf yuy2</option> und <option>-dr</option>
  helfen auch).
</para>

<note>
<para>
  Momentan ist nicht ganz klar, welche Savage-Modelle keine Unterstützung
  für YV12 in Hardware haben, sodass bei ihnen der Treiber diese Konvertierung
  sehr langsam vornimmt. Hast du deine Karte in Verdacht, dann
  besorg dir einen neueren Treiber, oder frag auf der MPlayer-Users-Mailingliste
  freundlich nach einem Treiber, der MMX/3DNow unterstützt.
</para>
</note>
</sect2>


<sect2 id="nvidia">
<title>nVidia-Karten</title>

<para>
  nVidia ist für Linux keine optimale Wahll.
  XFree86's Open-Source-Treiber unterstützt die meisten dieser Karten, jedoch
  musst du in einigen Fällen die binären Closed-Source-Treiber von nVidia
  verwenden, verfügbar auf der
  <ulink url="http://www.nvidia.com/object/linux.html">nVidia-Webseite</ulink>.
  Du brauchst diese Treiber immer, wenn du zusätzlich 3D-Beschleunigung
  haben willst.
</para>

<para>
  Riva128-Karten bieten nicht einmal mit den binären nVidia-Treibern
  XVideo-Unterstützung (beklag dich bei nVidia).
</para>

<para>
  Wie auch immer, <application>MPlayer</application> enthält einen
  <link linkend="vidix">VIDIX</link> -Treiber für die meisten nVidia-Karten.
  Er ist aktuell in der Beta-Phase und besitzt einige Nachteile. Mehr
  Informationen findest du in der
  <link linkend="vidix-nvidia">nVidia-VIDIX</link>-Sektion.
</para>
</sect2>


<sect2 id="ati">
<title>ATI-Karten</title>

<para>
  Die <ulink url="http://gatos.sf.net">GATOS-Treiber</ulink>, die du
  einsetzen solltest, sofern du keine Rage128- oder Radeon-Karte hast,
  haben per Voreinstellung VSYNC angeschaltet. Dies bedeutet, dass
  die Decodiergeschwindigkeit (!) zur Bildwiederholrate des Monitors
  synchronisiert wird. Wenn dir die Wiedergabe langsam vorkommt, dann
  versuche, irgendwie VSYNC abzuschalten, oder setze die Bildwiederholrate
  des Monitors auf n * (fps des Films) Hz.
</para>

<para>
  Radeon VE - wenn du X benötigst, verwende XFree86 4.2.0 oder höher für
  diese Karte. Außerdem gibt es keine Unterstützung für den TV-Ausgang.
  Natürlich bekommst du mit <application>MPlayer</application>
  <emphasis role="bold">Hardware-beschleunigte</emphasis> Wiedergabe, das
  ganze wahlweise <emphasis role="bold">mit oder ohne TV-Ausgang</emphasis>,
  und es werden dabei nicht einmal weitere Bibliotheken oder X selber benötigt.
  Lies dazu die <link linkend="vidix">VIDIX-Sektion</link>.
</para>
</sect2>


<sect2 id="neomagic">
<title>NeoMagic-Karten</title>

<para>
  Diese Chips befinden sich in vielen Laptops. Du musst XFree86 4.3.0 oder
  höher oder andernfalls die
  <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/">Xv-fähigen
  Treiber</ulink> von Stefan Seyfried verwenden.
  Wähle einfach einen, der zu deiner XFree86-Version passt.
</para>

<para>
  XFree86 4.3.0 beinhaltet die Unterstützung für Xv, Bohdan Horst schickte jetzt
  einen kleinen
  <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/neo_driver.patch">Patch</ulink>
  auf die XFree86-Quellen, der Framebuffer-Operationen (daher XVideo)
  bis auf das Vierfache beschleunigt. Der Patch wurde in das XFree86-CVS
  eingebunden und sollte im nächsten Release nach 4.3.0 vorhanden sein.
</para>

<para>
  Um die Wiedergabe von Video in DVD-Auflösung zu ermöglichen,
  ändere deine XF86Config wie folgt:
<programlisting>
Section "Device"
    [...]
    Driver "neomagic"
    <emphasis>Option "OverlayMem" "829440"</emphasis>
    [...]
EndSection<!--
--></programlisting>
</para>
</sect2>


<sect2 id="trident">
<title>Trident-Karten</title>
<para>
  Wenn du Xv mit einer Trident-Grafikkarte benutzen willst, dann installiere
  XFree86 4.2.0, sofern Xv nicht schon mit 4.1.0 funktioniert. Version 4.2.0
  enthält Unterstützung für Xv im Vollbild für Cyberblade XP-Karten.
</para>

<para>
  Alternativ enthält <application>MPlayer</application> einen
  <link linkend="vidix">VIDIX</link>-Treiber für the Cyberblade/i1-Karten.
</para>

</sect2>


<sect2 id="kyro">
<title>Kyro/PowerVR-Karten</title>
<para>
  Wenn du Xv mit einer Kyro-basierten Karte (wie z.B. der Hercules Prophet 4000XT)
  verwenden möchstest, dann solltest du die Treiber von der
  <ulink url="http://www.powervr.com/">PowerVR-Seite</ulink> herunterladen.
</para>
</sect2>
</sect1>

<!-- ********** -->

<sect1 id="dga">
<title>DGA</title>

<formalpara>
<title>PRÄAMBEL</title>
<para>
  Dieser Abschnitt versucht, in wenigen Worten zu beschreiben, was DGA
  generell ist und was der DGA-Videotreiber in <application>MPlayer</application>
  erreichen kann, und was nicht.
</para>
</formalpara>

<formalpara>
<title>WAS IST DGA?</title>
<para>
  <acronym>DGA</acronym> ist die Abkürzung für
  <emphasis>Direct Graphics Access</emphasis> (direkter Zugriff auf die
  Grafikhardware) und gibt Programmen die Möglichkeit, unter Umgehung
  des X-Servers direkt den Framebuffer der Grafikkarte zu verändern.
  Technisch gesehen wird das dadurch realisiert, dass der
  Framebuffer-Speicher in den virtuellen Adressraum des jeweiligen Prozesses
  abgebildet wird. Das wird vom Kernel aber nur dann zugelassen, wenn der
  Prozess Superuserprivilegien besitzt. Dazu musst du dich entweder als
  <systemitem class="username">root</systemitem> anmelden oder das SUID-bit
  des <application>MPlayer</application>-Binaries setzen (was
  <emphasis role="bold">nicht empfohlen wird</emphasis>).
</para>
</formalpara>
<para>
  Von DGA gibt es zwei Versionen: DGA1 kommt mit XFree 3.x.x, und DGA2
  wurde mit XFree 4.0.1 eingeführt.
</para>

<para>
  DGA1 bietet nur den oben beschriebenen Zugriff auf den Framebuffer. Die
  Umschaltung des Videomodus klappt nur mit der XVidMode-Erweiterung.
</para>

<para>
  DGA2 beinhaltet die Features der XVidMode-Erweiterung und erlaubt
  außerdem, die Farbtiefe zu ändern. Damit kannst du also auf 32bit
  Farbtiefe umschalten, auch wenn der X-Server gerade mit 15bit Farbtiefe
  läuft und umgekehrt.
</para>

<para>
  DGA hat aber auch ein paar Nachteile. Die Funktionsweise scheint ein wenig
  von der Grafikkarte und der Implementierung des Grafikkartentreibers
  im X-Server abhängig zu sein, der diesen Chip kontrolliert.
  Es fuktioniert also nicht auf jedem System...
</para>

<formalpara>
<title>DGA-UNTERSTÜTZUNG FÜR MPLAYER INSTALLIEREN</title>

<para>
  Stelle als erstes sicher, dass X die DGA-Erweiterung lädt. Schau
  in <filename>/var/log/XFree86.0.log</filename> nach:

<programlisting>(II) Loading extension XFree86-DGA</programlisting>

  Wie du siehst, ist XFree86 4.0.x oder neuer
  <emphasis role="bold">sehr zu empfehlen</emphasis>!
  <application>MPlayer</application>s DGA-Treiber wird von
  <filename>./configure</filename> automatisch erkannt. Alternativ
  kannst du seine Compilierung mit <option>--enable-dga</option> erzwingen.
</para>
</formalpara>

<para>
  Falls der Treiber nicht zu einer kleineren Auflösung wechseln
  konnte, dann experimentiere mit den Optionen <option>-vm</option> (nur bei
  X 3.3.x), <option>-fs</option>, <option>-bpp</option>,
  <option>-zoom</option> herum, um einen Videomodus zu finden,
  in den der Film reinpasst. Momentan gibt es keinen Konverter :(
</para>

<para>
  Werde <systemitem class="username">root</systemitem>.
  DGA braucht <systemitem class="username">root</systemitem>-Privilegien,
  um direkt in den Grafikspeicher zu schreiben. Wenn du MPlayer als
  normaler Nutzer starten möchtest, dann installiere
  <application>MPlayer</application> mit dem SUID-Bit:

<screen>
chown root <replaceable>/usr/local/bin/mplayer</replaceable>
chmod 750 <replaceable>/usr/local/bin/mplayer</replaceable>
chmod +s <replaceable>/usr/local/bin/mplayer</replaceable>
</screen>

  Jetzt funktioniert es auch als normaler Benutzer.
</para>

<caution>
<title>Warnung: Sicherheitsrisiko!</title>
<para>
  Dieses ist ein <emphasis role="bold">großes</emphasis> Sicherheitsloch.
  Tu das <emphasis role="bold">niemals</emphasis> auf einem Server oder
  auf einem Computer, auf den auch andere Leute Zugriff haben, da sie durch einen
  SUID-<systemitem class="username">root</systemitem>-<application>MPlayer</application>
  <systemitem class="username">root</systemitem>-Privilegien erlangen können.
</para>
</caution>

<para>
  Benutze jetzt die Option <option>-vo dga</option>, und ab geht's (hoffe ich
  zumindest :))! Du solltest auch ausprobieren, ob bei dir die Option
  <option>-vo sdl:dga</option> funktioniert. Sie ist viel schneller.
</para>


<formalpara id="dga-modelines">
<title>ÄNDERN DER AUFLÖSUNG</title>

<para>
  Der DGA-Treiber ermöglicht es, die Auflösung des Output-Signals zu ändern.
  Damit entfällt die Notwendigkeit der (langsamen) Softwareskalierung und
  bietet gleichzeitig ein Vollbild. Idealerweise würde DGA in die gleiche
  Auflösung schalten, die das Video (natürlich unter Beachtung des
  Höhen-/Breitenverhältnisses) hat, aber der X-Server lässt nur
  Auflösungen zu, die vorher in der <filename>/etc/X11/XF86Config</filename> bzw.
  <filename>/etc/X11/XF86Config-4</filename> definiert wurden, bezüglich XFree 4.X.X.
  Diese werden durch sogenannte Modelines festgelegt und hängen von den Fähigkeiten
  deiner Grafikhardware ab. Der X-Server liest diese Konfigurationsdatei beim
  Start ein und deaktiviert alle Modelines, die sich nicht mit deiner Hardware
  vertragen. Du kannst die überlebenden Modelines anhand der X11-Logdatei
  herausfinden (normalerweise <filename>/var/log/XFree86.0.log</filename>).
</para>
</formalpara>

<para>
  Diese Einträge funktionieren mit einem Riva128-Chip und dem
  nv.o-X-Server-Treibermodul.
</para>


<para><programlisting>
Section "Modes"
  Identifier "Modes[0]"
  Modeline "800x600"  40     800 840 968 1056  600 601 605 628
  Modeline "712x600"  35.0   712 740 850 900   400 410 412 425
  Modeline "640x480"  25.175 640 664 760 800   480 491 493 525
  Modeline "400x300"  20     400 416 480 528   300 301 303 314 Doublescan
  Modeline "352x288"  25.10  352 368 416 432   288 296 290 310
  Modeline "352x240"  15.750 352 368 416 432   240 244 246 262 Doublescan
  Modeline "320x240"  12.588 320 336 384 400   240 245 246 262 Doublescan
EndSection
</programlisting></para>


<formalpara>
<title>DGA &amp; MPLAYER</title>
<para>
  DGA wird bei <application>MPlayer</application> an zwei Stellen benutzt:
  beim SDL-Treiber mit (<option>-vo sdl:driver=dga</option>) oder beim
  DGA-Treiber selbst (<option>-vo dga</option>).
  Das oben gesagte gilt für beide Treiber. In den folgenden Abschnitten
  erkläre ich, wie der DGA-Treiber von <application>MPlayer</application>
  selber arbeitet.
</para>
</formalpara>


<formalpara>
<title>FEATURES DES DGA-TREIBERS</title>

<para>
  Der DGA-Treiber wird durch die Option <option>-vo dga</option> aktiviert.
  Sein Standardverhalten sieht vor, dass er in die Auflösung schaltet, die
  der Videoauflösung am nächsten kommt. Der Treiber ignoriert absichtlich
  die Optionen <option>-vm</option> (Videomodusumschaltung aktivieren) und
  <option>-fs</option> (Vollbildmodus erzwingen) - er versucht immer, so viel
  Bildfläche wie möglich durch eine Änderung der Auflösung zu bedecken.
  Dadurch wird nicht ein einziger weiterer CPU-Takt für die Skalierung des
  Bildes verwendet. Wenn du mit dem Modus nicht zufrieden bist, den der Treiber
  gewählt hat, dann kannst du ihn zwingen, denjenigen Modus zu
  wählen, der am besten zu dem mit den Optionen <option>-x</option> und
  <option>-y</option> angegebenen Werten passt. Die Option <option>-v</option>
  veranlasst den DGA-Treiber, neben einigen anderen Dingen auch alle von deiner
  <filename>XF86Config</filename>-Datei unterstützen Videomodi aufzulisten.
  Wenn DGA2 verwendet wird, dann kannst du mit der Option <option>-bpp</option> die
  Verwendung einer bestimmten Farbtiefe erzwingen. Gültige Werte sind 15,
  16, 24 und 32. Es hängt dann von deiner Hardware ab, ob der Modus nativ
  unterstützt wird oder ob eine (möglicherweise langsame)
  Konvertierung stattfindet.
</para>
</formalpara>
<para>
  Wenn du Glück hast und dir genug unbenutzter Grafikspeicher zur
  Verfügung steht, um ein komplettes Bild aufzunehmen, dann wird der
  DGA-Treiber Doppelpufferung verwenden, was zu einer regelmäßigeren
  Wiedergabe führt. Der DGA-Treiber wird dir mitteilen, ob Doppelpufferung
  angeschaltet ist oder nicht.
</para>

<para>
  Doppelpufferung bedeutet, dass das nächste Bild deines Videos bereits
  an einer anderen Stelle im Grafikspeicher aufgebaut wird, während das
  aktuelle Bild angezeigt wird. Ist das nächste Bild fertig, so wird
  dem Grafikchip nur noch mitgeteilt, wo er das neue Bild im Speicher finden
  kann. Somit holt sich der Chip seine Daten einfach von dort. In der
  Zwischenzeit wird der andere, jetzt unbenutze Puffer wieder mit neuen
  Videodaten gefüllt.
</para>

<para>
  Doppelpufferung kann mit der Option <option>-double</option> aktiviert und mit
  <option>-nodouble</option> deaktiviert werden. Momentan ist die Doppelpufferung
  per Voreinstellung deaktiviert. Wird der DGA-Treiber verwendet,
  dann funktioniert das Onscreen-Display (ODS) nur dann, wenn auch die
  Doppelpufferung aktiviert ist. Andererseits kann die Doppelpufferung auch
  einen großen Geschwindigkeitseinbruch hervorrufen, was stark von
  der DGA-Implementierung der Treiber für deine Hardware abhängt (auf
  meinem K6-II+ 525 benötigt Doppelpufferung weitere 20% CPU-Zeit!).
</para>


<formalpara>
<title>PUNKTE BEZÜGLICH DER GESCHWINDIGKEIT</title>

<para>
  Generell gesehen sollte der Zugriff auf den DGA-Framebuffer genauso
  schnell sein wie der X11-Treiber, wobei man zusätzlich noch ein Vollbild
  erhält. Die prozentualen Geschwindigkeitswerte, die <application>MPlayer</application>
  ausgibt, müssen mit Vorsicht genossen werden, da sie z.B. beim X11-Treiber
  nicht die Zeit beinhalten, die der X-Server tatsächlich zum
  Anzeigen des Bildes benötigt. Klemm ein Terminal an deinen seriellen
  Port und starte <command>top</command>, wenn du wissen willst, wie's wirklich mit
  der Geschwindigkeit aussieht.
</para>
</formalpara>

<para>
  Allgemein betrachtet hängt die Geschwindigkeitsverbesserung von DGA
  gegenüber dem 'normalen' X11-Treiber sehr von deiner Grafikkarte und
  davon ab, wie gut das X-Servermodul optimiert ist.
</para>

<para>
  Wenn du ein langsames System hast, dann benutz besser eine Farbtiefe von
  15 oder 16bit, da sie nur die halbe Bandbreite des 32bit-Farbmodus
  benötigen.
</para>

<para>
  Einge gute Idee ist auch die Verwendung von 24bit Farbtiefe, selbst dann,
  wenn deine Grafikkarte nativ nur 32bit unterstützt, da bei 24bit 25%
  weniger Daten im Vergleich zum 32/32-Modus über den Bus transferiert
  werden müssen.
</para>

<para>
  Ich habe schon gesehen, wie einige AVI-Dateien auf einem Pentium MMX 266
  wiedergegeben werden konnten. AMD K6-2-CPUs werden ab ca. 400 MHz oder
  höher funktionieren.
</para>


<formalpara>
<title>BEKANNTE FEHLER</title>

<para>
  Die Entwickler von XFree sagen selbst, dass DGA ein ganz schönes
  Monstrum ist. Sie raten eher davon ab, es zu benutzen, da seine
  Implementierung in einige Chipset-Treiber für XFree nicht immer
  ganz fehlerfrei war.
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  Bei der Kombination aus XFree 4.0.3 und dem
  <filename>nv.o</filename>-Treiber gibt es einen Fehler, der zu
  merkwürdigen Farben führt.
</para></listitem>
<listitem><para>
  Die ATI-Treiber müssen den Videomodus mehrmals zurückstellen,
  nachdem der DGA-Modus verlassen wurde.
  </para></listitem>
<listitem><para>
  Einige Treiber schaffen es manchmal einfach nicht, in die vorherige
  Auflösung zurückzuschalten. Benutze in solch einem Fall
  <keycombo><keycap>Strg</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo> und
  <keycombo><keycap>Strg</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>,
  um manuell die Auflösung zu ändern.
</para></listitem>
<listitem><para>
  Einige Treiber zeigen einfach nur merkwürdige Farben an.
</para></listitem>
<listitem><para>
  Manche Treiber lügen, was die von ihnen in den Prozessorspeicher
  eingeblendete Menge Grafikspeicher anbelangt, weswegen vo_dga
  nicht die Doppelpufferung verwendet (SIS?).
</para></listitem>
<listitem><para>
  Einige Treiber schaffen es nicht einmal, auch nur einen einzigen
  gültigen Grafikmodus bereitzustellen. In solchen Fällen
  gibt der DGA-Treiber schwachsinnige Modi wie z.B. 100000x100000 oder
  so ähnlich aus.
</para></listitem>
<listitem><para>
  Das OSD funktioniert nur, wenn auch die Doppelpufferung aktiviert
  ist (sonst flimmert es).
</para></listitem>
</itemizedlist>

</sect1>
<!--</sect1>-->

<!-- ********** -->

<sect1 id="sdl">
<title>SDL</title>

<para>
  <acronym>SDL</acronym> (Simple Directmedia Layer, einfacher Layer für
  den direkten Zugriff auf Mediengeräte) bietet grundsätzlich eine einheitliche
  Schnittstelle zu Audio- und Videogeräten. Programme, die SDL
  benutzen, kennen nur SDL und brauchen nichts darüber zu wissen, welche
  Video- oder Audiotreiber SDL tatsächlich benutzt. So kann z.B. eine
  Doom-Portierung mit SDL die Svgalib, aalib, X11, fbdev und andere Treiber
  nutzen. Dazu musst du z.B. nur den Videotreiber angeben, indem du die
  Umgebungsvariable <envar>SDL_VIDEODRIVER</envar> setzt.
  So lautet zumindest die Theorie.
</para>

<para>
  Bei <application>MPlayer</application> benutzten wir damals die
  Softwareskalierungsroutinen der X11-Treiber von SDL bei Grafikkarten/-treibern,
  die keine Unterstützung für XVideo hatten, bis wir unsere eigenen schrieben,
  die schneller und hübscher waren. Wir benutzten damals außerdem SDLs
  aalib-Ausgabe. Jetzt haben wir unsere eigenen, was wesentlich komfortabler
  ist. Auch davon haben wir selber eine komfortablere Version geschrieben.
  SDLs DGA-Code war besser als unserer - zumindest bis vor kurzem.
  Verstehst du, worauf ich hinauswill? :)
</para>

<para>
  SDL ist auch bei einigen fehlerbehafteten Treibern/Karten nützlich,
  wenn das Video ruckelig abgespielt wird (und es nicht an einem langsamen
  System liegt), oder wenn der Ton hinterherhinkt.
</para>

<para>
  Die SDL-Videoausgabe unterstützt die Anzeige von Untertiteln unterhalb
  des Films auf den schwarzen Balken (sofern diese vorhanden sind).
</para>

</sect1>


<sect1 id="svgalib">
<title>SVGAlib</title>

<formalpara>
<title>INSTALLATION</title>
<para>
  Du musst zuerst die svgalib und die dazugehörigen Entwicklerpakete
  installieren, bevor du <application>MPlayer</application> compilierst,
  da er sonst die Svgalib nicht automatisch findet und den Treiber dazu
  nicht compiliert (das kann aber trotzdem erzwungen werden). Vergiss auch
  nicht, in <filename>/etc/vga/libvga.config</filename> richtige Werte
  für deine Grafikkarte und deinen Monitor anzugeben.
</para>
</formalpara>

<note>
<para>
  Verwende nicht die Option <option>-fs</option>, da sie die Benutzung des
  Softwareskalierers erzwingt und das ganze dann langsam wird. Wenn du diese
  Option wirklich brauchst, dann verwende auch <option>-sws 4</option>,
  welche zwar schlechte Qualität produziert, dafür aber auch ein wenig
  schneller ist.
</para>
</note>

<formalpara><title>EGA(4bpp)-UNTERSTÜTZUNG</title>
<para>
  SVGAlib beinhaltet die EGAlib, und MPlayer kann damit jeden Film in
  16 Farben bei folgenden Modi anzeigen:
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  EGA-Karte mit EGA-Monitor: 320x200x4bpp, 640x200x4bpp, 640x350x4bpp
</para></listitem>
<listitem><para>
  EGA-Karte mit CGA-Monitor: 320x200x4bpp, 640x200x4bpp
</para></listitem>
</itemizedlist>

<para>
  Der bpp-Wert (Bits pro Pixel) muss von Hand auf vier gesetzt werden:
  <option>-bpp 4</option>
</para>

<para>
  Die Auflösung des Films muss wahrscheinlich verkleinert werden, damit
  er in den EGA-Modus reinpasst:
  <screen>-vf scale=640:350</screen>
  oder
  <screen>-vf scale=320:200</screen>
</para>

<para>
  Dafür brauchen wir eine schnelle, aber schlechte Qualität
  produzierende Skalierroutine:
  <screen>-sws 4</screen>
</para>

<para>
  Eventuell muss die automatische Anpassung des
  Höhen-/Breitenverhältnisses ausgeschaltet werden:
  <screen>-noaspect</screen>
</para>

<note><para>
  Die besten Ergebnisse bei EGA-Bildschirmen erhält man meiner Erfahrung nach,
  wenn man die Helligkeit ein wenig verringert:
  <option>-vf eq=-20:0</option>. Ich musste auch die Audiosamplerate reduzieren,
  weil bei 44KHz der Sound nicht richtig funktionierte:
  <option>-srate 22050</option>.
</para></note>

<para>
  Du kannst das OSD und Untertitel mit dem <option>expand</option>-Filter
  aktivieren. Die Manpage enthält die exakten Parameter.
</para>
</sect1>


<sect1 id="fbdev">
<title>Framebuffer-Ausgabe (FBdev)</title>

<para>
  <filename>./configure</filename> erkennt automatisch, ob es den Framebuffertreiber
  (fbdev) compilieren soll oder nicht. Lies die Framebufferdokumentation in den
  Kernelquellen (<filename>Documentation/fb/*</filename>); dort stehen mehr
  Informationen.
</para>

<para>
  Falls deine Karte den VBE 2.0-Standard nicht unterstützt (wie z.B.
  ältere ISA-/PCI-Karten wie die S3 Trio64) oder nur VBE 1.2 und
  älter unterstützt: Tja, dann kannst du immer noch VESAfb benutzen,
  benötigst aber den SciTech Display Doctor (ehemals UniVBE), der vor dem
  Booten von Linux geladen werden muss. Nimm dazu eine DOS-Bootdiskette oder
  was auch immer. Vergiss nicht, deine Kopie von UniVBE zu registrieren ;).
</para>

<para>
  Die Fbdev-Ausgabe kennt neben den üblichen Parametern noch einige andere:
</para>

<variablelist>
<varlistentry>
  <term><option>-fb</option></term>
  <listitem><para>
  Gibt das zu verwendende Framebuffergerät an (Standard: <filename>/dev/fb0</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmode</option></term>
  <listitem><para>
  Gibt zu benutzenden Modusnamen an (wie sie in <filename>/etc/fb.modes</filename> stehen)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmodeconfig</option></term>
  <listitem><para>
  Konfigurationsdatei für die Modi (Standard: <filename>/etc/fb.modes</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-monitor-hfreq</option></term>
  <term><option>-monitor-vfreq</option></term>
  <term><option>-monitor-dotclock</option></term>
  <listitem><para>
  <emphasis role="bold">Wichtige</emphasis> Werte, schau dir die
  <filename>example.conf</filename> an.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
  Wenn du in einen speziellen Modus wechseln willst, dann benutze
<screen>
mplayer -vm -fbmode <replaceable>Modusname</replaceable> <replaceable>Dateiname</replaceable>
</screen>
</para>

<itemizedlist>
<listitem><para>
  <option>-vm</option> ohne weitere Optionen wird den am besten passenden Modus
  aus <filename>/etc/fb.modes</filename> auswählen. Kann auch zusammen mit
  <option>-x</option> und <option>-y</option> benutzt werden. Die Option
  <option>-flip</option> wird nur dann unterstützt, wenn das Pixelformat des
  Films mit dem Pixelformat des Videomodus übereinstimmt. Pass auf den
  bpp-Wert auf. fbdev wird den aktuell eingestellten benutzen, wenn du
  nicht mit <option>-bpp</option> einen bestimmten angibst.
</para></listitem>
<listitem><para>
  Die Option <option>-zoom</option> wird nicht unterstützt (Softwareskalierung
  ist langsam, verwende <option>-vf scale</option>). Du kannst keine Modi mit
  8bpp oder weniger benutzen.
</para></listitem>
<listitem><para>
  Wahrscheinlich wirst du den Cursor (<screen>echo -e '\033[?25l'</screen>
  oder <screen>setterm -cursor off</screen>) und den Bildschirmschoner
  (<option>setterm -blank 0</option>) deaktivieren wollen. Um den Cursor wieder
  zu aktivieren: <screen>echo -e '\033[?25h'</screen> oder
  <screen>setterm -cursor on</screen>.
  </para></listitem>
</itemizedlist>

<note>
<para>
  fbdev kann den Videomodus in Verbindung mit dem VESA-Framebuffer
  <emphasis>nicht</emphasis> ändern. Frag auch nicht danach - das ist
  keine Einschränkung seitens <application>MPlayer</application>.
</para>
</note>
</sect1>


<sect1 id="mga_vid">
<title>Matrox-Framebuffer (mga_vid)</title>

<para>
  <systemitem>mga_vid</systemitem> ist eine Kombination aus einem Videoausgabetreiber
  und Linux-Kernelmodul, das die Matrox G200/G400/G450/G550 Scaler-/Overlay-Einheit
  verwendet, um YUV->RGB-Farbraumkonvertierungen und beliebige Videoskalierungen durchzuführen.
  <systemitem>mga_vid</systemitem> bietet Unterstützung für Hardware-VSYNC und Dreifachpufferung.
  Dieser Treiber funktioniert sowohl unter der Framebufferconsole als auch unter X,
  jedoch nur mit Linux 2.4.x.
</para>

<para>
  Für eine Version für Linux 2.6.x gehe auf <ulink url="http://attila.kinali.ch/mga/"/>.
</para>

<procedure>
<title>Installation:</title>
<step><para>
  Um den Treiber benutzen zu können, musst du erstmal <filename>mga_vid.o</filename>
  compilieren:
  <screen>
cd drivers
make<!--
--></screen>
  </para></step>
<step><para>
    Führe dann (als <systemitem class="username">root</systemitem>) folgenden Befehl aus:
    <screen>make install</screen>
    Dies sollte das Modul installieren und das Device-Node für dich erstellen.
    Lade den Treiber mit
  <screen>insmod mga_vid.o</screen>
  </para></step>
<step><para>
  Du solltest sicherstellen, dass das Modul die Größe des
  Grafikkartenspeichers korrekt ermittelt hat. Benutze dazu
  <command>dmesg</command>. Wenn die Angabe nicht stimmt, dann gib nach
  <command>rmmod mga_vid</command> mit Hilfe der Option
  <option>mga_ram_size</option> die Größe explizit an:
  <screen>insmod mga_vid.o mga_ram_size=16</screen>
</para></step>
<step><para>
  Wenn das Modul automatisch geladen und entladen werden soll, sobald
  es benötigt wird, so füge die folgende Zeile in der Datei
  <filename>/etc/modules.conf</filename> ein:

  <programlisting>alias char-major-178 mga_vid</programlisting>
  </para></step>
<step><para>
  Schließlich musst du noch <application>MPlayer</application> (erneut) compilieren.
  <command>configure</command> wird automatisch <filename>/dev/mga_vid</filename>
  finden und den 'mga'-Treiber erstellen. Die entsprechende Option für
  <application>MPlayer</application> lautet <option>-vo mga</option>, wenn du mit
  dem matroxfb auf der Console arbeitest, oder <option>-vo xmga</option>, wenn du
  unter XFree 3.x.x oder XFree 4.x.x arbeitest.
  </para></step>
</procedure>

<para>
  Der mga_vid-Treiber kooperiert mit Xv.
</para>

<para>
  Das Gerät <filename>/dev/mga_vid</filename> kann z.B. mit
  <screen>cat /dev/mga_vid</screen>
  ausgelesen werden, um ein paar Informationen über
  den aktuellen Zustand zu erhalten. Die Helligkeit kann zusätzlich mit z.B.
  <screen>echo "brightness=120" &gt; /dev/mga_vid</screen>
  angepasst werden.
</para>

<para>
  Es gibt ein Testprogramm namens <command>mga_vid_test</command> im selben Verzeichnis.
  Es sollte 256x256 große Bilder auf den Schirm zeichnen, wenn alles gut funktioniert.
</para>

</sect1>


<sect1 id="tdfxfb" xreflabel="3Dfx YUV support (tdfxfb)">
<title>3dfx-YUV-Unterstützung (tdfxfb)</title>
<para>
  Dieser Treiber verwendet den tdfx-Framebuffertreiber des Kernels, um Filme
  mit YUV-Beschleunigung abzuspielen. Deswegen benötigst du einen Kernel
  mit tdfxfb-Unterstütztung. Danach musst du MPlayer compilieren mit
  <screen>./configure --enable-tdfxfb</screen>
</para>
</sect1>

<sect1 id="tdfx_vid">
<title>tdfx_vid</title>

<para>
  Dies ist eine Kombination aus Linux-Kernelmodul und einem Videoausgabetreiber,
  ähnlich <link linkend="mga_vid">mga_vid</link>.
  Du wirst einen 2.4.x-Kernel mit dem <systemitem>agpgart</systemitem>-Treiber
  brauchen, denn <systemitem>tdfx_vid</systemitem> verwendet AGP.
  Übergib <option>--enable-tdfxfb</option> an <command>configure</command>, um
  den Videoausgabetreiber zu erstellen, und erzeuge das Kernelmodul nach folgenden
  Anweisungen.
</para>

<procedure>
<title>Das tdfx_vid.o-Kernelmodul installieren:</title>
<step>
  <para>
    Compiliere <filename>tdfx_vid.o</filename>:
<screen>
cd drivers
make</screen>
  </para>
</step>
<step>
  <para>
    Führe dann (als <systemitem class="username">root</systemitem>) folgenden Befehl aus:
    <screen>make install</screen>
    Dies sollte das Modul installieren und das Device-Node für dich erstellen.
    Lade den Treiber mit <screen>insmod tdfx_vid.o</screen>
  </para>
</step>
<step>
  <para>
    Um es automatisch nach Bedarf zu laden bzw. zu entfernen, füge folgende Zeile
    am Ende von <filename>/etc/modules.conf</filename> hinzu:

    <programlisting>alias char-major-178 tdfx_vid</programlisting>
  </para>
</step>
</procedure>

<para>
  Es gibt ein Testprogramm namens <command>tdfx_vid_test</command> im selben Verzeichnis.
  Es sollte nützliche Informationen ausgeben, wenn alles gut funktioniert.
</para>
</sect1>

<!-- ********** -->


<sect1 id="opengl">
<title>OpenGL-Ausgabe</title>

<para>
  <application>MPlayer</application> unterstützt die Ausgabe von Filmen via
  OpenGL. Wenn aber deine Plattform/dein Treiber Xv unterstützt (was bei PCs
  mit Linux praktisch immer der Fall ist), dann benutze besser Xv, da die
  OpenGL-Geschwindigkeit deutlich geringer als die von Xv ist. Wenn du dagegen
  eine X11-Implementierung hast, die Xv nicht unterstützt, so mag OpenGL eine
  brauchbare Alternative sein.
</para>

<para>
  Leider unterstützen nicht alle Treiber die erforderlichen Features.
  Die Utah-GLX-Treiber (für XFree86 3.3.6) unterstützen sie für
  alle Karten. Auf <ulink url="http://utah-glx.sf.net"/>
  findest du Details zur Installation.
</para>

<para>
  XFree86(DRI) 4.0.3 oder neuer unterstützt OpenGL mit Matrox- und
  Radeon-Karten, 4.2.0 und neuer unterstützen zusätzlich Rage128.
  Auf <ulink url="http://dri.sf.net"/> findest du Details zur Installation.
</para>

<para>
  Ein Hinweis von einem unserer User: der GL-Video-Output kann dazu verwendet
  werden, einen vertikal synchronisierten TV-Output zu bekommen.
  Du musst dann eine Umgebungsvariable setzen (zumindest bei nVidia):
</para>

<para>
<command>export __GL_SYNC_TO_VBLANK=1</command>
</para>

</sect1>


<sect1 id="aalib">
<title>AAlib - Ausgabe im Textmodus</title>

<para>
  AAlib ist eine Bilbiothek, mit der Grafiken im Textmodus angezeigt
  werden, wobei ein mächtiger Textmodusrenderer angewandt wird. Es gibt SEHR
  viele Programme, die das bereits unterstützen, wie z.B. Doom, Quake etc.
  <application>MPlayer</application> enthält einen sehr gut brauchbaren
  Treiber für AAlib. Wenn <filename>./configure</filename> feststellt,
  dass die AAlib installiert ist, dann wird anschließend der AAlib-Treiber
  gebaut.
</para>

<para>
  Du kannst diese Tasten im AA-Fenster benutzen, um die Render-Optionen
  zu beeinflussen:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Taste</entry><entry>Aktion</entry></row>
</thead>
<tbody>
<row><entry><keycap>1</keycap></entry><entry>
  Kontrast verringern
  </entry></row>
<row><entry><keycap>2</keycap></entry><entry>
  Kontrast erhöhen
  </entry></row>
<row><entry><keycap>3</keycap></entry><entry>
  Helligkeit verringern
  </entry></row>
<row><entry><keycap>4</keycap></entry><entry>
  Helligkeit erhöhen
  </entry></row>
<row><entry><keycap>5</keycap></entry><entry>
  Schnelles Rendern an-/ausschalten
  </entry></row>
<row><entry><keycap>6</keycap></entry><entry>
  Wahl des Farbverteilungsmodus (keiner, Fehlerverteilung, Floyd Steinberg)
  </entry></row>
<row><entry><keycap>7</keycap></entry><entry>
  Bild invertieren
  </entry></row>
<row><entry><keycap>8</keycap></entry><entry>
  schaltet zwischen den <application>MPlayer</application>- und den AA-Tastenbelegungen um
  </entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title>Die folgenden Kommandozeilenparamter stehen zur Verfügungung:</title>
<varlistentry>
  <term><option>-aaosdcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
  OSD-Farbe ändern
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aasubcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
  Farbe der Untertitel ändern,
  </para><para>
    <replaceable>V</replaceable> kann folgende Werte annehmen:
    <literal>0</literal> (normal),
    <literal>1</literal> (dunkel),
    <literal>2</literal> (fett),
    <literal>3</literal> (fette Schrift),
    <literal>4</literal> (negative Farben),
    <literal>5</literal> (spezial).
    </para></listitem>
</varlistentry>
</variablelist>

<variablelist>
  <title>Die AAlib selbst bietet ebenfalls eine große Anzahl von Optionen.
  Hier sind die wichtigsten:</title>
<varlistentry>
  <term><option>-aadriver</option></term>
  <listitem><para>
  Wählt den empfohlenen aa-Treiber (X11, curses, Linux).
    </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaextended</option></term>
  <listitem><para>
  Benutze alle 256 Zeichen.
    </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaeight</option></term>
  <listitem><para>
  Benutze 8 Bit ASCII-Zeichen.
    </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aahelp</option></term>
  <listitem><para>
  Gib alle aalib-Optionen aus.
    </para></listitem>
</varlistentry>
</variablelist>

<note>
<para>
  Das Rendern ist sehr CPU-intensiv, vor allem, wenn AA unter X
  benutzt wird. AAlib braucht auf einer Nicht-Framebuffer-Console am
  wenigstens CPU-Zeit. Benutze SVGATextMode, um einen möglichst
  großen Textmodus zu wählen, und genieß den Film! (Hercules-Karten
  als zweites Ausgabegerät rocken :)) (Aber IMHO kannst du die Option
  <option>-vf 1bpp</option> anwenden, um Grafiken auf hgafb zu bekommen :)
</para>
</note>

<para>
  Wenn dein Computer nicht schnell genug ist, um alle Frames anzuzeigen,
  dann benutze die Option <option>-framedrop</option>.
</para>

<para>
  Wenn du auf einem Terminal abspielst, dann erzielst du mit dem Linux-
  Treiber (<option>-aadriver linux</option>) bessere Ergebnisse als mit dem curses-
  Treiber. Allerdings benötigst du dafür auch Schreibrechte auf
  <filename>/dev/vcsa<replaceable>&lt;Terminal&gt;</replaceable></filename>.
  Das wird von aalib nicht automatisch festgestellt, aber vo_aa versucht, den
  besten Modus herauszufinden. Lies
  <ulink url="http://aa-project.sf.net/tune"/> für weitere Tuningtipps.
</para>
</sect1>


<sect1 id="caca">
<title><systemitem class="library">libcaca</systemitem> - Color ASCII Art-Bibliothek</title>

<para>
  Die Bibliothek
  <ulink url="http://sam.zoy.org/projects/libcaca/"><systemitem class="library">libcaca</systemitem></ulink>
  ist eine Grafik-Bibliothek, die Text anstatt Pixel ausgibt, sodass sie auf älteren
  Grafikkarten oder Text-Terminals läuft. Sie ist der bekannten Bibliothek
  <systemitem class="library">AAlib</systemitem> nicht unähnlich.
  <systemitem class="library">libcaca</systemitem> benötigt ein Terminal, um zu
  funktionieren, deshalb sollte sie auf allen Unix-Systemen (inklusive Mac OS X) funktionieren,
  wenn man entweder die <systemitem class="library">slang</systemitem>-Bibliothek oder die
  <systemitem class="library">ncurses</systemitem>-Bibliothek, unter DOS die
  <systemitem class="library">conio.h</systemitem>-Bibliothek und auf Windows-Systemen
  entweder <systemitem class="library">slang</systemitem> oder
  <systemitem class="library">ncurses</systemitem> (durch Cygwin-Emulation) oder
  <systemitem class="library">conio.h</systemitem> verwendet. Wenn
  <filename>./configure</filename> <systemitem class="library">libcaca</systemitem>
  entdeckt, wird der caca-Treiber gebaut.
</para>

<itemizedlist>
<title>Die Unterschiede zu <systemitem class="library">AAlib</systemitem> sind
  folgende:</title>
<listitem><para>
  16 verfügbare Farben für die Zeichenausgabe (256 Farbpaare)
 </para></listitem>
<listitem><para>
  Farbbild-Dithering
 </para></listitem>
</itemizedlist>

<itemizedlist>
<title>Aber <systemitem class="library">libcaca</systemitem> hat auch folgende
  Einschränkungen:</title>
<listitem><para>
   keine Unterstützung für Helligkeit, Kontrast, Gamma
  </para></listitem>
</itemizedlist>

<para>
  Du kannst diese Tasten im caca-Fenster benutzen, um die Render-Optionen
  zu beeinflussen:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Taste</entry><entry>Aktion</entry></row>
</thead>
<tbody>
<row><entry><keycap>d</keycap></entry><entry>
  zwischen den Dithering-Methoden von
  <systemitem class="library">libcaca</systemitem> umschalten.
  </entry></row>
<row><entry><keycap>a</keycap></entry><entry>
  zwischen dem Antialiasing von <systemitem class="library">libcaca</systemitem>
  umschalten.
  </entry></row>
<row><entry><keycap>b</keycap></entry><entry>
  zwischen dem Hintergrund <systemitem class="library">libcaca</systemitem>
  umschalten.
  </entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title><systemitem class="library">libcaca</systemitem> sucht auch nach
  bestimmten Umgebungsvariablen:</title>
<varlistentry>
  <term><option>CACA_DRIVER</option></term>
  <listitem><para>
  Setze den empfohlenen caca-Treiber. z.B. ncurses, slang, x11.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_GEOMETRY (nur bei X11)</option></term>
  <listitem><para>
  Spezifiziere die Anzahl der Spalten und Zeilen, z.B. 128x50.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_FONT (nur bei X11)</option></term>
  <listitem><para>
  Legt die zu verwendende Schrift fest, z.B. fixed, nexus.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
  Nimm die Option <option>-framedrop</option>, wenn dein Rechner nicht schnell
  genug für die Darstellung aller Frames ist.
</para>

</sect1>


<sect1 id="vesa">
<title>VESA-Ausgabe über das VESA-BIOS</title>

<para>
  Dieser Treiber ist vom Design her ein <emphasis role="bold">generischer Treiber</emphasis>
  für alle Grafikkarten, deren Bios VESA VBE 2.0 unterstützt. Ein weiterer
  Vorteil dieses Treibers liegt darin, dass er versucht, den TV-Ausgang anzuschalten.
  <citetitle>VESA BIOS EXTENSION (VBE) Version 3.0 Date: September 16, 1998</citetitle>
  (Seite 70) hat folgendes zu sagen:
</para>

<blockquote>
<formalpara><title>Designs für zwei Controller</title>
<para>
  VBE 3.0 unterstützt zwei Controller dadurch, dass angenommen wird,
  dass beide Controller vom gleichen OEM (Hardwarehersteller) stammen und
  unter Kontrolle desselben BIOS auf derselben Grafikkarte sitzen. Somit ist
  es möglich, die Tatsache, dass zwei Controller vorhanden sind, vor der
  Anwendung zu verbergen. Dies verhindert zwar, dass beide Controller
  unabhängig voneinander gesteuert werden, erlaubt andererseits aber,
  dass Anwendungen weiterhin problemlos funktionieren, die vor Erscheinen der
  VBE-3.0-Spezifikation geschrieben wurden. Die VBE-Funktion 00h (Auskunft
  über die Controller, Return Controller Information) gibt
  dementsprechend die kombinierten Informationen über beide Controller
  zurück, was auch eine kombinierte Liste der vorhandenen Grafikmodi
  einschließt. Sobald eine Anwendung einen Grafikmodus wählt, wird
  der entsprechende Controller aktiviert. Alle weiteren VBE-Funtkionen werden
  dann auf diesem Controller ausgeführt.
</para>
</formalpara>
</blockquote>

<para>
  Somit hast du also eine Chance, den TV-Ausgang mit diesem Treiber zum
  Laufen zu bringen.
  (Ich vermute, dass der TV-Ausgang normalerweise auf einer separaten
  Grafikkarte oder zumindest ein separater Ausgang ist.)
</para>

<itemizedlist spacing="compact">
<title>VORTEILE</title>
<listitem><para>
  Du hast die Möglichkeit, selbst dann Filme anzusehen, wenn
  <emphasis role="bold">Linux nichts von deiner Grafikhardware weiß</emphasis>.
</para></listitem>
<listitem><para>
  Du musst keine einzige Grafikanwendung installiert haben (wie
  X11/XFree86, fbdev usw.). Dieser Treiber wird im
  <emphasis role="bold">Textmodus</emphasis>
  benutzt.
</para></listitem>
<listitem><para>
  Die Chancen stehen gut, dass der <emphasis role="bold">TV-Ausgang funktioniert</emphasis>.
  (Es läuft nachweislich zumindest auf ATI-Karten.)
</para></listitem>
<listitem><para>
  Dieser Treiber ruft die <function>int 10h</function>-Routine wirklich auf und ist
  dementsprechend kein Emulator - er ruft <emphasis role="bold">echte</emphasis>
  Funktionen des <emphasis>echten</emphasis> BIOS im <emphasis>Real</emphasis>-Modus
  auf (bzw. im vm68-Modus).
</para></listitem>
<listitem><para>
  Du kannst den Treiber zusammen mit VIDIX verwenden und erhältst
  dadurch gleichzeitig eine hardwarebeschleunigte Grafikanzeige
  <emphasis role="bold">und</emphasis> den TV-Ausgang! (für ATI-Karten empfohlen)
</para></listitem>
<listitem><para>
  Wenn du ein VESA-VBE-3.0+-BIOS hast und irgendwo die Optionen
  <option>monitor-hfreq</option>, <option>monitor-vfreq</option>,
  <option>monitor-dotclock</option> angegeben werden (Kommandozeile,
  Konfigurationsdatei), dann bekommst du die höchstmögliche
  Bildwiederholrate (mit den generischen Timingformeln). Um dieses Feature
  zu aktivieren, müssen <emphasis role="bold">alle</emphasis>
  Monitoroptionen angegeben werden.
</para></listitem>
</itemizedlist>

<itemizedlist spacing="compact">
<title>NACHTEILE</title>
<listitem><para>
  Der Treiber funtkioniert nur auf <emphasis role="bold">x86-Systemen</emphasis>.
</para></listitem>
<listitem><para>
  Er kann nur von <systemitem class="username">root</systemitem> benutzt werden.
</para></listitem>
<listitem><para>
  Momentan ist er nur für <emphasis role="bold">Linux</emphasis> verfügbar.
</para></listitem>
</itemizedlist>

<important>
<para>
  Benutze diesen Treiber nicht mit <emphasis role="bold">GCC 2.96</emphasis>!
  Das wird nicht funktionieren!
</para>
</important>

<variablelist>
<title>BEI VESA VERFÜGBARE KOMMANDOZEILENOPTIONEN</title>
<varlistentry>
  <term><option>-vo vesa:<replaceable>opts</replaceable></option></term>
  <listitem><para>
  Momentan erkannt: <literal>dga</literal>, um den DGA-Modus zu erzwingen
  und <literal>nodga</literal>, um ihn zu deaktivieren. Im DGA-Modus kannst du den
  Doppelpuffermodus mit <option>-double</option> aktivieren. Anmerkung: Du
  kannst diese Parameter auch weglassen, um die <emphasis role="bold">automatische
  Erkennung</emphasis> des DGA-Modus zu ermöglichen.
  </para></listitem>
</varlistentry>
</variablelist>

<itemizedlist spacing="compact">
<title>BEKANNTE PROBLEME UND WIE MAN SIE UMGEHT</title>
<listitem><para>
  Wenn du unter Linux eine <emphasis role="bold">NLS</emphasis>-Schrift
  verwendest und du den VESA-Treiber aus dem Textmodus heraus aufrufst,
  dann wird nach dem Beenden von <application>MPlayer</application> die
  <emphasis role="bold">ROM-Schrift</emphasis> anstelle der nationalen
  geladen sein. Du kannst die nationale Schriftart erneut mit
  <command>setsysfont</command> laden, das z.B. bei Mandrake zur
  Distribution gehört. (<emphasis role="bold">Tip:</emphasis> Das
  gleiche Tool wird für die Lokalisation von fbdev verwendet.)
</para></listitem>
<listitem><para>
  Manche <emphasis role="bold">Linux-Grafiktreiber</emphasis> aktualisieren
  nicht den aktiven <emphasis role="bold">BIOS-Modus</emphasis> im DOS-Speicher.
  Wenn du also so ein Problem hast, dann verwende den VESA-Treiber nur aus dem
  <emphasis role="bold">Textmodus</emphasis> heraus. Andernfalls
  wird immer der Textmodus (#03) aktiviert werden, und du wirst den
  Computer neustarten müssen.
</para></listitem>
<listitem><para>
  Oftmals siehst du nur einen <emphasis role="bold">schwarzen Bildschirm</emphasis>,
  wenn der VESA-Treiber beendet wird. Um die Anzeige wieder in den richtigen Zustand
  zu versetzen, wechsele einfach zu einer anderen Console (mit
  <keycombo><keycap>Alt</keycap><keycap>F&lt;x&gt;</keycap></keycombo>) und wieder zurück.
</para></listitem>
<listitem><para>
  Um eine <emphasis role="bold">funktionierende TV-Ausgabe</emphasis> zu erhalten,
  musst du das TV-Kabel eingesteckt haben, bevor du deinen PC bootest, da das BIOS
  nur einmal während der POST-Phase initialisiert wird.
</para></listitem>
</itemizedlist>
</sect1>


<sect1 id="x11">
<title>X11</title>

<para>
  Vermeide diesen Treiber, wenn's geht. Er benutzt X11 (mit den Shared-
  Memory-Erweiterungen) ohne jegliche Hardwarebeschleunigung. Unterstützt
  MMX-/3DNow/SSE-beschleunigte Softwareskalierung mit den Optionen
  <option>-fs -zoom</option>, aber die ist trotzdem langsam. Die meisten
  Karten bieten Unterstützung für Hardwareskalierung. Benutze also
  <option>-vo xv</option> in den meisten Fällen bzw. <option>-vo xmga</option>
  bei Matrox-Karten.
</para>

<para>
  Ein Problem liegt darin, dass die meisten Grafikkartentreiber
  Hardwarebeschleunigung nicht beim zweiten Ausgang/beim TV-Ausgang
  unterstützen. In diesen Fällen siehst du nur ein grünes/blaues
  Fenster anstelle des Films. Hier ist der X11-Treiber ganz praktisch, aber du
  brauchst trotzdem eine schnelle CPU für die Softwareskalierung. Benutze
  nicht den SDL-Ausgabetreiber und SDLs Skalierer, da dieser eine schlechtere
  Qualität bietet!
</para>

<para>
  Softwareskalierung ist sehr langsam. Versuch also besser, vorher in einen
  anderen Videomodus zu schalten. Das ist sehr einfach. Such die
  <link linkend="dga-modelines">Modelines in der DGA-Sektion</link> und füge sie
  in deine <filename>XF86Config</filename> ein.

<itemizedlist spacing="compact">
<listitem><para>
  Wenn du XFree86 4.x.x hast, dann benutze die Option <option>-vm</option>.
  MPlayer wird dann die Auflösung in diejenige ändern,
  in die dein Film am besten hineinpasst. Wenn das nicht funktioniert:
</para></listitem>
<listitem><para>
  Unter XFree86 3.x.x musst du mit
  <keycombo><keycap>Strg</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo>
  und
  <keycombo><keycap>Strg</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>
  die Auflösung ändern.
</para></listitem>
</itemizedlist>
</para>

<para>
  Wenn du die soeben eingefügten Modi nicht wiederfindest, dann schau
  dir die Ausgabe von XFree86 an. Einige Treiber können nicht die
  niedrigen Pixelclock-Werte benutzen, die für niedrige Auflösungen
  vonnöten sind.
</para>
</sect1>


<sect1 id="vidix">
<title>VIDIX</title>

<formalpara>
<title>EINLEITUNG</title>
<para>
  <acronym>VIDIX</acronym> ist die Abkürzung für <emphasis role="bold">VID</emphasis>eo
  <emphasis role="bold">I</emphasis>nterface für
  *ni<emphasis role="bold">X</emphasis> (Video-Schnittstelle für *n*x).
  VIDIX wurde entworfen, um eine Schnittstelle für schnelle Userspacetreiber für
  Grafikkarten zur Verfügung zu stellen, so wie es mga_vid für
  Matrox-Karten tut. VIDIX ist ebenfalls sehr portabel.
</para>
</formalpara>
<para>
  Diese Schnittstelle wurde als Versuch entworfen, den vorhandenen
  Schnittstellen für Videobeschleunigung (mga_vid, rage128_vid,
  radeon_vid, pm3_vid) ein einheitliches Dach zu geben. Sie stellt einen
  einheitlichen Highlevel-Zugang zu BES- und OV-Chips zur Verfügung
  (BackEnd Scaler und Video Overlays). Sie stellt keine Lowlevel-Funktionen
  für z.B. Grafikserver zur Verfügung. (Ich möchte nicht mit den
  X11-Leuten in Sachen Grafikmodusumschaltung konkurrieren.) Das Ziel dieser
  Schnittstelle liegt also einfach darin, die höchstmögliche
  Geschwindigkeit bei der Videowiedergabe zu erreichen.
</para>

<itemizedlist spacing="compact">
<title>VERWENDUNG</title>
<listitem><para>
  Du kannst den eigenständigen Videotreiber benutzen:
  <option>-vo vidix</option>
  Dieser Treiber wurde als das X11-Frontend für die VIDIX-Technologie
  entwickelt. Er benötigt dementsprechend einen X-Server und
  funktioniert auch nur unter X. Beachte, dass der Pixmap-Cache korrumpiert
  werden kann, weil der Treiber unter Umgehung des X-Treibers direkt auf
  die Hardware zugreift. Du kannst das dadurch verhindern, dass du die von
  X verwendete Menge des Grafikspeichers verringerst. Benutze dafür
  die Option "VideoRam" in der "device"-Sektion der
  <filename>XF86Config</filename>. Du solltest da die installierte Menge
  Grafikspeicher minus 4MB eintragen. Wenn du über weniger als 8MB
  Grafikspeicher verfügst, dann solltest du stattdessen die Option
  "XaaNoPixmapCache" in der "screen"-Sektion verwenden.
  </para></listitem>
<listitem><para>
  Es gibt einen VIDIX-Treiber für die Konsole: <option>-vo cvidix</option>.
  Dieser benötigt für die meisten Karten einen funktionierenden und
  initialisierten Framebuffer (oder du wirst stattdessen den Bildschirm
  in Unordnung bringen) und wirst einen Effekt ähnlich wie mit
  <option>-vo mga</option> oder <option>-vo fbdev</option> bekommen.
  nVidia-Karten sind dagegen in der Lage, wirklich grafisches Video
  auf einer echten Text-Konsole auszugeben. Im Abschnitt
  <link linkend="vidix-nvidia">nvidia_vid</link> wirst du mehr Informationen
  dazu finden.
  Um Text an den Rändern und den blinkenden Cursor loszuwerden,
  probiere etwas wie den folgenden Befehl:
</para>
<screen>setterm -cursor off > /dev/tty9</screen>
<para>
  (welcher davon ausgeht, dass <systemitem>tty9</systemitem> bis dahin ungenutzt ist).
  Wechsle dann zu <systemitem>tty9</systemitem>.
  Andererseits sollte dir <option>-colorkey 0</option> ein Video liefern, das
  im "Hintergrund" läuft; das hängt jedoch davon ab, dass die colorkey-Funktionalität
  korrekt funktioniert.
  </para></listitem>
<listitem><para>
  Du kannst auch das VIDIX-Untergerät verwenden, das bei vielen
  Treibern zur Verfügung steht:
  <option>-vo vesa:vidix</option> (<emphasis role="bold">nur unter Linux</emphasis>)
  und <option>-vo fbdev:vidix</option>
  </para></listitem>
</itemizedlist>

<para>
  Es ist in der Tat nicht wichtig, welcher Videoausgabetreiber mit
  <emphasis role="bold">VIDIX</emphasis> verwendet wird.
</para>

<itemizedlist spacing="compact">
<title>ANFORDERUNGEN</title>
<listitem><para>
  Die Grafikkarte sollte sich gerade im Grafikmodus befinden (ausser
  nVidia-Karten mit den <option>-vo cvidix</option> Ausgabe-Treibern).
</para></listitem>
<listitem><para>
  <application>MPlayer</application>s Videoausgabetreiber sollte den
  aktiven Videomodus kennen und in der Lage sein, dem VIDIX-Untergerät
  ein paar Charakteristika des X-Servers mitzuteilen.
</para></listitem>
</itemizedlist>

<formalpara>
<title>BEDIENUNGSMETHODEN</title>
<para>
  Wenn VIDIX als <emphasis role="bold">Subgerät</emphasis>
  (<option>-vo vesa:vidix</option>) benutzt wird, dann wird die Konfiguration
  des Videomodus vom Videoausgabegerät erledigt (kurz
  <emphasis role="bold">vo_server</emphasis>). Deswegen kannst du für
  <application>MPlayer</application> die gleichen Kommandozeilenparameter wie
  für vo_server verwenden.
  Zusätzlich ist die Option <option>-double</option> als global sichtbarer
  Parameter verfügbar. (Ich empfehle diese Option zumindest bei VIDIX und
  ATI-Karten.) <option>-vo xvidix</option> erkennt momentan die folgenden
  Optionen: <option>-fs -zoom -x -y -double</option>.
</para>
</formalpara>
<para>
  Du kannst den VIDIX-Treiber auch direkt als drittes Teilargument auf der
  Kommandozeile angeben:

  <screen>mplayer -vo xvidix:mga_vid.so -fs -zoom -double <replaceable>Datei.avi</replaceable></screen>
  oder
  <screen>mplayer -vo vesa:vidix:radeon_vid.so -fs -zoom -double -bpp 32 <replaceable>Datei.avi</replaceable></screen>

  Das ist allerdings gefährlich, und du solltest das lieber nicht tun.
  Hierbei wird die Verwendung des angegebenen Treibers erzwungen, und das
  Resultat ist unklar (dein Computer könnte sogar
  <emphasis role="bold">abstürzen</emphasis>).
  Du solltest das wirklich NUR DANN tun, wenn du absolut sicher bist, dass es
  funktioniert und <application>MPlayer</application> es nicht eh schon
  automatisch auswählt.
  Berichte den Entwicklern von deinen Erfahrungen. Die korrekte Art, VIDIX zu
  benutzen, ist ohne das dritte Teilargument, sodass <application>MPlayer</application>
  automatisch den richtigen Treiber aussucht.
</para>

<para>
  Da VIDIX direkten Zugriff auf die Hardware benötigt, musst du
  <application>MPlayer</application> entweder als
  <systemitem class="username">root</systemitem> starten oder der
  Programmdatei das SUID-Bit setzen (<emphasis role="bold">WARNUNG:
  Das ist ein Sicherheitsrisiko!</emphasis>).
  Alternativ kannst du auch spezielle Kernelmodule benutzen:
</para>

<procedure>
<step><para>
  Lade dir die
  <ulink url="http://www.arava.co.il/matan/svgalib/">Entwicklerversion</ulink>
  der svgalib herunter (z.B. 1.9.17),
  <emphasis role="bold">ODER</emphasis> lade dir eine von Alex speziell für
  die Benutzung mit <application>MPlayer</application> modifizierte Version
  (die nicht die svgalib-Sourcen zum Compilieren benötigt)
  <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/svgalib/svgalib_helper-1.9.17-mplayer.tar.bz2">hier</ulink>
  herunter.
</para></step>
<step><para>
  Compiliere das Modul im <filename class="directory">svgalib_helper</filename>-Verzeichnis
  (das im Verzeichnis <filename class="directory">svgalib-1.9.17/kernel/</filename>
  gefunden werden kann, wenn du die Sourcen von der svgalib-Seite heruntergeladen hast),
  und lade es mit insmod.
</para></step>
<step><para>
  Um die entsprechenden Geräte im <filename class="directory">/dev</filename>-Verzeichnis
  zu erstellen, führe ein <screen>make device</screen> im Verzeichnis
  <filename class="directory">svgalib_helper</filename> als
  <systemitem class="username">root</systemitem> aus.
</para></step>
<step><para>
  Verschiebe das Verzeichnis <filename class="directory">svgalib_helper</filename>
  in das <filename class="directory">vidix</filename>-Unterverzeichnis des
  <application>MPlayer</application>-Quellbaums.
</para></step>
<step><para>
    Entferne den Kommentar vor der CFLAGS-Zeile, die "svgalib_helper" enthält
    aus <filename class="directory">vidix/Makefile</filename>.
</para></step>
<step><para>
  Compiliere erneut.
</para></step>
</procedure>

<sect2 id="vidix-ati">
<title>ATI-Karten</title>
<para>
  Momentan werden die meisten ATI-Karten unterstützt, von der Mach64
  bis hin zur neuesten Radeon.
</para>

<para>
  Es gibt zwei compilierte Binaries: <filename>radeon_vid</filename> für Radeons
  und <filename>rage128_vid</filename> für Rage128-Karten. Du kannst entweder eine
  der beiden erzwingen oder das VIDIX-System automatisch alle verfügbaren
  Treiber ausprobieren lassen.
</para>
</sect2>

<sect2 id="vidix-mga">
<title>Matrox-Karten</title>
<para>
  Matrox G200, G400, G450 und G550 sollen funktionieren.
</para>

<para>
  Der Treiber unterstützt Videoequalizer und sollte fast genauso schnell
  wie der <link linkend="mga_vid">Matrox-Framebuffer</link> sein.
</para>
</sect2>

<sect2 id="vidix-trident">
<title>Trident-Karten</title>
<para>
  Es gibt einen Treiber für den Trident Cyberblade/i1-Chipsatz, der auf
  VIA Epia-Mainboards eingesetzt wird.
</para>

<para>
  Der Treiber wurde geschrieben und wird weiterentwickelt von
  <ulink url="http://www.blackfiveservices.co.uk/EPIAVidix.shtml">Alastair M. Robinson</ulink>.
</para>
</sect2>

<sect2 id="vidix-3dlabs">
<title>3DLabs-Karten</title>
<para>
  Auch wenn es einen Treiber für 3DLabs GLINT R3-Chips und Permedia3-Chips
  gibt, so hat noch niemand diese getestet. Feedback wird deswegen gern gesehen.
</para>
</sect2>

<sect2 id="vidix-nvidia">
<title>nVidia-Karten</title>

<para>
  Ein einmaliges Feature des nvidia_vid-Treibers ist seine Fähigkeit, Video auf
  <emphasis role="bold">einfacher, purer Textkonsole</emphasis> darzustellen - ohne
  Framebuffer oder X magic oder was auch immer. Zu diesem Zweck müssen wir
  die <option>cvidix</option>-Videoausgabe verwenden, wie folgendes Beispiel zeigt:
  <screen>mplayer -vo cvidix <replaceable>example.avi</replaceable></screen>
</para>

</sect2>

<sect2 id="vidix-sis">
<title>SiS-Karten</title>
<para>
  Dies ist ein sehr experimenteller Code, ähnlich nvidia_vid.
</para>

<para>
  Er wurde auf SiS 650/651/740 getestet (die verbreitetsten Chipsets in den
  SiS-Versionen der Boxen von "Shuttle XPC"-Barebones)
</para>

<para>
  Berichte erwartet!
</para>
</sect2>
</sect1>

<sect1 id="directfb">
<title>DirectFB</title>
<blockquote><para>
  "DirectFB ist eine Grafikbibliothek, deren Zielplattform eingebettete
  Systeme sind. Sie bietet maximale Hardwarebeschleunigung bei minimalem
  Ressourcenverbrauch und minimalem Overhead." - Zitat von
  <ulink url="http://www.directfb.org"/>.
</para></blockquote>

<para>
  Ich lasse die DirectFB-Features in dieser Sektion weg.
</para>

<para>
  Obwohl <application>MPlayer</application> nicht als "Videoprovider"
  bei DirectFB unterstützt wird, bietet dieser Treiber Videowiedergabe mittels
  DirectFB. Die Wiedergabe ist - natürlich - hardwarebeschleunigt. Bei
  meiner Matrox G400 war der DirectFB genauso schnell wie XVideo.
</para>

<para>
  Versuche immer die neueste Version von DirectFB zu verwenden. Du kannst
  DirectFB-Optionen mit der <option>-dfbopts</option>-Option auf der Kommandozeile
  angeben. Layer-Auswahl erfolgt durch Angabe als Teilargument, z.B. mit
  <option>-vo directfb:2</option> (Layer -1 ist der Standardwert: automatische
  Layerauswahl).
</para>
</sect1>

<sect1 id="dfbmga">
<title>DirectFB/Matrox (dfbmga)</title>
<para>
  Bitte lies die
  <link linkend="directfb">DirectFB-Sektion</link> zu generellen
  Informationen über DiretcFB.
</para>

<para>
  Dieser Videoausgabetreiber wird auf einer Matrox G400/G450/G550-Karten
  den CRTC2 (des zweiten Ausgangs) aktivieren und damit das Video
  <emphasis role="bold">unabhängig</emphasis> vom primären Ausgang anzeigen.
</para>

<para>
  Anweisungen, um dies zum Laufen zu bringen, stehen direkt in der
  <ulink url="http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto">HOWTO</ulink>
  oder der
  <ulink url="http://www.sci.fi/~syrjala/directfb/Matrox_TV-out_README.txt">README</ulink>
  auf der Homepage von Ville Syrjala.
</para>

<note><para>
  Die erste DirectFB-Version, mit der wir das zum Laufen gebracht haben, war
  0.9.17 (sie ist fehlerhaft, benötigt den <systemitem>surfacemanager</systemitem> von
  oben erwähnter URL). Wie auch immer, eine Portierung des CRTC2-Codes für
  <link linkend="mga_vid">mga_vid</link> ist bereits in Arbeit.
  <ulink url="../../tech/patches.txt">Patches</ulink> sind willkommen.
</para></note>
</sect1>

<sect1 id="mpeg_decoders">
<title>MPEG-Dekoderkarten</title>

<sect2 id="dvb">
<title>DVB-Output und -Input</title>
<para>
  <application>MPlayer</application> unterstützt Karten mit dem Siemens-DVB-Chipsatz von
  Herstellern wie Siemens, Technotrend, Galaxis oder Hauppauge. Die neuesten
  DVB-Treiber gibt's auf der
  <ulink url="http://www.linuxtv.org">Linux TV-Seite</ulink>. Wenn du
  Transcodierung in Software machen willst, dann brauchst du eine CPU mit mindestens 1GHz.
</para>

<para>
  <filename>configure</filename> sollte automatisch deine DVB-Karte erkennen. Wenn
  es das nicht tut, dann erzwinge DVB-Unterstützung mit
</para>

<para><screen>./configure --enable-dvb</screen></para>

<para>
  Wenn die ost-Headerdateien nicht an ihrem normalen Platz liegen, dann gib
  explizit den Pfad zu ihnen an mit:
</para>

<para>
<screen>./configure --with-extraincdir=<replaceable>DVB-Source-Verzeichnis</replaceable>/ost/include
</screen>
</para>

<para>
  Dann compiliere und installiere wie sonst auch.
</para>

<formalpara>
<title>GEBRAUCH</title>
<para>
  Hardwaredecodierung von Streams, die MPEG-1/2 Video und/oder MPEG-Audio enthalten,
  geschieht mit diesem Kommando:
</para>
</formalpara>

<para>
<screen>mplayer -ao mpegpes -vo mpegpes <replaceable>Datei.mpg|vob</replaceable>
</screen>
</para>

<para>
  Decodierung jeder Art Videostream verlangt Transcodierung zu MPEG-1, daher ist
  es langsam und den Ärger möglicherweise nicht wert, vor allem, wenn dein
  Computer langsam ist.
  Es kann folgenderweise gemacht werden:
</para>
<para>
<screen>
mplayer -ao mpegpes -vo mpegpes <replaceable>DateieDatei.ext</replaceable>
mplayer -ao mpegpes -vo mpegpes -vf expand <replaceable>DateieDatei.ext</replaceable>
</screen>
</para>

<para>
  Beachte, dass DVB-Karten nur bestimmte Bildhöhen unterstützen:
  288 und 576 für PAL und 240 und 480 für NTSC. Du
  <emphasis role="bold">musst</emphasis> das Bild vorher skalieren, wenn
  die Höhe nicht einer der oben erwähnten entspricht:
  <option>-vf scale=width:height</option>. DVB-Karten
  unterstützen eine Vielzahl horizontaler Auflösungen wie z.B.
  720, 704, 640, 512, 480, 352 etc. Sie machen Hardwareskalierung in horizontaler
  Richtung, sodass du meist nicht in horizontaler Richtung skalieren musst.
  Bei einem 512x384-MPEG4 (DivX) (Verhältnis 4:3) kannst du folgendes probieren:
</para>

<para>
<screen>mplayer -ao mpegpes -vo mpegpes -vf scale=512:576
</screen>
</para>

<para>
  Wenn du einen Breitwandfilm hast und du ihn nicht auf die volle
  Höhe skalieren möchtest, dann kannst du den <option>expand=w:h</option>-Filter
  benutzen, um schwarze Balken hinzuzufügen.
  Um ein 640x384-MPEG4 (DivX) anzuschauen:
</para>

<para>
<screen>mplayer -ao mpegpes -vo mpegpes -vf expand=640:576 <replaceable>Datei.avi</replaceable>
</screen>
</para>

<para>
  Wenn deine CPU für 720x576-MPEG4 (DivX) zu langsam ist, dann skaliere
  herunter:
</para>

<para>
  <screen>mplayer -ao mpegpes -vo mpegpes -vf scale=352:576 <replaceable>Datei.avi</replaceable>
</screen>
</para>

<para>
  Wenn sich die Geschwindigkeit nicht verbessert, dann skaliere auch in
  vertikaler Richtung:
</para>

<para>
  <screen>mplayer -ao mpegpes -vo mpegpes -vf scale=352:288 <replaceable>Datei.avi</replaceable>
</screen>
</para>

<para>
  Für ein OSD und Untertitel kannst du das OSD-Feature des expand-
  Filters benutzen. Anstelle von <option>expand=w:h</option> oder
  <option>expand=w:h:x:y</option> benutzt du dafür
  <option>expand=w:h:x:y:1</option> (der fünfte Parameter <option>:1</option>
  schaltet die OSD-Anzeige an). Eventuell willst du das Bild ein wenig nach
  oben schieben, um unten mehr Platz für die Untertitel zu haben.
  Vielleicht willst du auch die Untertitel hochschieben, wenn sie ansonsten
  außerhalb des sichtbaren Bereiches des Fernsehers liegen. Das kannst du mit
  <option>-subpos &lt;0-100&gt;</option> erreichen, wobei
  <option>-subpos 80</option> meistens eine gute Wahl darstellt.
</para>

<para>
  Um Filme mit weniger/mehr als 25 Frames pro Sekunde auf einem
  PAL-Fernseher abzuspielen, oder wenn du eine langsame CPU hast,
  verwende die Option <option>-framedrop</option>.
</para>

<para>
  Um das Höhen-/Breitenverhältnis des MPEG-4 (DivX) beizubehalten und
  trotzdem die optimalen Skalierungsparameter zu verweden (Hardwareskalierung
  in horizontaler Richtung und Softwareskalierung in vertikaler Richtung unter
  Beibehaltung des richtigen Höhen-/Breitenverhältnisses), benutze
  den neuen dvbscale-Filter:
</para>

<para><screen>
for a  4:3 TV: -vf dvbscale,scale=-1:0,expand=-1:576:-1:-1:1
for a 16:9 TV: -vf dvbscale=1024,scale=-1:0,expand=-1:576:-1:-1:1
</screen></para>

<formalpara>
<title>Digitales TV (DVB-Input-Modul)</title>
<para>
  Du kannst deine DVB-Karte zum Ansehen digitalen TVs verwenden.
</para>
</formalpara>

<para>
  Du solltest die Programme <command>scan</command> und
  <command>szap/tzap/czap/azap</command> installiert haben; sie sind alle
  im Treiberpaket enthalten.
</para>

<para>
  Überprüfe, ob die Treiber sauber mit dem Programm wie etwa
  <ulink url="http://sf.net/projects/dvbtools/"><command>dvbstream</command></ulink>
  arbeiten (das ist die Basis des DVB-Input-Moduls).
</para>

<para>
  Jetzt solltest du eine Datei <filename>~/.mplayer/channels.conf</filename>
  mit der von <command>szap/tzap/czap/azap</command> Syntax compilieren oder
  es von <command>scan</command> für dich compilieren lassen.
</para>

<para>
  Hast du mehr als einen Kartentyp (z.B. Satellit, Antenne, Kabel und ATSC),
  kannst du deine Kanaldateien als
  <filename>~/.mplayer/channels.conf.sat</filename>,
  <filename>~/.mplayer/channels.conf.ter</filename>,
  <filename>~/.mplayer/channels.conf.cbl</filename>,
  und <filename>~/.mplayer/channels.conf.atsc</filename> respektive
  speichern, um <application>MPlayer</application> unbedingt darauf
  hinzuweisen, eher diese Dateien zu verwenden als
  <filename>~/.mplayer/channels.conf</filename>,
  und du musst angeben, welche Karte du verwendest.
</para>

<para>
  Stelle sicher, dass du <emphasis>nur</emphasis> frei ausgestrahlte
  Kanäle in deiner Datei <filename>channels.conf</filename> hast, oder
  <application>MPlayer</application> wird auf eine unverschlüsselte
  Übertragung warten.
</para>

<para>
  In deinen Audio- und Videofeldern kannst du eine erweiterte Syntax
  anwenden:
  <option>...:pid[+pid]:...</option> (für ein Maximum von 6 pids bei
  jedem); in diesem Fall wird <application>MPlayer</application>
  alle gezeigten pids enbinden, plus pid 0 (welche das PAT enthält).
  Binde ruhig in jede Spalte die PMT pid für den
  korrespondierenden Kanal ein (falls du ihn kennst).
  Du kannst auch 8192 angeben; dies wird alle pids auf dieser Frequenz wählen,
  und du kannst dann zwischen ihnen mit TAB wechseln.
  Das mag mehr Bandbreite benötigen, billige Karten übertragen jedoch
  alle Kanäle zumindest bis zum Kernel, daher macht es für diese keinen
  großen Unterschied.
  Andere mögliche Anwendungen sind: televideo pid, zweiter Audio-Track, etc.
</para>

<para>
  Wenn sich <application>MPlayer</application> regelmäßig über
  <screen>Zu viele Audiopakete im Puffer</screen> beschwert oder
  wenn du eine zunehmende Desynchronisation zwischen Ton und Video feststellst,
  versuche den MPEG-TS-Demuxer von libavformat zu verwenden, indem du
  <option>-demuxer lavf -lavfdopts probesize=128</option>
  der Kommandozeile hinzufügst.
</para>

<para>
  Um den ersten der in deiner Liste vorhandenen Kanäle anzuzeigen,
  führe folgendes aus
</para>

<screen>
  mplayer dvb://
</screen>

<para>
  Willst du einen bestimmten Kanal wie z.B. R1 ansehen,
  führe dies aus
</para>

<screen>
  mplayer dvb://R1
</screen>

<para>
  Hast du mehr als eine Karte, musst du die Nummer der Karte, in der
  der Kanal zu sehen ist (z.B. 2), mit dieser Syntax angeben:
</para>

<screen>
  mplayer dvb://2@R1
</screen>

<para>
  Um Kanäle zu wechseln, drücke die Tasten <keycap>h</keycap> (nächster)
  und <keycap>k</keycap> (vorheriger) oder verwende das
  <link linkend="osdmenu">OSD-Menü</link>.
</para>

<para>
  Wenn deine <filename>~/.mplayer/menu.conf</filename> einen Eintrag
  <literal>&lt;dvbsel&gt;</literal> enthält, wie der in der Beispieldatei
  <filename>etc/dvb-menu.conf</filename> (die du zum Überschreiben der
  <filename>~/.mplayer/menu.conf</filename> nutzen kannst), wird das Hauptmenü
  einen Untermenüeintrag anzeigen, der dir die Wahl des Kanal-Presets in deiner
  <filename>channels.conf</filename> erlaubt, womöglich gefolgt von einem
  Menü mit der Liste der verfügbaren Karten, falls mehr als eine
  von <application>MPlayer</application> genutzt werden kann.
</para>

<para>
  Willst du ein Programm auf die Festplatte speichern, nimm
</para>

<screen>
  mplayer -dumpfile r1.ts -dumpstream dvb://R1
</screen>

<para>
  Willst du ihn statt dessen in einem anderen Format aufnehmen (ihn neu encodieren),
  kannst du einen Befehl wie diesen ausführen
</para>

<screen>
  mencoder -o r1.avi -ovc xvid -xvidencopts bitrate=800 -oac mp3lame -lameopts cbr:br=128 -pp=ci dvb://R1
</screen>

<para>
  Lies dir in der Manpage eine Liste von Optionen durch, die du an das DVB-Input-Modul
  übergeben kannst.
</para>

<formalpara>
<title>AUSBLICK</title>
<para>
  Wenn du Fragen hast oder an der Diskussion über zukünftige
  Features teilnehmen willst, dann melde dich bei unserer
  <ulink url="http://lists.mplayerhq.hu/mailman/listinfo/mplayer-dvb">MPlayer-DVB</ulink>
  Mailingliste an. Denk bitte daran, dass dort Englisch gesprochen wird.
</para>
</formalpara>

<para>
  Für die Zukunft kannst du mit der Möglichkeit, das OSD und die
  Untertitel mit den eingebauten Funktionen der DVB-Karten anzuzeigen, mit
  flüssigerer Wiedergabe von Filmen mit weniger/mehr als 25 Bildern pro
  Sekunde und mit Echtzeit-Transcodierung zwischen MPEG-2 und MPEG-4 (partielle
  Dekompression) rechnen.
</para>
</sect2>

<sect2 id="dxr2">
<title>DXR2</title>
<para>
  <application>MPlayer</application> unterstützt hardwarebeschleunigte
  Wiedergabe mit der Creative DXR2-Karte.</para>
<para>
  Zuerst brauchst du einen richtig installierten DXR2-Treiber. Du kannst
  die Treiber und Installationshinweise im
  <ulink url="http://dxr2.sf.net/">DXR2 Resource Center</ulink> finden.
</para>

<variablelist>
<title>GEBRAUCH</title>
<varlistentry>
<term><option>-vo dxr2</option></term>
<listitem><para>Aktiviere TV-Ausgabe.</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-vo dxr2:x11</option> oder <option>-vo dxr2:xv</option></term>
<listitem><para>Aktiviere Overlay-Ausgabe unter X11.</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-dxr2 &lt;option1:option2:...&gt;</option></term>
<listitem><para>Diese Option wird zur Kontrolle des DXR2-Treiber verwendet.</para></listitem>
</varlistentry>
</variablelist>

<para>
  Der auf DXR2 genutzte Overlay-Chipset ist von sehr schlechter Qualität,
  die Standardeinstellungen sollten aber bei jedem funktionieren.
  Das OSD kann eventuell mit Overlay genutzt werden (nicht bei TV),
  indem es im colorkey eingetragen wird. Mit den Standardeinstellungen des
  colorkey bekommst du evtl. unterschiedliche Ergebnisse, gewöhnlich wirst du den
  colorkey rund um die Zeichen sehen oder einige anderen lustigen Effekte.
  Aber wenn du die colorkey-Einstellungen korrekt anpasst, solltest du in der
  Lage sein, akzeptable Resultate zu erzielen.
</para>

<para>Lies bitte in der Manpage über die vorhandenen Optionen.</para>
</sect2>

<sect2 id="dxr3">
<title>DXR3/Hollywood+</title>
<para>
  <application>MPlayer</application> unterstützt die hardwarebeschleunigte
  Wiedergabe mit den Karten Creative DXR3 und Sigma Designs Hollywood Plus.
  Beide Karten basieren auf dem em8300-MPEG-Decoderchip von Sigma Designs.
</para>

<para>
  Als erstes brauchst du korrekt installierte DXR3/H+-Treiber, Version
  0.12.0 oder neuer. Diese Treiber und weitere Installationsanweisungen findest
  du auf der Seite
  <ulink url="http://dxr3.sf.net/">DXR3 &amp; Hollywood Plus for Linux</ulink>.
  <filename>configure</filename> sollte die Karte automatisch
  finden. Die Compilierung sollte auch problemlos funktionieren.
</para>

<!-- FIXME: find a more clear presentation -->
<variablelist>
<title>GEBRAUCH</title>
<varlistentry>
<term><option>-vo dxr3:prebuf:sync:norm=x:<replaceable>device</replaceable></option></term>
<listitem>
<para>
  <option>overlay</option> aktiviert das Overlay anstelle des TV-Ausgangs.
  Dafür brauchst du ein korrekt konfiguriertes Overlaysetup. Am einfachsten
  konfigurierst du das Overlay mit dem Tool <filename>autocal</filename>.
  Starte danach <application>MPlayer</application> mit dxr3-Ausgabe und
  ohne Overlay anzuschalten. Starte <filename>dxr3view</filename>. Mit dxr3view
  kannst du die Overlay-Einstellungen verändern und siehst die
  Auswirkungen sofort. Eventuell wird dieses Feature irgendwann vom
  <application>MPlayer</application>-GUI unterstützt. Wenn du das Overlay richtig
  eingestellt hast, brauchst du dxr3view nicht mehr laufen zu lassen.
</para>
<para>
  <option>prebuf</option> schaltet Prebuffering ein. Das ist ein Feature des
  em8300-Chips, das es ihm ermöglicht, mehr als nur ein Bild
  gleichzeitig zu speichern. Das bedeutet, dass <application>MPlayer</application>
  in diesem Modus versucht, den Puffer ständig mit Daten gefüllt zu halten.
  Wenn du einen langsamen Rechner hast, dann wird <application>MPlayer</application>
  wahrscheinlich die meiste Zeit über knapp oder genau 100% der CPU-Zeit belegen.
  Das ist vor allem dann der Fall, wenn du echte MPEG-Streams (z.B. DVDs, SVCDs etc.)
  abspielst, da <application>MPlayer</application> nicht nach MPEG encodieren muss
  und den Puffer sehr schnell wird füllen können.
</para>
<para>
  Mit Prebuffering ist die Videowiedergabe <emphasis role="bold">viel</emphasis>
  weniger anfällig gegenüber anderen CPU-intensiven Programmen. Frames
  werden nur dann verworfen, wenn eine andere Anwendung für eine
  sehr lange Zeit die CPU belegt.
</para>
<para>
  Wenn kein Prebuffering verwendet wird, dann ist der em8300 viel
  anfälliger gegenüber CPU-Last. Somit wird dringend empfohlen,
  MPlayers <option>-framedrop</option>-Option zu verwenden, um die A/V-Sync
  zu erhalten.
</para>
<para>
  <option>sync</option> aktiviert die neue sync-Methode. Dieses Feature ist
  momentan noch experimentell. Bei dieser Methode beobachtet MPlayer
  ständig die interne Uhr des em8300-Chips. Weicht diese von
  MPlayers Uhr ab, so wird die des em8300-Chips zurückgesetzt,
  sodass dieser alle Frames verwirft, die hinterherhängen.
</para>
<para>
  <option>norm=x</option> setzt den TV-Standard der DXR3-Karte, ohne dafür
  externe Programme wie em8300setup zu benötigen.
  Gültige Werte sind 5 = NTSC, 4 = PAL-60, 3 = PAL. Spezielle Standards
  sind 2 (automatische Erkennung mit PAL/PAL-60) und 1 (automatische
  Erkennung für PAL/NTSC), da sie den Standard in Abhängigkeit
  der FPS des Films setzen. norm = 0 (Standard) ändert
  den momentan eingestellten TV-Standard nicht.
</para>
<para>
  <option><replaceable>device</replaceable></option> = Gerätenummer wählt die zu
  verwendene em8300-Karte, falls du mehrere davon hast.
</para>
<para>
  Jede dieser Optionen kann auch weggelassen werden.
</para>
<para>
  <option>:prebuf:sync</option> scheint sehr gut zu funktionieren, wenn du DivX
  abspielst. Es gab Berichte von Leuten, die Probleme mit <option>prebuf</option>
  bei der Wiedergabe von MPEG1/2-Dateien hatten. Du
  solltest es also zuerst ohne Optionen probieren. Wenn du Sync-Probleme
  hast, dann probier <option>:sync</option> aus.
</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-ao oss:/dev/em8300_ma-<replaceable>X</replaceable></option></term>
<listitem><para>
  Audioausgabe, wobei <replaceable>X</replaceable> die Gerätenummer ist
  (0 bei nur einer Karte).
</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-af resample=<replaceable>xxxxx</replaceable></option></term>
<listitem><para>
  Der em8300 kann keine Sampleraten niedriger als 44100Hz abspielen.
  Wenn die Samplerate weniger als 44100Hz beträgt, dann wähle
  44100Hz oder 48000Hz, je nachdem, welche davon besser passt. Beispiel:
  Wenn der Film 22050Hz benutzt, dann wähle 44100Hz, da 44100 / 2 =
  22050 ist. Bei 24000Hz nimmst du 48000Hz etc. Das funktioniert nicht mit
  der digitalen Audioausgabe (<option>-ac hwac3</option>).
</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-vf lavc</option></term>
<listitem><para>
  Wenn du Nicht-MPEG-Filme mit dem em8300 ansehen möchtest (z.B.
  DivX oder RealVideo), dann musst du einen MPEG1-Videofilter wie
  <systemitem class="library">libavcodec</systemitem> (lavc) verwenden.
  Momentan gibt es keine
  Möglichkeit, die Anzahl der Bilder pro Sekunde des em8300 zu setzen,
  was bedeutet, dass sie fest bei 29.97 liegt. Aus diesem Grund solltest du
  <option>-vf lavc=<replaceable>quality</replaceable>:25</option> verwenden,
  besonders dann, wenn du auch Prebuffering verwendest. Warum aber 25
  und nicht 29.97? Tja, die Sache ist, dass das Bild bei 29.97 unruhig
  wird. Wir wissen leider nicht, warum das so ist. Wenn du Werte zwischen
  25 und 27 benutzt, dann wird das Bild stabil. Momentan können wir das
  nur als gegeben hinnehmen.
</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-vf expand=-1:-1:-1:-1:1</option></term>
<listitem><para>
  Obwohl der DXR3-Treiber ein OSD über das MPEG1-/2-/4-Video
  projezieren kann, ist es qualitativ deutlich schlechter als
  <application>MPlayer</application>s traditionelles OSD, und es hat
  diverse Probleme mit der Erneuerung der Anzeige. Der oben angegebene
  Befehl konvertiert das Video erst nach MPEG4 (das ist leider
  erforderlich) und wendet dann den expand-Filter an, der zwar das
  Bild nicht vergrößert (-1: = Standardwerte) aber dafür das normale
  OSD auf das Bild stanzt (die "1" am Ende).
</para></listitem>
</varlistentry>

<varlistentry>
<term><option>-ac hwac3</option></term>
<listitem><para>
  Der em8300 unterstützt die Audiowiedergabe von AC3-Streams
  (Surroundsound) über den digitalen Ausgang der Karte. Schau oben bei
  der Option <option>-ao oss</option> nach. Sie muss angegeben werden, um den
  DXR3-Ausgang anstelle der Soundkarte anzugeben.
</para></listitem>
</varlistentry>
</variablelist>
</sect2>

</sect1>

<sect1 id="other">
<title>Andere Visualisierungshardware</title>

<sect2 id="zr">
<title>Zr</title>

<para>
  Dieser Treiber ist ein Anzeigetreiber (<option>-vo zr</option>), der
  verschiedeene MJPEG-Aufnahme-/-Wiedergabekarten unterstützt. Getestet
  wurde er mit DC10+ und Buz, und er sollte auch mit der LML33 und der
  Original-DC10 funktionieren. Dieser Treiber encodiert jedes Bild nach JPEG
  und schickt es dann an die Karte. Für die Encodierung wird
  <systemitem class="library">libavcodec</systemitem> benutzt und
  dementsprechend auch benötigt. Mit dem speziellen
  <emphasis>cinemara</emphasis>-Modus kannst du Filme auch tatsächlich im
  Breitbildformat anschauen, wenn du zwei Beamer und zwei MJPEG-Karten hast.
  Abhängig von der Qualität und Auflösung braucht dieser Treiber
  eine Menge CPU-Power. Benutze also besser die Option <option>-framedrop</option>,
  wenn deine Maschine zu langsam ist. Anmerkung: Mein AMD K6-2 350MHz ist
  durchaus in der Lage, Filme in VCD-Größe mit <option>-framedrop</option>
  wiederzugeben.
</para>

<para>
  Dieser Treiber benutzt den Kerneltreiber, den du auf
  <ulink url="http://mjpeg.sf.net"/>
  herunterladen kannst. Dieser muss also vorher schon funktionieren.
  <filename>configure</filename> erkennt automatisch vorhandene MJPEG-Karten. Wenn
  nicht, dann erzwinge zr mit
  <screen>./configure --enable-zr</screen>
</para>
<para>
  Die Ausgabe kann mit diversen Optionen gesteuert werden. Eine
  vollständige Liste findest du in der Manpage. Eine kurze Auflistung gibt
  dir auch
  <screen>mplayer -zrhelp</screen>
</para>

<para>
  Sachen wie das OSD und Skalierung werden nicht von diesem Treiber
  erledigt, aber sie können natürlich durch Filter realisiert werden.
  Beispiel: Angenommen, du hast einen Film mit einer Auflösung von
  512x272, und du möchtest ihn im Vollbild auf deiner DC10+
  anschauen. Du hast dann drei Möglichkeiten: den Film auf eine Breite von
  768, 384 oder 192 zu skalieren. Aus
  Geschwindigkeits- und Qualitätsgründen würde ich empfehlen,
  den Film auf 384x204 mit dem bilinearen Algorithmus zu
  skalieren. Die Kommandozeile sieht dazu wie folgt aus:
<screen>
mplayer -vo zr -sws 0 -vf scale=384:204 <replaceable>movie.avi</replaceable>
</screen>
</para>

<para>
  Das Beschneiden des Bildes kann mit dem <option>crop</option>-Filter geschehen
  oder vom Treiber selbst vorgenommen werden. Angenommen, der Film ist zu breit
  für die Anzeige deiner Buz, und du möchtest <option>-zrcrop</option>
  benutzen, um den Film schmaler zu machen. Dann verwendest du folgendes
  Kommando:
<screen>
mplayer -vo zr -zrcrop 720x320+80+0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
  Mit dem <option>crop</option>-Filter sieht es so aus:
<screen>
mplayer -vo zr -vf crop=720:320:80:0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
  Mehrfache Anwendung von <option>-zrcrop</option> aktiviert den
  <emphasis>cinerama</emphasis>-Modus. Das heißt, du kannst das Bild über
  mehrere Fernseher oder Beamer verteilen, um eine größere
  Anzeigefläche zu erreichen. Angenommen, du hast zwei Beamer. Der linke
  hängt an deiner Buz an <filename>/dev/video1</filename>, und der rechte
  hängt an deiner DC10+ an <filename>/dev/video0</filename>. Der Film hat eine
  Auflösung von 704x288. Nehmen wir weiter an, dass du den
  rechten Beamer schwarz/weiß betreiben möchtest, und dass du auf
  dem linken Beamer Bilder mit der Qualitätsstufe 10 haben
  möchtest. Dann benutzt du dafür das folgende Kommando:
<screen>
mplayer -vo zr -zrdev /dev/video0 -zrcrop 352x288+352+0 -zrxdoff 0 -zrbw \
    -zrcrop 352x288+0+0 -zrdev /dev/video1 -zrquality 10 \
        <replaceable>movie.avi</replaceable>
</screen>
</para>

<para>
  Wie du siehst, gelten die Optionen vor dem zweiten <option>-zrcrop</option> nur
  für die DC10+ und die Optionen nach dem zweiten <option>-zrcrop</option> nur
  für die Buz. Die maximale Anzahl an MJPEG-Karten, die am
  <emphasis>cinerama</emphasis>-Modus teilnehmen, liegt bei vier, sodass du dir
  eine 2x2-Videowand basteln kannst.
</para>

<para>
  Zuletzt ein wirklich wichtiger Hinweis: Starte oder beende auf keinen Fall
  XawTV während der Wiedergabe, da das deinen Computer zum Absturz bringen
  wird. Du kannst aber problemlos <emphasis role="bold">ZUERST</emphasis> XawTV,
  <emphasis role="bold">DANN</emphasis> <application>MPlayer</application>
  starten, warten, bis <application>MPlayer</application> fertig ist
  und <emphasis role="bold">ZULETZT</emphasis> XawTV beenden.
</para>
</sect2>

<sect2 id="blinkenlights">
<title>Blinkenlights</title>
<para>
  Dieser Treiber kann Video mit dem Blinkenlights UDP-Protokoll wiedergeben.
  Wenn du nicht weißt, was
  <ulink url="http://www.blinkenlights.de/">Blinkenlights</ulink>
  oder dessen Nachfolger <ulink url="http://www.blinkenlights.de/arcade/">Arcade</ulink>
  ist, finde es heraus.
  Obwohl dies höchstwahrscheinlich der am wenigsten genutzte Videoausgabetreiber ist,
  den <application>MPlayer</application> zu bieten hat, so ist er ohne Zweifel der coolste.
  Schau dir einfach ein paar von den
  <ulink url="http://www.blinkenlights.de/video.en.html">Blinkenlights-Dokumentationsvideos</ulink>
  an.
  Auf dem Arcade-Video siehst du Blinkenlights-Ausgabetreiber um 00:07:50 in Aktion.
</para>
</sect2>
</sect1>

<sect1 id="tvout">
<title>Unterstützung für die TV-Ausgabe</title>

<sect2 id="tvout-mga-g400">
<title>Matrox G400-Karten</title>

<para>
  Unter Linux hast du zwei Möglichkeiten, den TV-Ausgang deiner
  G400 anzuschalten:
</para>

<important>
<para>
  Anweisungen für die Matrox G450/G550 und deren TV-Ausgänge findest
  du im nächsten Abschnitt!
</para>
</important>

<variablelist>
<varlistentry>
  <term>XFree86</term>
  <listitem><para>
  Mit dem alten Treiber und dem HAL-Modul, welches es
  auf der <ulink url="http://www.matrox.com">Matrox-Seite</ulink> gibt. Damit
  bekommst du X auf dem Fernseher, aber <emphasis role="bold">keine
  Hardwarebeschleunigung</emphasis> wie unter Windows!
</para>
<para>
  Der zweite Ausgang besitzt nur einen YUV-Framebuffer.
  Der <emphasis>BES</emphasis> (Back End Scaler, die YUV-Skalierungseinheit des
  G200/G400/G450/G550) funktioniert mit ihm nicht! Der Windows-Treiber
  umgeht das irgendwie, wahrscheinlich dadurch, dass er die 3D-Engine
  für die Skalierung und den YUV-Framebuffer zur Anzeige des
  skalierten Bildes verwendet. Wenn du unbedingt X benutzen willst, dann
  probier <option>-vo x11 -fs -zoom</option>, aber das wird
  <emphasis role="bold">LANGSAM</emphasis> sein
  und den <emphasis role="bold">Macrovision</emphasis>-Kopierschutz
  aktiviert haben. (Du kannst Macrovision mit diesem
  <ulink url="http://avifile.sf.net/mgamacro.pl">Perlscript</ulink>
  umgehen.)
</para></listitem>
</varlistentry>
<varlistentry>
  <term>Framebuffer</term>
  <listitem><para>
  Mit den <emphasis role="bold">matroxfb-Modulen</emphasis> in den 2.4er
  Kerneln. 2.2er Kernel kennen den TV-Ausgang noch nicht und sind somit
  hierfür nicht geeignet. Du musst ALLE matroxfb-spezifischen Features
  bei der Compilierung anschalten (bis auf MultiHead). Compiliere sie als
  <emphasis role="bold">Module</emphasis>! Du musst ebenfalls I2C anschalten.
</para>

<procedure>
<step><para>
  Gehe nach <filename class="directory">TVout</filename> und gib
  <command>./compile.sh</command> ein. Installiere
  <filename>TVout/matroxset/matroxset</filename> in ein Verzeichnis, das
  in deinem <envar>PATH</envar> liegt.
</para></step>
<step><para>
  Wenn du <command>fbset</command> nicht installiert hast, installiere
  <filename>TVout/fbset/fbset</filename> in ein Verzeichnis, das in
  deinem <envar>PATH</envar> liegt.
</para></step>
<step><para>
  Wenn du <command>con2fb</command> nicht installiert hast, installiere
  <filename>TVout/con2fb/con2fb</filename> in ein Verzeichnis, das in
  deinem <envar>PATH</envar> liegt.
</para></step>
<step><para>
  Geh jetzt in das Verzeichnis <filename class="directory">TVout/</filename>
  in den <application>MPlayer</application>-Quellen und führe dort
  <filename>./modules</filename> als <systemitem class="username">root</systemitem>
  aus. Deine Textmodusconsole wird danach in den Framebuffermodus umschalten,
  aus dem es keinen Weg zurück gibt!
</para></step>
<step><para>
  Editiere als nächstes das Script <filename>./matroxtv</filename>.
  Es wird dir ein simples Menü präsentieren. Drücke
  <keycap>2</keycap> gefolgt von <keycap>ENTER</keycap>. Jetzt solltest
  du auf dem Fernseher das gleiche Bild wie auf dem Monitor sehen.
  Wenn das TV-Bild (PAL ist die Standardeinstellung) merkwürdige Streifen
  enthält, dann war das Script nicht in der Lage, die Auflösung richtig zu
  setzen (per Voreinstellung 640x512). Probiere andere im Menü
  angebotene Auflösungen aus und/oder experimentiere mit fbset.
</para></step>
<step><para>
  So. Die nächste Aufgabe ist es, den Cursor auf tty1 (oder
  woauchimmer) verschwinden zu lassen, und den Bildschirmschoner
  auszuschalten. Führ folgende Kommandos aus:

<screen>
echo -e '\033[?25l'
setterm -blank 0<!--
   --></screen>
      oder
<screen>
setterm -cursor off
setterm -blank 0<!--
   --></screen>

  Wahrscheinlich möchtest du das in ein Script packen und dabei
  gleich den Bildschirm löschen. Um den Cursor wieder
  anzuschalten:
      <screen>echo -e '\033[?25h'</screen> oder
      <screen>setterm -cursor on</screen>
</para></step>
<step><para>
  Yeah kewl. Starte die Wiedergabe mit
<screen>
mplayer -vo mga -fs -screenw 640 -screenh 512 <replaceable>Dateiname</replaceable><!--
   --></screen>

  (Wenn du X benutzt, dann wechsle jetzt auf den matroxfb mit z.B.
  <keycombo><keycap>STRG</keycap><keycap>ALT</keycap><keycap>F1</keycap></keycombo>!)
  Ändere die <literal>640</literal> und <literal>512</literal>, wenn
  du eine andere Auflösung verwendest.
</para></step>
<step><para>
  <emphasis role="bold">Genieße die ultra-schnelle und featurereiche Wiedergabe
  mit dem Matrox-TV-Ausgang (sogar noch besser als Xv)!</emphasis>
      </para></step>
    </procedure>
  </listitem>
</varlistentry>
</variablelist>

<formalpara>
<title>Matrox-TV-Ausgangskabel im Eigenbau</title>
<para>
  Niemand übernimmt Verantwortung für irgendetwas oder jegliche
  Schäden, die durch diese Dokumentation entstehen.
</para>
</formalpara>

<formalpara>
<title>Kabel für die G400</title>
<para>
  Der vierte Pin des CRTC2-Steckers liefert das Composite Video-Signal.
  Erde liegt am sechsten, siebten und achten Pin.
  (Informationen von Balázs Rácz)
</para>
</formalpara>

<formalpara>
<title>Kabel für die G450</title>
<para>
  Der erste Pin des CRTC2-Steckers liefert
  das Composite Video-Signal. Erde liegt am fünften, sechsten, siebten und
  fünfzehnten (5, 6, 7, 15) Pin. (Information von Balázs Kerekes)
</para>
</formalpara>
</sect2>

<sect2 id="tv-out_matrox_g450">
<title>Matrox G450/G550-Karten</title>
<para>
  Unterstützung für den TV-Ausgang dieser Karten wurde erst
  kürzlich implementiert und ist noch nicht in den Standardkerneln
  enthalten. Momentan kann das <emphasis role="bold">mga_vid</emphasis>-Modul
  nicht benutzt werden, wenn ich recht informiert bin, da der G450/G550-Treiber
  nur in einer Konfiguration arbeitet: Der erste CRTC-Chip (mit den vielen
  Features) am ersten Display (meistens der Monitor), und der zweite CRTC
  (kein <emphasis role="bold">BES</emphasis> - Erläuterungen zum BES gibts
  in der G400-Sektion oben) am Fernseher.
  Somit kannst du momentan nur den <emphasis>fbdev</emphasis>-Ausgabetreiber von
  <application>MPlayer</application> benutzen.
</para>

<para>
  Der erste CRTC kann momentan nicht an den zweiten Ausgang umgeleitet
  werden. Der Author des matroxfb-Kernelmoduls, Petr Vandrovec, wird auch das
  irgendwann unterstützen, indem die Ausgabe des ersten CRTC auf beiden
  Ausgängen angezeigt wird, wie es momentan auch für die G400
  empfohlen wird (siehe oben).
</para>

<para>
  Der dafür benötigte Kernelpatch und eine detaillierte Anleitung
  kann auf <ulink url="http://www.bglug.ca/matrox_tvout/"/> gefunden werden.
</para>
</sect2>


<sect2 id="tvout-ati">
<title>ATI-Karten</title>

<formalpara>
<title>EINLEITUNG</title>
<para>
  Momentan möchte ATI keinen einzigen ihrer TV-Ausgabe-Chips unter
  Linux unterstützen, da sie die Macrovision-Technologie lizensiert
  haben.
</para>
</formalpara>

<itemizedlist>
<title>STATUS DER ATI-TV-AUSGABEUNTERSTÜTZUNG UNTER LINUX</title>
<listitem><para>
  <emphasis role="bold">ATI Mach64</emphasis>:
  Von <ulink url="http://gatos.sf.net">GATOS</ulink> unterstützt.
</para></listitem>
<listitem><para>
  <emphasis role="bold">ASIC Radeon VIVO</emphasis>:
  Von <ulink url="http://gatos.sf.net">GATOS</ulink> unterstützt.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Radeon</emphasis> und <emphasis role="bold">Rage128</emphasis>:
  Von <application>MPlayer</application> unterstützt!
  Lies die <link linkend="vesa">VESA-Treiber-</link> und
  <link linkend="vidix">VIDIX</link>-Sektionen.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Rage Mobility P/M, Radeon, Rage 128, Mobility M3/M4</emphasis>:
  Von <ulink url="http://www.stud.uni-hamburg.de/users/lennart/projects/atitvout/">atitvout</ulink>
  unterstützt.
</para></listitem>
</itemizedlist>

<para>
  Verwende bei anderen Karten einfach den
  <link linkend="vesa">VESA-Treiber</link>
  ohne VIDIX. Dafür brauchst du aber eine schnelle CPU.
</para>

<para>
  Nur eines musst du tun - <emphasis role="bold">das TV-Kabel vor dem Booten
  eingesteckt haben</emphasis>, da das BIOS sich nur einmal während der
  POST-Prozedur initialisiert.
</para>
</sect2>


<sect2 id="tvout-nvidia">
<title>nVidia</title>
<para>
  Zuerst musst du die Closed-Source-Treiber von <ulink url="http://nvidia.com"/>
  herunterladen. Ich werde Installation und Konfiguration nicht im Detail
  beschreiben, da dies außerhalb der Aufgabe dieses Dokuments liegt.
</para>

<para>
  Nachdem du sichergestellt hast, dass XFree86, XVideo und die
  3D-Beschleunigung funktionieren, ändere die <filename>XF86Config</filename>,
  und passe das folgende Beispiel deiner Karte an:

<programlisting>
Section "Device"
        Identifier      "GeForce"
        VendorName      "ASUS"
        BoardName       "nVidia GeForce2/MX 400"
        Driver          "nvidia"
        #Option         "NvAGP" "1"
        Option          "NoLogo"
        Option          "CursorShadow"  "on"

        Option          "TwinView"
        Option          "TwinViewOrientation" "Clone"
        Option          "MetaModes" "1024x768,640x480"
        Option          "ConnectedMonitor" "CRT, TV"
        Option          "TVStandard" "PAL-B"
        Option          "TVOutFormat" "Composite"
EndSection
</programlisting>
</para>

<para>
  Natürlich besteht der wichtige Teil aus den TwinView-Optionen.
</para>
</sect2>

<sect2 id="tvout-neomagic">
<title>NeoMagic</title>
<para>
  Der NeoMagic-Chip befindet sich auf zahlreichen Laptops, einige von ihnen
  sind mit einen einfachen analogen TV-Encoder ausgestattet, einige besitzen
  einen fortschrittlicheren.
<itemizedlist>
<listitem><para>
  <emphasis role="bold">Analoger Encoder-Chip</emphasis>:
  Es wurde berichtet, dass ein zuverlässiger TV-Ausgang mittels
  <option>-vo fbdev</option> oder <option>-vo fbdev2</option>
  erreicht werden kann.
  Du musst vesafb in deinen Kernel compiliert haben und der
  Kernel-Befehlszeile folgende Parameter übergeben:
  <option>append="video=vesafb:ywrap,mtrr" vga=791</option>.
  Du solltest <application>X</application> starten, dann in den
  Consolen-Modus z.B. mit
  <keycombo><keycap>STRG</keycap><keycap>ALT</keycap><keycap>F1</keycap></keycombo> wechseln.
  Misslingt der Start von <application>X</application> vor dem von
  <application>MPlayer</application> in der Console, wird das Video
  langsam und abgehackt (Erklärungen sind willkommen).
  Logge dich auf deiner Konsole ein und initialisiere dann folgenden Befehl:

  <screen>clear; mplayer -vo fbdev -zoom -cache 8192 dvd://</screen>

  Jetzt solltest du den Film im Konsolen-Modus laufen sehen.
  Er wird etwa die Hälfte des LCD-Bildschirms deines Laptops ausfüllen.
  Um auf TV zu wechseln, drücke dreimal
  <keycombo><keycap>Fn</keycap><keycap>F5</keycap></keycombo>.
  Getestet auf einem Tecra 8000, 2.6.15 Kernel mit vesafb, ALSA v1.0.10.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Chrontel 70xx Encoder-Chip</emphasis>:
  Zu finden im IBM Thinkpad 390E und möglicherweise anderen Thinkpads oder
  Notebooks.
  </para><para>
  Du musst <option>-vo vesa:neotv_pal</option> für PAL oder
  <option>-vo vesa:neotv_ntsc</option> für NTSC verwenden.
  Es wird eine TV-Output-Funktion in folgenden 16bpp und 8bpp-Modi
  zur Verfügung stellen:
  </para>
  <itemizedlist>
    <listitem><para>NTSC 320x240, 640x480 und evtl. auch 800x600.</para></listitem>
    <listitem><para>PAL  320x240, 400x300, 640x480, 800x600.</para></listitem>
  </itemizedlist>
  <para>Der Modus 512x384 wird im BIOS nicht unterstützt. Du musst das Bild
  auf eine andere Auflösung skalieren, um die TV-Ausgabe zu aktivieren.
  Wenn du auf dem Schirm ein Bild in 640x480 oder in 800x600 siehst, jedoch nicht
  in 320x240 oder einer kleineren Auflösung, musst du zwei Tabellen in
  <filename>vbelib.c</filename> ersetzen.
  Siehe Funktion vbeSetTV für Details. Bitte kontaktiere in diesem Fall den Autor.
  </para>
  <para>
  Bekanntes Problem: Nur VESA, keine weiteren Schalter wie Helligkeit, Kontrast,
  Blacklevel, Flimmerfilter sind implementiert.
  </para>
</listitem>
</itemizedlist>
</para>
</sect2>
</sect1>

</chapter>
